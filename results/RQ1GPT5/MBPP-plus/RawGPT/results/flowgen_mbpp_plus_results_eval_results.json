{"date": "2025-12-06 15:21", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/59": [{"task_id": "Mbpp/59", "solution": "\"\"\"\nWrite a function to find the nth octagonal number.\nassert is_octagonal(5) == 65\n\"\"\"\ndef nth_octagonal(n: int) -> int:\n    \"\"\"\n    Return the nth octagonal number.\n    The nth octagonal number is O_n = n * (3n - 2) for n >= 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (3 * n - 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "\"\"\"\nWrite a function to find whether a given array of integers contains any duplicate element.\nassert test_duplicate(([1,2,3,4,5]))==False\n\"\"\"\ndef contains_duplicate(nums):\n    return len(nums) != len(set(nums))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "\"\"\"\nWrite a function to find squares of individual elements in a list.\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\"\"\"\ndef square_elements(lst):\n    \"\"\"\n    Return a list containing the squares of each element in the input list.\n    Assumes numeric elements (int, float). For non-numeric elements, a TypeError will be raised.\n    \"\"\"\n    return [x * x for x in lst]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "\"\"\"\nWrite a function to remove characters from the first string which are present in the second string.\nassert remove_dirty_chars(\"probasscurve\", \"pros\") == 'bacuve'\n\"\"\"\ndef remove_chars_from_string(s1, s2):\n    to_remove = set(s2)\n    return ''.join(ch for ch in s1 if ch not in to_remove)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "\"\"\"\nWrite a python function to find the volume of a triangular prism.\nassert find_Volume(10,8,6) == 240\n\"\"\"\ndef triangular_prism_volume(base: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    V = (1/2) * base * height * length\n    where 'base' and 'height' define the triangular base area, and 'length' is the prism length.\n    \"\"\"\n    if any(x is None for x in (base, height, length)):\n        raise ValueError(\"base, height, and length must be provided\")\n    try:\n        b = float(base)\n        h = float(height)\n        L = float(length)\n    except (TypeError, ValueError):\n        raise ValueError(\"base, height, and length must be numeric\")\n    if b < 0 or h < 0 or L < 0:\n        raise ValueError(\"base, height, and length must be non-negative\")\n    return 0.5 * b * h * L", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "\"\"\"\nWrite a function that returns the perimeter of a square given its side length as input.\nassert square_perimeter(10)==40\n\"\"\"\ndef square_perimeter(side_length):\n    \"\"\"\n    Return the perimeter of a square with the given side length.\n    side_length should be a non-negative number (int or float).\n    \"\"\"\n    return 4 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "\"\"\"\nWrite a python function to check if a given number is one less than twice its reverse.\nassert check(70) == False\n\"\"\"\ndef is_one_less_than_twice_reverse(n: int) -> bool:\n    if n < 0:\n        return False\n    rev = int(str(n)[::-1])\n    return n == 2 * rev - 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "\"\"\"\nWrite a python function to remove first and last occurrence of a given character from the string.\nassert remove_Occ(\"hello\",\"l\") == \"heo\"\n\"\"\"\ndef remove_first_and_last_occurrence(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the character `ch` from string `s`.\n    If `ch` does not occur in `s`, return `s` unchanged.\n    If `ch` occurs only once, remove that single occurrence.\n    \"\"\"\n    if not isinstance(s, str) or not isinstance(ch, str) or len(ch) != 1:\n        raise ValueError(\"s must be a string and ch must be a single character\")\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first + 1 :]\n    return s[:first] + s[first + 1 : last] + s[last + 1 :]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "\"\"\"\nWrite a python function to count the number of substrings with the sum of digits equal to their length.\nassert count_Substrings('112112') == 6\n\"\"\"\ndef count_substrings_with_sum_of_digits_equal_length(s: str) -> int:\n    from collections import defaultdict\n\n    freq = defaultdict(int)\n    freq[0] = 1  # prefix sum of 0 length\n    pref = 0\n    ans = 0\n\n    for ch in s:\n        d = ord(ch) - 48  # digit value\n        pref += d - 1     # sum of (digit - 1)\n        ans += freq[pref]\n        freq[pref] += 1\n\n    return ans", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/2": [{"task_id": "Mbpp/2", "solution": "\"\"\"\nWrite a function to find the shared elements from the given two lists.\nassert set(similar_elements((3, 4, 5, 6),(5, 7, 4, 10))) == set((4, 5))\n\"\"\"\ndef find_shared_elements(list1, list2):\n    \"\"\"\n    Return the elements that appear in both input lists.\n    The result contains unique elements, preserving the order\n    of their first appearance in list1.\n    Works for hashable elements (fast). Falls back to equality-based check\n    for unhashable elements.\n    \"\"\"\n    try:\n        set2 = set(list2)\n        seen = set()\n        result = []\n        for x in list1:\n            if x in set2 and x not in seen:\n                result.append(x)\n                seen.add(x)\n        return result\n    except TypeError:\n        # Fallback for unhashable elements\n        seen = []\n        result = []\n        for x in list1:\n            if any(x == y for y in list2) and not any(x == s for s in seen):\n                result.append(x)\n                seen.append(x)\n        return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "\"\"\"\nWrite a function to find all words which are at least 4 characters long in a string.\nassert set(find_char_long('Please move back to stream')) == set(['Please', 'move', 'back', 'stream'])\n\"\"\"\ndef find_words_at_least_four(text):\n    \"\"\"\n    Return a list of all sequences of consecutive alphabetic characters in 'text'\n    that have length >= 4. A word is defined as a maximal run of Unicode letters.\n    \"\"\"\n    result = []\n    current = []\n    for ch in text:\n        if ch.isalpha():\n            current.append(ch)\n        else:\n            if len(current) >= 4:\n                result.append(''.join(current))\n            current = []\n    if len(current) >= 4:\n        result.append(''.join(current))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "\"\"\"\nWrite a python function to find smallest number in a list.\nassert smallest_num([10, 20, 1, 45, 99]) == 1\n\"\"\"\ndef find_smallest_number(numbers):\n    if numbers is None or len(numbers) == 0:\n        raise ValueError(\"The input list is empty.\")\n    min_val = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] < min_val:\n            min_val = numbers[i]\n    return min_val", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "\"\"\"\nWrite a python function to check whether the two numbers differ at one bit position only or not.\nassert differ_At_One_Bit_Pos(13,9) == True\n\"\"\"\ndef differ_by_one_bit(a, b):\n    diff = a ^ b\n    return diff > 0 and (diff & (diff - 1)) == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "\"\"\"\nWrite a function to sort a given matrix in ascending order according to the sum of its rows.\nassert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]\n\"\"\"\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sorts a matrix (list of lists) by the ascending sum of each row.\n    Returns a new matrix with rows reordered accordingly.\n    \"\"\"\n    if matrix is None:\n        raise ValueError(\"matrix cannot be None\")\n    if not isinstance(matrix, list):\n        raise TypeError(\"matrix must be a list of rows\")\n    for i, row in enumerate(matrix):\n        if not isinstance(row, list):\n            raise TypeError(\"matrix must be a list of lists (rows)\")\n        if not all(isinstance(x, (int, float)) for x in row):\n            raise TypeError(\"all row elements must be numeric (int or float)\")\n    sorted_rows = sorted(matrix, key=lambda r: sum(r))\n    return [row[:] for row in sorted_rows]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "\"\"\"\nWrite a python function to find the largest number that can be formed with the given list of digits.\nassert find_Max_Num([1,2,3]) == 321\n\"\"\"\ndef largest_number_from_digits(digits):\n    \"\"\"\n    Return the largest integer that can be formed by permuting the given digits (0-9).\n    If digits is empty, return 0.\n    \"\"\"\n    if digits is None:\n        raise ValueError(\"digits must not be None\")\n    if not isinstance(digits, (list, tuple)):\n        raise TypeError(\"digits must be a list or tuple of integers 0-9\")\n    if len(digits) == 0:\n        return 0\n    for d in digits:\n        if not isinstance(d, int) or d < 0 or d > 9:\n            raise ValueError(\"all elements must be integers in the range 0-9\")\n    sorted_digits = sorted(digits, reverse=True)\n    result = ''.join(str(d) for d in sorted_digits)\n    return int(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "\"\"\"\nWrite a python function to check whether the given two integers have opposite sign or not.\nassert opposite_Signs(1,-2) == True\n\"\"\"\ndef opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check if two integers have opposite signs.\n    Returns True if one is positive and the other is negative.\n    Zeros are not considered to have a sign, so (0, x) or (x, 0) returns False.\n    \"\"\"\n    return a * b < 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "\"\"\"\nWrite a function to find the n largest integers from a given list of numbers, returned in descending order.\nassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65]\n\"\"\"\nimport heapq\nfrom typing import List\n\ndef n_largest_integers(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Return the n largest integers from nums in descending order.\n    If n <= 0 or nums is empty, return an empty list.\n    If n >= len(nums), return the entire list sorted in descending order.\n    \"\"\"\n    if n <= 0 or not nums:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    return heapq.nlargest(n, nums)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "\"\"\"\nWrite a function to check if the given number is woodball or not.\nassert is_woodall(383) == True\n\"\"\"\ndef is_woodball(n: int) -> bool:\n    \"\"\"\n    Check if n is a Woodall number: n = k * 2^k - 1 for some integer k >= 1.\n    Returns True if such k exists, otherwise False.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n    t = n + 1\n    k = 1\n    while True:\n        val = k * (1 << k)\n        if val == t:\n            return True\n        if val > t:\n            return False\n        k += 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "\"\"\"\nWrite a function to find the maximum difference between available pairs in the given tuple list.\nassert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n\"\"\"\ndef max_pair_difference(pairs):\n    \"\"\"\n    Return the maximum absolute difference between the two elements of any 2-element tuple\n    in the input list 'pairs'. If the list is empty, return 0.\n    \"\"\"\n    if not pairs:\n        return 0\n\n    max_diff = 0\n    for t in pairs:\n        if not isinstance(t, tuple) or len(t) != 2:\n            raise ValueError(\"Each item must be a 2-element tuple.\")\n        a, b = t\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "\"\"\"\nWrite a python function to check whether the length of the word is odd or not.\nassert word_len(\"Hadoop\") == False\n\"\"\"\ndef is_word_length_odd(word: str) -> bool:\n    \"\"\"\n    Return True if the length of the input word is odd, otherwise False.\n    \"\"\"\n    return len(word) % 2 == 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "\"\"\"\nWrite a python function to check whether the given array is monotonic or not.\nassert is_Monotonic([6, 5, 4, 4]) == True\n\"\"\"\ndef is_monotonic(arr):\n    return all(arr[i] >= arr[i - 1] for i in range(1, len(arr))) or all(arr[i] <= arr[i - 1] for i in range(1, len(arr)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "\"\"\"\nWrite a function to check whether a list contains the given sublist or not.\nassert is_sublist([2,4,3,5,7],[3,7])==False\n\"\"\"\ndef contains_sublist(lst, sublst):\n    \"\"\"\n    Return True if sublst appears as a contiguous subsequence of lst.\n    An empty sublst is considered to be contained in any list.\n    \"\"\"\n    if not isinstance(lst, list) or not isinstance(sublst, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if not sublst:\n        return True\n    if len(sublst) > len(lst):\n        return False\n\n    sub_len = len(sublst)\n    for i in range(len(lst) - sub_len + 1):\n        if lst[i:i + sub_len] == sublst:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "\"\"\"\nWrite a python function to identify non-prime numbers.\nassert is_not_prime(2) == False\n\"\"\"\ndef identify_non_primes(numbers):\n    \"\"\"\n    Given an iterable of integers, return a list of non-prime numbers\n    among them. Non-prime includes numbers < 2 (e.g., 0, 1) and composite numbers.\n    The input order is preserved.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        if n % 2 == 0:\n            return n == 2\n        if n % 3 == 0:\n            return n == 3\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    out = []\n    for x in numbers:\n        if not isinstance(x, int):\n            raise TypeError(\"All elements must be integers.\")\n        if not is_prime(x):\n            out.append(x)\n    return out", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "\"\"\"\nWrite a function to find whether all the given tuples have equal length or not.\nassert get_equal([(11, 22, 33), (44, 55, 66)]) == True\n\"\"\"\ndef all_tuples_equal_length(tuples):\n    \"\"\"\n    Return True if all tuples in the iterable have the same length.\n    Empty iterable or a single tuple is considered to have equal lengths.\n    Raises TypeError if any element in the iterable is not a tuple.\n    \"\"\"\n    lengths = set()\n    for item in tuples:\n        if not isinstance(item, tuple):\n            raise TypeError(\"All elements must be tuples\")\n        lengths.add(len(item))\n        if len(lengths) > 1:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "\"\"\"\nWrite a function to sort a list of tuples using the second value of each tuple.\nassert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\n\"\"\"\ndef sort_by_second(tuples_list, reverse=False):\n    \"\"\"\n    Return a new list of tuples sorted by their second element (index 1).\n    Tuples without a second element are placed after those that have one.\n    \"\"\"\n    return sorted(tuples_list, key=lambda t: (0, t[1]) if len(t) > 1 else (1, None), reverse=reverse)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "\"\"\"\nWrite a python function to count the number of positive numbers in a list.\nassert pos_count([1,-2,3,-4]) == 2\n\"\"\"\ndef count_positive_numbers(nums):\n    count = 0\n    for x in nums:\n        try:\n            if x > 0:\n                count += 1\n        except TypeError:\n            pass\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "\"\"\"\nWrite a function to find the surface area of a sphere.\nassert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)\n\"\"\"\nimport math\n\ndef surface_area_of_sphere(radius: float) -> float:\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n    Surface area = 4 * pi * r^2\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 4 * math.pi * (radius ** 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "\"\"\"\nWrite a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\nassert text_lowercase_underscore(\"aab_cbbbc\")==(True)\n\"\"\"\ndef contains_lowercase_sequences_joined_with_underscore(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    parts = s.split('_')\n    if len(parts) < 2:\n        return False\n    for part in parts:\n        if not part or not all('a' <= ch <= 'z' for ch in part):\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "\"\"\"\nWrite a function to find the nth tetrahedral number.\nassert tetrahedral_number(5) == 35\n\"\"\"\ndef tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Return the nth tetrahedral number T_n = n*(n+1)*(n+2)/6.\n    n must be a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return n * (n + 1) * (n + 2) // 6", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "\"\"\"\nWrite a function to get the frequency of all the elements in a list, returned as a dictionary.\nassert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})\n\"\"\"\ndef frequency_dict(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "\"\"\"\nWrite a python function to check whether the given number can be represented as the difference of two squares or not.\nassert dif_Square(5) == True\n\"\"\"\ndef can_be_difference_of_squares(n):\n    \"\"\"\n    Check if integer n can be represented as x^2 - y^2 for some integers x, y.\n    A number can be represented as a difference of two squares iff n is not congruent to 2 modulo 4.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return n % 4 != 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "\"\"\"\nWrite a function to flatten a list and sum all of its elements.\nassert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21\n\"\"\"\ndef flatten_and_sum(data):\n    \"\"\"\n    Flatten a nested list (containing lists or numbers) and return the sum of all numeric elements.\n    Nested structures are explored recursively. Only numbers (int/float) are summed.\n    \"\"\"\n    if isinstance(data, (int, float)):\n        return data\n    if not isinstance(data, list):\n        raise TypeError(\"Input must be a list or nested lists of numbers.\")\n    total = 0\n    for item in data:\n        if isinstance(item, list):\n            total += flatten_and_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n        else:\n            raise TypeError(\"All elements must be numbers or lists of numbers.\")\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "\"\"\"\nWrite a function to find the number of ways to partition a set of Bell numbers.\nassert bell_number(2)==2\n\"\"\"\ndef number_of_partitions_of_set_of_bell_numbers(n):\n    \"\"\"\n    Return the number of ways to partition a set of size n (i.e., the Bell number B(n)).\n    Uses the recurrence B(0)=1, B(n+1)=sum_{k=0}^n C(n,k)*B(k).\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for m in range(n):\n        total = 0\n        c = 1  # C(m, 0)\n        for k in range(0, m + 1):\n            total += c * bell[k]\n            if k < m:\n                c = c * (m - k) // (k + 1)\n        bell[m + 1] = total\n    return bell[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "\"\"\"\nWrite a function to find the nth number in the newman conway sequence.\nassert sequence(10) == 6\n\"\"\"\ndef newman_conway(n):\n    \"\"\"\n    Return the nth term of the Newman-Conway sequence (A004001).\n    a(1) = 1, a(2) = 1, for n > 2: a(n) = a(a(n-1)) + a(n - a(n-1))\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    if n <= 2:\n        return 1\n    a = [0] * (n + 1)\n    a[1] = 1\n    a[2] = 1\n    for i in range(3, n + 1):\n        k = a[i - 1]\n        a[i] = a[k] + a[i - k]\n    return a[n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "\"\"\"\nWrite a python function to find whether a number is divisible by 11.\nassert is_Diff (12345) == False\n\"\"\"\ndef is_divisible_by_11(n):\n    \"\"\"\n    Check divisibility by 11 for an integer.\n    Accepts int or string (optional leading +/-).\n    Returns True if divisible by 11, else False.\n    \"\"\"\n    if isinstance(n, int):\n        return n % 11 == 0\n    if isinstance(n, str):\n        s = n.strip()\n        if not s:\n            raise ValueError(\"Input string is empty.\")\n        if s[0] in '+-':\n            s = s[1:]\n        if not s.isdigit():\n            raise ValueError(\"Input string must be a valid integer.\")\n        rem = 0\n        for ch in s:\n            rem = (rem * 10 + (ord(ch) - 48)) % 11\n        return rem == 0\n    raise TypeError(\"Input must be an int or string representing an integer.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "\"\"\"\nWrite a python function to find the minimum number of rotations (greater than 0) required to get the same string.\nassert find_Rotations(\"aaaa\") == 1\n\"\"\"\ndef min_rotations_to_match(s: str) -> int:\n    \"\"\"\n    Return the smallest positive k such that rotating s left by k positions yields s.\n    If no such k exists for k < len(s), return len(s).\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Build prefix function (KMP) for s\n    lps = [0] * n\n    length = 0\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    period = n - lps[-1]\n    if lps[-1] > 0 and n % period == 0:\n        return period\n    return n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "\"\"\"\nWrite a function to find nth centered hexagonal number.\nassert centered_hexagonal_number(10) == 271\n\"\"\"\ndef nth_centered_hexagonal(n):\n    \"\"\"\n    Return the nth centered hexagonal number.\n    The sequence starts with n = 1 -> 1, n = 2 -> 7, n = 3 -> 19, ...\n    Formula: H(n) = 3n(n - 1) + 1\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return 3 * n * (n - 1) + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "\"\"\"\nWrite a function to sort a list of elements.\nassert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]\n\"\"\"\nfrom typing import Iterable, Callable, TypeVar, List, Optional, Any\n\nT = TypeVar('T')\n\ndef sort_list(items: Iterable[T], key: Optional[Callable[[T], Any]] = None, reverse: bool = False) -> List[T]:\n    \"\"\"\n    Return a new list containing all elements from items sorted in ascending order by the provided key.\n    - key: function applied to elements to determine sort order. If None, elements themselves are compared.\n    - reverse: if True, sort in descending order.\n    \"\"\"\n    arr = list(items)\n\n    def k(x: T) -> Any:\n        return key(x) if key is not None else x\n\n    def merge(left: List[T], right: List[T]) -> List[T]:\n        i = j = 0\n        merged: List[T] = []\n        while i < len(left) and j < len(right):\n            if k(left[i]) <= k(right[j]):\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        return merged\n\n    def merge_sort(seq: List[T]) -> List[T]:\n        n = len(seq)\n        if n <= 1:\n            return seq[:]\n        mid = n // 2\n        left = merge_sort(seq[:mid])\n        right = merge_sort(seq[mid:])\n        return merge(left, right)\n\n    sorted_list = merge_sort(arr)\n    if reverse:\n        sorted_list.reverse()\n    return sorted_list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "\"\"\"\nWrite a function to find tuples which have all elements divisible by k from the given list of tuples.\nassert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]\n\"\"\"\ndef find_tuples_divisible_by_k(tuples_list, k):\n    if k == 0:\n        raise ValueError(\"k must be non-zero\")\n    result = []\n    for t in tuples_list:\n        if isinstance(t, tuple):\n            if all(isinstance(x, (int, float)) and (x % k) == 0 for x in t):\n                result.append(t)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "\"\"\"\nWrite a function to find the volume of a sphere.\nassert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)\n\"\"\"\ndef volume_of_sphere(radius):\n    \"\"\"\n    Compute the volume of a sphere with the given radius.\n    Volume = (4/3) * pi * r^3\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    return (4.0/3.0) * 3.141592653589793 * (radius ** 3)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "\"\"\"\nWrite a python function to find the length of the smallest list in a list of lists.\nassert Find_Min_Length([[1],[1,2]]) == 1\n\"\"\"\ndef length_of_smallest_sublist(list_of_lists):\n    \"\"\"\n    Return the length of the smallest sublist within a list of lists.\n    Raises ValueError if the outer list is empty.\n    \"\"\"\n    if not isinstance(list_of_lists, list) or len(list_of_lists) == 0:\n        raise ValueError(\"Input must be a non-empty list of lists.\")\n    return min(len(sub) for sub in list_of_lists)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "\"\"\"\nWrite a python function to find the length of the longest word.\nassert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\n\"\"\"\ndef longest_word_length(text: str) -> int:\n    \"\"\"\n    Return the length of the longest word in the input string.\n    A word is defined as a maximal sequence of non-space characters.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"text must be a string\")\n    words = text.split()\n    return max((len(word) for word in words), default=0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "\"\"\"\nWrite a function to find the closest smaller number than n.\nassert closest_num(11) == 10\n\"\"\"\ndef closest_smaller(nums, n):\n    \"\"\"\n    Return the closest number in nums that is strictly less than n.\n    If no such number exists, return None.\n    \"\"\"\n    closest = None\n    for x in nums:\n        if x < n:\n            if closest is None or x > closest:\n                closest = x\n    return closest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "\"\"\"\nWrite a function to check if a string is present as a substring in a given list of string values.\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True\n\"\"\"\nfrom typing import Iterable\n\ndef is_substring_in_list(substr: str, values: Iterable[str]) -> bool:\n    return any(substr in s for s in values)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "\"\"\"\nWrite a function to find the kth element in the given array using 1-based indexing.\nassert kth_element([12,3,5,7,19], 2) == 3\n\"\"\"\ndef kth_element(arr, k):\n    \"\"\"\n    Return the kth element (1-based) from the sequence 'arr'.\n    Raises:\n        TypeError: if arr is not a sequence or k is not an integer.\n        IndexError: if k is out of bounds (1 <= k <= len(arr)).\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    try:\n        n = len(arr)\n    except TypeError:\n        raise TypeError(\"arr must be a sequence with a length\")\n    if k < 1 or k > n:\n        raise IndexError(\"k is out of range for the given array\")\n    return arr[k - 1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "\"\"\"\nWrite a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}\n\"\"\"\ndef frequency_of_elements(list_of_lists):\n    \"\"\"\n    Flatten a list of lists and count frequency of each element.\n    Returns a dictionary {element: count}.\n    \"\"\"\n    freq = {}\n    for sub in list_of_lists:\n        for item in sub:\n            freq[item] = freq.get(item, 0) + 1\n    return freq", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "\"\"\"\nGiven a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\nassert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'\n\"\"\"\ndef first_value_of_min_second(pairs):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element.\n    If the input list is empty, returns None.\n    All tuples are expected to have at least two elements.\n    Ties are resolved by choosing the earliest tuple in the list.\n    \"\"\"\n    if not pairs:\n        return None\n    best = None\n    for t in pairs:\n        if len(t) < 2:\n            raise ValueError(\"Each tuple must have at least two elements.\")\n        if best is None or t[1] < best[1]:\n            best = t\n    return best[0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "\"\"\"\nWrite a function to calculate the value of 'a' to the power 'b'.\nassert power(3,4) == 81\n\"\"\"\ndef power(a, b):\n    \"\"\"\n    Compute a raised to the power b.\n    Supports integer exponents efficiently using exponentiation by squaring.\n    For non-integer exponents, falls back to Python's built-in operator.\n    \"\"\"\n    if b == 0:\n        return 1\n    if a == 0:\n        if b > 0:\n            return 0\n        elif b < 0:\n            raise ValueError(\"0 cannot be raised to a negative power\")\n        else:\n            return 1\n    if isinstance(b, int):\n        exp = b\n        base = a\n        if exp < 0:\n            base = 1.0 / a\n            exp = -exp\n        result = 1\n        while exp:\n            if exp & 1:\n                result *= base\n            base *= base\n            exp >>= 1\n        return result\n    else:\n        return a ** b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "\"\"\"\nWrite a function to multiply all the numbers in a list and divide with the length of the list.\nassert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)\n\"\"\"\ndef multiply_and_divide_by_length(nums):\n    \"\"\"\n    Multiply all numbers in nums and divide by the length of nums.\n    Returns the resulting float. Raises ValueError if nums is empty.\n    \"\"\"\n    try:\n        values = list(nums)\n    except TypeError as e:\n        raise TypeError(\"nums must be an iterable of numbers\") from e\n\n    n = len(values)\n    if n == 0:\n        raise ValueError(\"Input must contain at least one number.\")\n\n    product = 1.0\n    for v in values:\n        if not isinstance(v, (int, float)):\n            raise TypeError(\"All elements must be numeric (int or float).\")\n        product *= v\n\n    return product / n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "\"\"\"\nWrite a function to check whether the given number is undulating or not.\nassert is_undulating(1212121) == True\n\"\"\"\ndef is_undulating(number):\n    n = abs(int(number))\n    digits = [int(ch) for ch in str(n)]\n    if len(digits) <= 1:\n        return True\n    diffs = []\n    for i in range(1, len(digits)):\n        diff = digits[i] - digits[i - 1]\n        if diff == 0:\n            return False\n        diffs.append(diff)\n    for i in range(1, len(diffs)):\n        if diffs[i] * diffs[i - 1] >= 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2121212121212120]]}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "\"\"\"\nWrite a python function to find the number of divisors of a given integer.\nassert divisor(15) == 4\n\"\"\"\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Return the number of positive divisors of n.\n    For n == 0, returns 0 (defined as a placeholder since zero has infinite divisors).\n    For negative n, the function uses the absolute value.\n    \"\"\"\n    if n == 0:\n        return 0\n    n = abs(n)\n    result = 1\n\n    # Factor out the power of 2\n    if n % 2 == 0:\n        exp = 0\n        while n % 2 == 0:\n            n //= 2\n            exp += 1\n        result *= (exp + 1)\n\n    # Factor out odd primes\n    p = 3\n    while p * p <= n:\n        if n % p == 0:\n            exp = 0\n            while n % p == 0:\n                n //= p\n                exp += 1\n            result *= (exp + 1)\n        p += 2\n\n    if n > 1:\n        result *= 2  # remaining prime factor\n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "\"\"\"\nWrite a function to check whether it follows the sequence given in the patterns array.\nassert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True\n\"\"\"\ndef follows_pattern(sequence, patterns):\n    \"\"\"\n    Check if 'sequence' follows the structure defined by 'patterns'.\n    Returns True if for all i, j: sequence[i] == sequence[j] iff patterns[i] == patterns[j].\n    Works with nested and unhashable elements by converting them to a hashable representation.\n    \"\"\"\n    if len(sequence) != len(patterns):\n        return False\n\n    def to_hashable(x):\n        if isinstance(x, dict):\n            return tuple(sorted((to_hashable(k), to_hashable(v)) for k, v in x.items()))\n        if isinstance(x, (list, tuple)):\n            return tuple(to_hashable(i) for i in x)\n        if isinstance(x, set):\n            return frozenset(to_hashable(i) for i in x)\n        return x\n\n    p2v = {}\n    v2p = {}\n    for p, v in zip(patterns, sequence):\n        hp = to_hashable(p)\n        hv = to_hashable(v)\n        if hp in p2v:\n            if p2v[hp] != hv:\n                return False\n        else:\n            p2v[hp] = hv\n        if hv in v2p:\n            if v2p[hv] != hp:\n                return False\n        else:\n            v2p[hv] = hp\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "\"\"\"\nWrite a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\nassert decimal_to_binary(8) == '1000'\n\"\"\"\ndef decimal_to_binary(n: int) -> str:\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n == 0:\n        return \"0\"\n    sign = '-' if n < 0 else ''\n    m = abs(n)\n    bits = []\n    while m:\n        bits.append('1' if (m & 1) else '0')\n        m >>= 1\n    return sign + ''.join(reversed(bits))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "\"\"\"\nWrite a function to convert a snake case string to camel case string.\nassert snake_to_camel('python_program')=='PythonProgram'\n\"\"\"\ndef snake_to_camel(s: str) -> str:\n    \"\"\"\n    Convert a snake_case string to camelCase.\n    Consecutive underscores are treated as separators; leading/trailing underscores are ignored.\n    \"\"\"\n    if not isinstance(s, str):\n        s = str(s)\n    parts = [p for p in s.split('_') if p]\n    if not parts:\n        return \"\"\n    first = parts[0].lower()\n    rest = ''.join(p.capitalize() for p in parts[1:])\n    return first + rest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python_program"]], "plus_fail_tests": [["___python_program"]]}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "\"\"\"\nWrite a python function to count true booleans in the given list.\nassert count([True,False,True]) == 2\n\"\"\"\ndef count_true_booleans(lst):\n    return sum(1 for item in lst if isinstance(item, bool) and item)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "\"\"\"\nWrite a function to sort each sublist of strings in a given list of lists.\nassert sort_sublists(([\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]))==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n\"\"\"\nfrom typing import List\n\ndef sort_sublists_of_strings(list_of_lists: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sort each sublist of strings in the given list of lists in-place.\n\n    Assumes every inner element is a list containing strings.\n    Returns the input outer list for convenient chaining.\n    \"\"\"\n    for sublist in list_of_lists:\n        if isinstance(sublist, list):\n            sublist.sort()\n    return list_of_lists", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "\"\"\"\nWrite a function to append the given list to the given tuples.\nassert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\n\"\"\"\ndef append_list_to_tuple(tup, lst):\n    \"\"\"\n    Append the elements of the list `lst` to the end of the tuple `tup`\n    and return the resulting tuple.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    return tup + tuple(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "\"\"\"\nWrite a function to check if a string represents an integer or not.\nassert check_integer(\"python\")==False\n\"\"\"\ndef is_integer_string(s):\n    try:\n        int(s)\n        return True\n    except (ValueError, TypeError):\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "\"\"\"\nWrite a function to convert a string to a list of strings split on the space character.\nassert string_to_list(\"python programming\")==['python','programming']\n\"\"\"\ndef split_on_space(s):\n    \"\"\"\n    Split the input string on the space character and return the list of substrings.\n    \"\"\"\n    return s.split(' ')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "\"\"\"\nWrite a python function to find the element that appears only once in a sorted array.\nassert search([1,1,2,2,3]) == 3\n\"\"\"\ndef find_single_element(nums):\n    \"\"\"\n    Find the element that appears only once in a sorted array\n    where every other element appears exactly twice.\n    Returns the single element.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input array must not be empty\")\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    return nums[left]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "\"\"\"\nWrite a function to merge three dictionaries into a single dictionary.\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{ \"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\" })=={'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}\n\"\"\"\ndef merge_three_dicts(d1, d2, d3):\n    \"\"\"\n    Merge three dictionaries into a new dictionary.\n    Keys from later dictionaries override earlier ones.\n    \"\"\"\n    result = {}\n    if d1 is not None:\n        result.update(d1)\n    if d2 is not None:\n        result.update(d2)\n    if d3 is not None:\n        result.update(d3)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "\"\"\"\nWrite a function to find words that are longer than n characters from a given list of words.\nassert long_words(3,\"python is a programming language\")==['python','programming','language']\n\"\"\"\ndef words_longer_than(words, n):\n    \"\"\"\n    Return a list of words from the input list that have length strictly greater than n.\n    Non-string elements are ignored.\n    \"\"\"\n    return [w for w in words if isinstance(w, str) and len(w) > n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "\"\"\"\nWrite a function to find the common elements in given nested lists.\nassert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])\n\"\"\"\ndef common_elements(nested_lists):\n    def flatten(item):\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                yield from flatten(x)\n        else:\n            yield item\n\n    if not nested_lists:\n        return []\n\n    sets = []\n    for sub in nested_lists:\n        s = set()\n        for v in flatten(sub):\n            s.add(v)\n        sets.append(s)\n\n    common = sets[0].copy()\n    for s in sets[1:]:\n        common &= s\n        if not common:\n            break\n\n    if not common:\n        return []\n\n    try:\n        return sorted(common)\n    except TypeError:\n        return list(common)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "\"\"\"\nWrite a python function to reverse only the vowels of a given string (where y is not a vowel).\nassert reverse_vowels(\"Python\") == \"Python\"\n\"\"\"\ndef reverse_vowels(s: str) -> str:\n    \"\"\"\n    Return a new string where only the vowels in s are reversed.\n    Vowels are a, e, i, o, u (both cases). 'y' is not considered a vowel.\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    vlist = [c for c in s if c in vowels]\n    i = len(vlist) - 1\n    out_chars = []\n    for ch in s:\n        if ch in vowels:\n            out_chars.append(vlist[i])\n            i -= 1\n        else:\n            out_chars.append(ch)\n    return ''.join(out_chars)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "\"\"\"\nWrite a function to multiply two integers.\nassert multiply_int(10,20)==200\n\"\"\"\ndef multiply(a: int, b: int) -> int:\n    if a == 0 or b == 0:\n        return 0\n    negative = (a < 0) ^ (b < 0)\n    a, b = abs(a), abs(b)\n    result = 0\n    while b:\n        if b & 1:\n            result += a\n        a <<= 1\n        b >>= 1\n    return -result if negative else result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "\"\"\"\nWrite a function to calculate the sum of the negative numbers of a given list of numbers.\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32\n\"\"\"\ndef sum_negative_numbers(nums):\n    \"\"\"Return the sum of negative numbers in nums. Non-numeric values are ignored.\"\"\"\n    return sum(x for x in nums if isinstance(x, (int, float)) and x < 0)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "\"\"\"\nWrite a function to merge three lists into a single sorted list.\nassert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]\n\"\"\"\ndef merge_three_lists(a, b, c):\n    return sorted(list(a) + list(b) + list(c))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "\"\"\"\nWrite a function to find the nth hexagonal number.\nassert hexagonal_num(10) == 190\n\"\"\"\ndef hexagonal_number(n: int) -> int:\n    \"\"\"\n    Return the nth hexagonal number, H(n) = n(2n - 1).\n    n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (2 * n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "\"\"\"\nWrite a function to find the item with maximum frequency in a given list.\nassert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2\n\"\"\"\ndef max_freq_item(lst):\n    if not lst:\n        return None\n    counts = {}\n    for item in lst:\n        counts[item] = counts.get(item, 0) + 1\n    max_count = max(counts.values())\n    for item in lst:\n        if counts[item] == max_count:\n            return item\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "\"\"\"\nWrite a function to find the circumference of a circle.\nassert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)\n\"\"\"\nimport math\n\ndef circumference(radius):\n    \"\"\"Return the circumference of a circle given its radius.\"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    return 2 * math.pi * radius", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "\"\"\"\nWrite a function to find the Eulerian number a(n, m).\nassert eulerian_num(3, 1) == 4\n\"\"\"\ndef a(n, m):\n    \"\"\"\n    Eulerian number A(n, m): number of permutations of {1..n} with exactly m descents.\n    Returns 0 for invalid inputs.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1 if m == 0 else 0\n    if m < 0 or m >= n:\n        return 0\n\n    dp_prev = [1]  # A(1,0) = 1\n    for k in range(2, n + 1):\n        dp_cur = [0] * k\n        for j in range(k):\n            val = 0\n            if j - 1 >= 0:\n                val += (k - j) * dp_prev[j - 1]\n            if j < len(dp_prev):\n                val += (j + 1) * dp_prev[j]\n            dp_cur[j] = val\n        dp_prev = dp_cur\n\n    return dp_prev[m]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "\"\"\"\nWrite a function to get the angle of a complex number.\nassert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)\n\"\"\"\ndef angle_of_complex(z):\n    \"\"\"\n    Return the angle (argument) of a complex number z in radians.\n    Accepts any value convertible to a complex number.\n    \"\"\"\n    import cmath\n    return cmath.phase(complex(z))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "\"\"\"\nWrite a function to count number items that are identical in the same position of three given lists.\nassert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3\n\"\"\"\ndef count_identical_in_position(a, b, c):\n    \"\"\"\n    Count the number of positions where the three lists have the same value.\n    Considers positions up to the length of the shortest list.\n    \"\"\"\n    return sum(1 for x, y, z in zip(a, b, c) if x == y == z)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "\"\"\"\nWrite a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nassert is_Sum_Of_Powers_Of_Two(10) == True\n\"\"\"\ndef can_be_sum_of_nonzero_powers_of_two(n):\n    \"\"\"\n    Checks if n can be represented as the sum of non-zero powers of two (2^k for k>=1).\n    This is true exactly when n is a positive even integer.\n    \"\"\"\n    return isinstance(n, int) and n > 0 and n % 2 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "\"\"\"\nWrite a function to find the ratio of zeroes to non-zeroes in an array of integers.\nassert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)\n\"\"\"\nfrom typing import Optional, Sequence\n\ndef ratio_zero_to_nonzero(arr: Sequence[int]) -> Optional[float]:\n    \"\"\"\n    Returns the ratio of zeros to non-zero elements in the input sequence.\n    - If there are no non-zero elements but there are zeros, returns float('inf').\n    - If the input is empty (zeros == 0 and non-zeros == 0), returns None.\n    - Otherwise, returns zeros / non_zeros as a float.\n    \"\"\"\n    zeros = 0\n    for x in arr:\n        if x == 0:\n            zeros += 1\n    total = len(arr)\n    nonzeros = total - zeros\n    if nonzeros == 0:\n        return None if zeros == 0 else float('inf')\n    return zeros / nonzeros", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "\"\"\"\nWrite a function to convert a given tuple of positive integers into a single integer.\nassert tuple_to_int((1,2,3))==123\n\"\"\"\ndef encode_tuple_to_int(t):\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple of positive integers.\")\n    if len(t) == 0:\n        raise ValueError(\"Tuple must be non-empty.\")\n    for x in t:\n        if not isinstance(x, int) or x <= 0:\n            raise ValueError(\"All elements must be positive integers.\")\n\n    def pair(a, b):\n        s = a + b\n        return s * (s + 1) // 2 + b\n\n    res = t[0]\n    for x in t[1:]:\n        res = pair(res, x)\n    return res", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "\"\"\"\nWrite a function to convert a tuple to a string.\nassert tup_string(('e', 'x', 'e', 'r', 'c', 'i', 's', 'e', 's'))==(\"exercises\")\n\"\"\"\ndef tuple_to_string(t, sep=\"\"):\n    \"\"\"\n    Converts a tuple to a string by concatenating its elements.\n    - Non-string elements are converted using str().\n    - Nested tuples are flattened recursively.\n    - A custom separator can be provided to join top-level elements.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n\n    def convert(item):\n        if isinstance(item, tuple):\n            return ''.join(convert(e) for e in item)\n        else:\n            return str(item)\n\n    return sep.join(convert(elem) for elem in t)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "\"\"\"\nWrite a function to calculate whether the matrix is a magic square.\nassert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True\n\"\"\"\ndef is_magic_square(matrix):\n    \"\"\"\n    Check if the given matrix is a magic square of order n.\n\n    A magic square is an n x n matrix containing the numbers 1 through n^2\n    exactly once, such that the sums of the numbers in each row, each column,\n    and both main diagonals are all equal.\n\n    Returns True if the matrix is a magic square, otherwise False.\n    \"\"\"\n    if not matrix:\n        return False\n\n    n = len(matrix)\n    # Ensure it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Target sum from the first row\n    target = sum(matrix[0])\n\n    # Check all row sums\n    for row in matrix:\n        if sum(row) != target:\n            return False\n\n    # Check all column sums\n    for c in range(n):\n        s = 0\n        for r in range(n):\n            s += matrix[r][c]\n        if s != target:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != target:\n        return False\n\n    # Check for numbers 1..n^2 exactly once\n    expected = set(range(1, n * n + 1))\n    flat = {matrix[i][j] for i in range(n) for j in range(n)}\n    if flat != expected:\n        return False\n\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "\"\"\"\nWrite a python function to find the sum of common divisors of two given numbers.\nassert sum(10,15) == 6\n\"\"\"\nimport math\n\ndef sum_of_common_divisors(a, b):\n    g = math.gcd(abs(a), abs(b))\n    if g == 0:\n        return 0\n    total = 0\n    limit = int(g ** 0.5)\n    for i in range(1, limit + 1):\n        if g % i == 0:\n            total += i\n            other = g // i\n            if other != i:\n                total += other\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "\"\"\"\nWrite a function to flatten the list of lists into a single set of numbers.\nassert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])\n\"\"\"\ndef flatten_to_set(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a set of numbers (unique elements).\n    \"\"\"\n    result = set()\n    if not list_of_lists:\n        return result\n    for sub in list_of_lists:\n        if sub is None:\n            continue\n        for item in sub:\n            result.add(item)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "\"\"\"\nWrite a function to count the number of occurrences of a number in a given list.\nassert frequency([1,2,3], 4) == 0\n\"\"\"\ndef count_occurrences(numbers, target):\n    \"\"\"\n    Return the number of times target appears in the list numbers.\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num == target:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "\"\"\"\nWrite a function to find the next smallest palindrome of a specified integer, returned as an integer.\nassert next_smallest_palindrome(99)==101\n\"\"\"\ndef next_smallest_palindrome(n: int) -> int:\n    if n <= 0:\n        return 0\n    if n <= 9:\n        return n - 1\n\n    s = str(n)\n    L = len(s)\n    half = (L + 1) // 2  # length of the left part including middle if odd\n    left = s[:half]\n\n    def build_pal(left_str: str, total_len: int) -> str:\n        if total_len % 2 == 0:\n            return left_str + left_str[::-1]\n        else:\n            return left_str + left_str[:-1][::-1]\n\n    pal_str = build_pal(left, L)\n    if int(pal_str) < n:\n        return int(pal_str)\n\n    left_num = int(left) - 1\n    if left_num < 10 ** (half - 1):\n        return int('9' * (L - 1))\n\n    new_left = str(left_num)\n    pal_str2 = build_pal(new_left, L)\n    return int(pal_str2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[99]], "plus_fail_tests": [[0]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "\"\"\"\nWrite a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nassert find_length(\"11000010001\") == 6\n\"\"\"\ndef max_abs_diff_zero_one_substring(s: str) -> int:\n    \"\"\"\n    Return the maximum absolute difference between the number of '0's and '1's\n    in any substring of the binary string s.\n    \"\"\"\n    if not s:\n        return 0\n\n    max_ending = 0\n    max_sum = float('-inf')\n    min_ending = 0\n    min_sum = float('inf')\n\n    for ch in s:\n        val = 1 if ch == '0' else -1  # '0' -> +1, '1' -> -1\n\n        max_ending = max(val, max_ending + val)\n        max_sum = max(max_sum, max_ending)\n\n        min_ending = min(val, min_ending + val)\n        min_sum = min(min_sum, min_ending)\n\n    return max(max_sum, -min_sum)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "\"\"\"\nWrite a function to find the perimeter of a regular pentagon from the length of its sides.\nassert perimeter_pentagon(5) == 25\n\"\"\"\ndef pentagon_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of one side.\n    For a regular pentagon, perimeter P = 5 * s.\n    \"\"\"\n    if isinstance(side_length, bool):\n        raise TypeError(\"side_length must be a numeric value, not a boolean.\")\n    if not isinstance(side_length, (int, float)):\n        raise TypeError(\"side_length must be a numeric value (int or float).\")\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative.\")\n    return 5 * side_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "\"\"\"\nWrite a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\nassert sum_series(6) == 12\n\"\"\"\ndef sum_sequence(n):\n    m = n // 2\n    return (m + 1) * (n - m)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "\"\"\"\nWrite a python function to remove the characters which have odd index values of a given string.\nassert odd_values_string('abcdef') == 'ace'\n\"\"\"\ndef remove_odd_index_chars(s):\n    \"\"\"\n    Remove characters with odd indices from the input string.\n    Returns a new string consisting of characters at even indices (0, 2, 4, ...).\n    \"\"\"\n    return s[::2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "\"\"\"\nWrite a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\nassert count_char_position(\"xbcefg\") == 2\n\"\"\"\ndef count_alphabet_position_matches(s: str) -> int:\n    s = s.lower()\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return sum(1 for i in range(min(len(s), len(alphabet))) if s[i] == alphabet[i])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "\"\"\"\nWrite a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\nassert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36\n\"\"\"\ndef max_abs_product_between_tuples(tuple_list):\n    \"\"\"\n    Given a list of 2-element tuples, returns the maximum absolute product\n    obtainable by choosing one element from two different tuples.\n    \"\"\"\n    n = len(tuple_list)\n    if n < 2:\n        raise ValueError(\"At least two tuples are required.\")\n    max1 = -1\n    max2 = -1\n    for t in tuple_list:\n        a, b = t\n        w = max(abs(a), abs(b))\n        if w > max1:\n            max2 = max1\n            max1 = w\n        elif w > max2:\n            max2 = w\n    return max1 * max2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "\"\"\"\nWrite a function that counts the number of pairs of integers in a list that xor to an even number.\nassert find_even_pair([5, 4, 7, 2, 1]) == 4\n\"\"\"\ndef count_pairs_xor_even(nums):\n    evens = 0\n    for x in nums:\n        if x % 2 == 0:\n            evens += 1\n    odds = len(nums) - evens\n    return evens * (evens - 1) // 2 + odds * (odds - 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "\"\"\"\nWrite a python function to find the smallest power of 2 greater than or equal to n.\nassert next_power_of_2(0) == 1\n\"\"\"\ndef smallest_power_of_two_ge(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return 1\n    if (n & (n - 1)) == 0:\n        return n\n    return 1 << n.bit_length()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "\"\"\"\nWrite a python function to find the maximum difference between any two elements in a given array.\nassert max_Abs_Diff((2,1,5,3)) == 4\n\"\"\"\ndef max_difference(arr):\n    if arr is None or len(arr) < 2:\n        return 0\n    return max(arr) - min(arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "\"\"\"\nWrite a function to find minimum of three numbers.\nassert min_of_three(10,20,0)==0\n\"\"\"\ndef min_of_three(a, b, c):\n    m = a\n    if b < m:\n        m = b\n    if c < m:\n        m = c\n    return m", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "\"\"\"\nWrite a function to count the number of occurence of the string 'std' in a given string.\nassert count_occurance(\"letstdlenstdporstd\") == 3\n\"\"\"\ndef count_std(s: str) -> int:\n    \"\"\"\n    Count occurrences of the substring 'std' in the given string.\n    Overlapping occurrences are counted.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    target = 'std'\n    tlen = len(target)\n    count = 0\n    for i in range(len(s) - tlen + 1):\n        if s[i:i + tlen] == target:\n            count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "\"\"\"\nWrite a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\nassert replace_blank(\"hello people\",'@')==(\"hello@people\")\n\"\"\"\ndef replace_spaces(s: str, ch: str) -> str:\n    return s.replace(' ', ch)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "\"\"\"\nWrite a function to find the volume of a cube given its side length.\nassert volume_cube(3)==27\n\"\"\"\ndef cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n    side_length must be a non-negative number.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be non-negative.\")\n    return side_length ** 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "\"\"\"\nWrite a function to find the lateral surface area of a cylinder.\nassert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)\n\"\"\"\nimport math\n\ndef lateral_surface_area(radius, height):\n    \"\"\"\n    Compute the lateral surface area of a cylinder.\n    LSA = 2 * pi * radius * height\n    \"\"\"\n    return 2 * math.pi * radius * height", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "\"\"\"\nWrite a function to check if all the elements in tuple have same data type or not.\nassert check_type((5, 6, 7, 3, 5, 6) ) == True\n\"\"\"\ndef all_same_type(t: tuple) -> bool:\n    \"\"\"\n    Check if all elements in the tuple have the same type.\n    Empty tuple is considered homogeneous.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return len({type(x) for x in t}) <= 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "\"\"\"\nWrite a python function to count the number of set bits (binary digits with value 1) in a given number.\nassert count_Set_Bits(2) == 1\n\"\"\"\ndef count_set_bits(n):\n    \"\"\"\n    Return the number of set bits (1s) in the binary representation of a non-negative integer n.\n    Uses Brian Kernighan's algorithm for efficient counting.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an int\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "\"\"\"\nWrite a function to remove all elements from a given list present in another list.\nassert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]\n\"\"\"\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef remove_all_present(source: List[T], removal: List[T]) -> List[T]:\n    \"\"\"Return a new list with elements from source not present in removal.\"\"\"\n    try:\n        removal_set = set(removal)\n        return [x for x in source if x not in removal_set]\n    except TypeError:\n        result = []\n        for x in source:\n            if not any(x == r for r in removal):\n                result.append(x)\n        return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "\"\"\"\nWrite a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nassert find_solution(2, 3, 7) == (2, 1)\n\"\"\"\ndef solve_linear_diophantine(a, b, n):\n    \"\"\"\n    Returns integers x, y such that a*x + b*y == n, or None if no solution exists.\n    \"\"\"\n    # Handle the degenerate case where both coefficients are zero\n    if a == 0 and b == 0:\n        return (0, 0) if n == 0 else None\n\n    # Iterative Extended Euclidean Algorithm\n    def extended_gcd(a, b):\n        old_r, r = a, b\n        old_s, s = 1, 0\n        old_t, t = 0, 1\n        while r != 0:\n            q = old_r // r\n            old_r, r = r, old_r - q * r\n            old_s, s = s, old_s - q * s\n            old_t, t = t, old_t - q * t\n        return old_r, old_s, old_t  # (g, x, y) such that a*x + b*y = g\n\n    g, x0, y0 = extended_gcd(a, b)\n    if g == 0:\n        return None  # Should not happen due to earlier check, but safe guard\n\n    if n % g != 0:\n        return None\n\n    k = n // g\n    return (x0 * k, y0 * k)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "\"\"\"\nWrite a python function to count the number of non-empty substrings of a given string.\nassert number_of_substrings(\"abc\") == 6\n\"\"\"\ndef count_non_empty_substrings(s: str) -> int:\n    \"\"\"\n    Return the number of non-empty substrings of s.\n    For a string of length n, the total number of substrings (including duplicates) is n*(n+1)//2.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    n = len(s)\n    return n * (n + 1) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "\"\"\"\nWrite a function that takes in a list and an integer n and returns a list containing the n largest items from the list.\nassert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])\n\"\"\"\ndef n_largest_items(lst, n):\n    \"\"\"\n    Return the n largest items from lst as a list in descending order.\n    If n <= 0, returns an empty list. If n >= len(lst), returns all items sorted descending.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(lst):\n        return sorted(lst, reverse=True)\n    import heapq\n    return heapq.nlargest(n, lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "\"\"\"\nWrite a function to count the total number of characters in a string.\nassert count_charac(\"python programming\")==18\n\"\"\"\ndef count_characters(s: str) -> int:\n    \"\"\"\n    Return the total number of characters in the string s.\n    \"\"\"\n    return len(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "\"\"\"\nWrite a function to sum all amicable numbers from 1 to a specified number.\nassert amicable_numbers_sum(999)==504\n\"\"\"\ndef sum_amicable_numbers(limit):\n    if limit < 2:\n        return 0\n\n    # Compute sum of proper divisors for all numbers up to limit using a sieve-like approach\n    s = [0] * (limit + 1)\n    for d in range(1, limit // 2 + 1):\n        for m in range(2 * d, limit + 1, d):\n            s[m] += d\n\n    def sum_proper_divisors(n):\n        if n <= 1:\n            return 0\n        total = 1\n        temp = n\n        p = 2\n        while p * p <= temp:\n            if temp % p == 0:\n                sum_p = 1 + p\n                temp //= p\n                power = p\n                while temp % p == 0:\n                    temp //= p\n                    power *= p\n                    sum_p += power\n                total *= sum_p\n            p += 1 if p == 2 else 2\n        if temp > 1:\n            total *= (1 + temp)\n        return total - n\n\n    total_sum = 0\n    for a in range(2, limit + 1):\n        b = s[a]\n        if b != a:\n            if b <= limit:\n                b_sum = s[b]\n            else:\n                b_sum = sum_proper_divisors(b)\n            if b_sum == a:\n                total_sum += a\n\n    return total_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "\"\"\"\nWrite a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\nassert odd_Equivalent(\"011001\",6) == 3\n\"\"\"\ndef count_odd_rotations(bin_str: str, times: int) -> int:\n    \"\"\"\n    Return the number of odd-valued rotations when a binary string bin_str\n    is left-rotated exactly 'times' times.\n    A rotation yields an odd value if its least significant bit is '1'.\n    \"\"\"\n    if times <= 0 or not bin_str:\n        return 0\n\n    n = len(bin_str)\n\n    # Prefix sums of ones for quick range queries\n    pref = [0] * (n + 1)\n    for i, ch in enumerate(bin_str):\n        pref[i + 1] = pref[i] + (1 if ch == '1' else 0)\n\n    ones = pref[n]\n    cycles = times // n\n    rem = times % n\n\n    extra = 0\n    if rem:\n        # For the first 'rem' rotations, the last bits come from positions:\n        # n-1, 0, 1, ..., rem-2\n        extra = (1 if bin_str[-1] == '1' else 0) + pref[rem - 1]\n\n    return cycles * ones + extra", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "\"\"\"\nWrite a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\nassert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]\n\"\"\"\ndef replace_last_with_list(lst1, lst2):\n    if lst1:\n        lst1[-1:] = lst2\n    else:\n        lst1.extend(lst2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "\"\"\"\nWrite a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\nassert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}\n\"\"\"\ndef count_tuples(lst):\n    \"\"\"\n    Return a dictionary mapping each unique tuple in lst to its frequency.\n    \"\"\"\n    counts = {}\n    for t in lst:\n        counts[t] = counts.get(t, 0) + 1\n    return counts", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "\"\"\"\nWrite a python function that takes in a tuple and an element and counts the occcurences of the element in the tuple.\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0\n\"\"\"\ndef count_occurrences(t, element):\n    \"\"\"\n    Return the number of times 'element' occurs in the tuple 't'.\n    \"\"\"\n    return t.count(element)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "\"\"\"\nWrite a function to find the sum of numbers in a list within a range specified by two indices.\nassert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29\n\"\"\"\ndef sum_in_range(nums, start, end, inclusive=True):\n    \"\"\"\n    Return the sum of elements in nums from the boundary indices start to end.\n    If inclusive is True, include end; else exclude end.\n    Indices can be in any order; the range is interpreted between the two indices.\n    \"\"\"\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"nums must be a list or tuple\")\n    if not isinstance(start, int) or not isinstance(end, int):\n        raise TypeError(\"start and end must be integers\")\n    a, b = sorted((start, end))\n    if inclusive:\n        return sum(nums[a:b+1])\n    else:\n        return sum(nums[a:b])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "\"\"\"\nWrite a function to maximize the given two tuples.\nassert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))\n\"\"\"\ndef maximize_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Return a tuple containing the element-wise maximum of t1 and t2.\n    Both inputs must be tuples of the same length.\n    \"\"\"\n    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must be of the same length.\")\n    return tuple(max(a, b) for a, b in zip(t1, t2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "\"\"\"\nWrite a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\nassert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black']\n\"\"\"\ndef insert_before_each(lst, element):\n    \"\"\"\n    Return a new list with 'element' inserted before each element in 'lst'.\n    \"\"\"\n    result = []\n    for x in lst:\n        result.append(element)\n        result.append(x)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "\"\"\"\nWrite a function that takes in two numbers and returns a tuple with the second number and then the first number.\nassert swap_numbers(10,20)==(20,10)\n\"\"\"\ndef swap_second_first(a, b):\n    \"\"\"\n    Return a tuple with the second argument first, then the first argument.\n    \"\"\"\n    return (b, a)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "\"\"\"\nWrite a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nassert get_total_number_of_sequences(10, 4) == 4\n\"\"\"\ndef count_sequences(m: int, n: int) -> int:\n    if m <= 0 or n <= 0:\n        return 0\n    # Initialize for sequences of length 1: any a1 in [1, m]\n    dp_prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    for _ in range(2, n + 1):\n        diff = [0] * (m + 2)  # difference array for range updates on [2*p, m]\n        for p in range(1, m + 1):\n            v = dp_prev[p]\n            if v:\n                left = 2 * p\n                if left <= m:\n                    diff[left] += v\n                    diff[m + 1] -= v\n        dp_curr = [0] * (m + 1)\n        acc = 0\n        for x in range(1, m + 1):\n            acc += diff[x]\n            dp_curr[x] = acc\n        dp_prev = dp_curr\n\n    return sum(dp_prev[1:])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "\"\"\"\nWrite a python function that returns the number of integer elements in a given list.\nassert count_integer([1,2,'abc',1.2]) == 2\n\"\"\"\ndef count_integers(lst):\n    \"\"\"\n    Return the number of elements in lst that are exactly of type int.\n    Booleans are not counted since they are of type bool.\n    \"\"\"\n    return sum(1 for x in lst if type(x) is int)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "\"\"\"\nWrite a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\nassert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)\n\"\"\"\ndef div_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Perform element-wise division of two tuples.\n    Returns a new tuple where each element i is t1[i] / t2[i].\n    Raises ValueError if tuples have different lengths.\n    Propagates ZeroDivisionError if any t2[i] == 0.\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"tuples must be of the same length\")\n    return tuple(a / b for a, b in zip(t1, t2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "\"\"\"\nWrite a python function to convert complex numbers to polar coordinates.\nassert convert(1) == (1.0, 0.0)\n\"\"\"\nimport math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates (r, theta) in radians.\n    Returns a tuple (r, theta) where r >= 0 and theta is in (-pi, pi].\n    \"\"\"\n    z = complex(z)\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "\"\"\"\nWrite a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\nassert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n\"\"\"\ndef is_majority(arr, n, x):\n    \"\"\"\n    Returns True if x is the majority element in the sorted array arr of length n.\n    A majority element occurs more than n/2 times.\n    \"\"\"\n    # Find first occurrence of x via binary search\n    lo, hi = 0, n - 1\n    first = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n            if arr[mid] == x:\n                first = mid\n    if first == -1:\n        return False\n\n    # Find last occurrence of x via binary search\n    lo, hi = 0, n - 1\n    last = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] > x:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n            if arr[mid] == x:\n                last = mid\n\n    count = last - first + 1\n    return count > n // 2", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "\"\"\"\nWrite a function to sort a list of elements.\nassert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]\n\"\"\"\ndef sort_list(elements):\n    \"\"\"Return a new list containing the elements sorted in ascending order\n    using a stable merge sort. The input is not modified.\n    \"\"\"\n    def merge(left, right):\n        i = j = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        return merged\n\n    items = list(elements)\n    n = len(items)\n    if n <= 1:\n        return items.copy()\n    mid = n // 2\n    left_sorted = sort_list(items[:mid])\n    right_sorted = sort_list(items[mid:])\n    return merge(left_sorted, right_sorted)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "\"\"\"\nWrite a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\nassert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]\n\"\"\"\ndef split_list_every_n(lst, n):\n    \"\"\"\n    Split lst into chunks of size n. Returns a list of sublists.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    chunks = []\n    for i in range(0, len(lst), n):\n        chunks.append(lst[i:i+n])\n    return chunks", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "\"\"\"\nWrite a function to find the length of the longest palindromic subsequence in the given string.\nassert lps(\"TENS FOR TENS\") == 5\n\"\"\"\ndef longest_palindromic_subsequence_length(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2 if j > i + 1 else 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "\"\"\"\nWrite a function to find the lateral surface area of a cube given its side length.\nassert lateralsurface_cube(5)==100\n\"\"\"\ndef lateral_surface_area_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n    Lateral surface area = 4 * side_length^2\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative\")\n    return 4 * (side_length ** 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "\"\"\"\nWrite a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\nassert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])\n\"\"\"\ndef split_list_at(lst, L):\n    \"\"\"\n    Split the list into two parts such that the first part has length L.\n    Returns a tuple: (first_part, second_part)\n    \"\"\"\n    return lst[:L], lst[L:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "\"\"\"\nWrite a function to calculate a dog's age in dog's years.\nassert dog_age(12)==61\n\"\"\"\ndef dog_years(human_years: float) -> float:\n    \"\"\"\n    Convert human years to dog years using the common approximation:\n    - The first 2 human years equal 21 dog years (10.5 per year)\n    - Each additional human year equals 4 dog years\n    Returns a float to handle partial years.\n    \"\"\"\n    if human_years < 0:\n        raise ValueError(\"human_years must be non-negative\")\n    if human_years <= 2:\n        return human_years * 10.5\n    return 21.0 + (human_years - 2.0) * 4.0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "\"\"\"\nWrite a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\nassert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194\n\"\"\"\ndef max_sum_bitonic_subsequence(arr):\n    \"\"\"\n    Compute the maximum sum of a bitonic subsequence (increasing then decreasing).\n    A bitonic subsequence can be as simple as a single element.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Maximum sum of increasing subsequence ending at i\n    inc = [0] * n\n    for i in range(n):\n        best = 0\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] > best:\n                best = inc[j]\n        inc[i] = arr[i] + best\n\n    # Maximum sum of decreasing subsequence starting at i\n    dec = [0] * n\n    for i in range(n - 1, -1, -1):\n        best = 0\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and dec[j] > best:\n                best = dec[j]\n        dec[i] = arr[i] + best\n\n    # Bitonic with peak at i: inc[i] + dec[i] - arr[i] (arr[i] counted twice)\n    return max(inc[i] + dec[i] - arr[i] for i in range(n))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "\"\"\"\nWrite a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\nassert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\n\"\"\"\ndef subtract_tuples(t1, t2):\n    \"\"\"\n    Subtract elements of t2 from t1 element-wise and return a new tuple.\n    Both inputs must be tuples of equal length.\n    \"\"\"\n    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must be of the same length.\")\n    return tuple(a - b for a, b in zip(t1, t2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "\"\"\"\nWrite a python function to find the next perfect square greater than a given number.\nassert next_Perfect_Square(35) == 36\n\"\"\"\nimport math\n\ndef next_perfect_square(n):\n    \"\"\"\n    Return the smallest perfect square strictly greater than n.\n    If n is negative, returns 0.\n    \"\"\"\n    if n < 0:\n        return 0\n    return math.ceil(math.sqrt(n + 1)) ** 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "\"\"\"\nWrite a function to find the n'th star number.\nassert find_star_num(3) == 37\n\"\"\"\ndef nth_star_number(n: int) -> int:\n    \"\"\"\n    Compute the nth star number.\n    Star numbers are given by S(n) = 6*n*(n-1) + 1, with n >= 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return 6 * n * (n - 1) + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "\"\"\"\nWrite a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\nassert square_Sum(2) == 10\n\"\"\"\ndef sum_odd_squares(n: int) -> int:\n    \"\"\"\n    Returns the sum of squares of the first n odd natural numbers.\n    Formula: sum_{k=1..n} (2k-1)^2 = n*(2n-1)*(2n+1)/3\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return n * (2 * n - 1) * (2 * n + 1) // 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "\"\"\"\nWrite a function to find the ascii value of a character.\nassert ascii_value('A')==65\n\"\"\"\ndef ascii_value(ch: str) -> int:\n    \"\"\"\n    Return the ASCII value of a single character.\n\n    Raises:\n        TypeError: if input is not a string.\n        ValueError: if input is not a single character or if the character is non-ASCII.\n    \"\"\"\n    if not isinstance(ch, str):\n        raise TypeError(\"Input must be a string representing a single character.\")\n    if len(ch) != 1:\n        raise ValueError(\"Input must be a single character.\")\n    val = ord(ch)\n    if val > 127:\n        raise ValueError(\"Character is not ASCII.\")\n    return val", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\u00ae"]]}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "\"\"\"\nWrite a function that takes in the radius and height of a cylinder and returns the the volume.\nassert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)\n\"\"\"\nimport math\n\ndef cylinder_volume(radius: float, height: float) -> float:\n    \"\"\"Calculate the volume of a cylinder: V = \u03c0 * r^2 * h.\"\"\"\n    return math.pi * (radius ** 2) * height", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "\"\"\"\nWrite a function to find the number of elements that occurs before the tuple element in the given tuple.\nassert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3\n\"\"\"\ndef count_before_element_in_tuple(tup, element):\n    \"\"\"\n    Return the number of elements that occur before the first occurrence\n    of element in the tuple 'tup'.\n    If the element is not present, return -1.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    try:\n        return tup.index(element)\n    except ValueError:\n        return -1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "\"\"\"\nWrite a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\nassert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\n\"\"\"\ndef rear_elements(pairs):\n    return [t[-1] for t in pairs]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "\"\"\"\nWrite a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}\n\"\"\"\ndef filter_dict_by_min_value(d, n):\n    \"\"\"\n    Return a new dictionary containing items from d whose values are >= n.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise TypeError(\"d must be a dictionary.\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer.\")\n    return {k: v for k, v in d.items() if v >= n}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "\"\"\"\nWrite a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\nassert count_Primes_nums(5) == 2\n\"\"\"\ndef count_primes_less_than(n):\n    \"\"\"\n    Return the number of prime numbers less than n.\n    n is treated as a non-negative integer (floored if given as float).\n    \"\"\"\n    n = int(n)\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    p = 2\n    while p * p < n:\n        if is_prime[p]:\n            for i in range(p * p, n, p):\n                is_prime[i] = False\n        p += 1\n    return sum(is_prime)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "\"\"\"\nWrite a python function to find the sum of even numbers at even positions of a list.\nassert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30\n\"\"\"\ndef sum_even_at_even_positions(nums):\n    \"\"\"\n    Returns the sum of elements that are even numbers located at even indices (0-based) in the input list.\n    Non-integer values are ignored.\n    \"\"\"\n    total = 0\n    for idx in range(0, len(nums), 2):\n        val = nums[idx]\n        if isinstance(val, int) and val % 2 == 0:\n            total += val\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "\"\"\"\nWrite a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\nassert even_binomial_Coeff_Sum(4) == 8\n\"\"\"\ndef sum_even_index_binomial(n):\n    \"\"\"\n    Return the sum of binomial coefficients C(n, k) for even k (0 <= k <= n).\n    For n >= 1 this equals 2^(n-1).\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 1 << (n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "\"\"\"\nWrite a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\nassert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)\n\"\"\"\ndef find_in_array(arr, element):\n    \"\"\"\n    Returns a tuple (found, index) where found is True if 'element' exists in 'arr',\n    and index is the position of its first occurrence or -1 if not found.\n    \"\"\"\n    for i, val in enumerate(arr):\n        if val == element:\n            return (True, i)\n    return (False, -1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "\"\"\"\nWrite a function that takes in a list and element and checks whether all items in the list are equal to the given element.\nassert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False\n\"\"\"\ndef all_equal_to(lst, element):\n    return all(x == element for x in lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "\"\"\"\nWrite a function to subtract two lists element-wise.\nassert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]\n\"\"\"\nfrom typing import List, Union\n\ndef subtract_lists(a: List[Union[int, float]], b: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    Subtract two lists element-wise.\n    Both lists must have the same length and contain numeric values.\n    Returns a new list with a[i] - b[i].\n    \"\"\"\n    if not isinstance(a, list) or not isinstance(b, list):\n        raise TypeError(\"Both inputs must be lists.\")\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length.\")\n    return [x - y for x, y in zip(a, b)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "\"\"\"\nWrite a python function to check if the elements of a given list are unique or not.\nassert all_unique([1,2,3]) == True\n\"\"\"\ndef are_elements_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    Returns True if all elements are distinct, False otherwise.\n    Handles hashable elements efficiently; for unhashable elements it falls back to a quadratic comparison.\n    \"\"\"\n    if not isinstance(lst, list):\n        lst = list(lst)\n\n    try:\n        return len(lst) == len(set(lst))\n    except TypeError:\n        n = len(lst)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] == lst[j]:\n                    return False\n        return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "\"\"\"\nWrite a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\nassert square_Sum(2) == 20\n\"\"\"\ndef sum_squares_first_n_even(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return 2 * n * (n + 1) * (2 * n + 1) // 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "\"\"\"\nWrite a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\nassert text_match_two_three(\"ac\")==(False)\n\"\"\"\ndef contains_a_followed_by_two_or_three_bs(s: str) -> bool:\n    for i in range(len(s) - 2):\n        if s[i] == 'a' and s[i + 1] == 'b' and s[i + 2] == 'b':\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "\"\"\"\nWrite a function to find the list of maximum length in a list of lists.\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])\n\"\"\"\ndef max_length_sublists(lists):\n    if not lists:\n        return []\n    max_len = max(len(sub) for sub in lists)\n    return [sub for sub in lists if len(sub) == max_len]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "\"\"\"\nWrite a function to find the nth decagonal number.\nassert is_num_decagonal(3) == 27\n\"\"\"\ndef nth_decagonal(n: int) -> int:\n    \"\"\"Return the nth decagonal number, defined as P10(n) = n(4n - 3).\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (4 * n - 3)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "\"\"\"\nWrite a python function to set all even bits of a given number.\nassert even_bit_set_number(10) == 10\n\"\"\"\ndef set_even_bits(n):\n    \"\"\"\n    Set all even-indexed bits (0-based, counting from LSB) of n to 1.\n    Handles non-negative integers. For n == 0, bit 0 will be set.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    limit = max(n, 1)\n    mask = 0\n    i = 0\n    while (1 << i) <= limit:\n        mask |= (1 << i)\n        i += 2\n    return n | mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "\"\"\"\nWrite a function to flatten a given nested list structure.\nassert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]\n\"\"\"\ndef flatten(nested):\n    if not isinstance(nested, (list, tuple)):\n        return [nested]\n    result = []\n    for item in nested:\n        if isinstance(item, (list, tuple)):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "\"\"\"\nWrite a function to convert a given string to a tuple of characters.\nassert string_to_tuple(\"python 3.0\")==('p', 'y', 't', 'h', 'o', 'n', '3', '.', '0')\n\"\"\"\ndef string_to_char_tuple(s: str) -> tuple:\n    \"\"\"Convert a string into a tuple of its characters.\"\"\"\n    return tuple(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "\"\"\"\nWrite a function to calculate the maximum aggregate from the list of tuples.\nassert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)\n\"\"\"\ndef max_aggregate(list_of_tuples):\n    \"\"\"\n    Compute the maximum aggregate (sum) among a list of tuples.\n    Returns None if the input list is empty.\n    \"\"\"\n    return max((sum(t) for t in list_of_tuples), default=None)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["Juan Whelan", 90], ["Sabah Colley", 88], ["Peter Nichols", 7], ["Juan Whelan", 122], ["Sabah Colley", 84]]]], "plus_fail_tests": [[[["Alice", 80], ["Bob", 90], ["Charlie", 70], ["Alice", 60], ["Bob", 50], ["Charlie", 40]]]]}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "\"\"\"\nWrite a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\nassert validate(1234) == True\n\"\"\"\ndef is_digit_frequency_valid(n: int) -> bool:\n    \"\"\"\n    Return True if for every digit present in the absolute value of n,\n    the frequency of that digit is less than or equal to the digit itself.\n    \"\"\"\n    s = str(abs(n))\n    from collections import Counter\n    counts = Counter(s)\n    for ch, cnt in counts.items():\n        d = ord(ch) - ord('0')\n        if cnt > d:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "\"\"\"\nWrite a python function to find the maximum of two numbers.\nassert maximum(5,10) == 10\n\"\"\"\ndef max_of_two(a, b):\n    \"\"\"\n    Return the maximum of two numbers.\n    If they are equal, returns a (or b).\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "\"\"\"\nWrite a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\nassert even_Power_Sum(2) == 1056\n\"\"\"\ndef sum_first_n_even_numbers_fifth(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    a = n * n\n    b = (n + 1) * (n + 1)\n    c = 2 * n * n + 2 * n - 1\n    return (8 * a * b * c) // 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "\"\"\"\nWrite a function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\nassert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)\n\"\"\"\ndef comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - k + i) // i\n    return result\n\ndef count_sequences(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return comb(2 * n, n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "\"\"\"\nWrite a python function to find quotient of two numbers (rounded down to the nearest integer).\nassert find(10,3) == 3\n\"\"\"\ndef floor_quotient(a, b):\n    \"\"\"\n    Return floor(a / b) as an integer. Raises ZeroDivisionError if b == 0.\n    Works for integers and floating-point numbers.\n    \"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if isinstance(a, int) and isinstance(b, int):\n        return a // b\n    import math\n    return int(math.floor(a / b))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "\"\"\"\nWrite a function to return two words from a list of words starting with letter 'p'.\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')\n\"\"\"\ndef two_p_words(words, case_insensitive=True):\n    \"\"\"\n    Return the first two words from 'words' that start with 'p'.\n    If fewer than two such words exist, raise ValueError.\n    \"\"\"\n    if case_insensitive:\n        predicate = lambda w: isinstance(w, str) and w.lower().startswith('p')\n    else:\n        predicate = lambda w: isinstance(w, str) and w.startswith('p')\n    found = []\n    for w in words:\n        if predicate(w):\n            found.append(w)\n            if len(found) == 2:\n                return (found[0], found[1])\n    raise ValueError(\"Less than two words start with 'p'.\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "\"\"\"\nWrite a function to find the volume of a cone.\nassert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)\n\"\"\"\nimport math\n\ndef volume_of_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n    Volume = (1/3) * pi * r^2 * h\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative.\")\n    return (math.pi * radius * radius * height) / 3.0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "\"\"\"\nWrite a python function to count inversions in an array.\nassert get_Inv_Count([1,20,6,4,5]) == 5\n\"\"\"\ndef count_inversions(arr):\n    \"\"\"\n    Count inversions in the array.\n    An inversion is a pair (i, j) with i < j and arr[i] > arr[j].\n    Returns the number of inversions as an integer.\n    \"\"\"\n    a = list(arr)\n\n    def merge_sort_with_count(sub):\n        n = len(sub)\n        if n <= 1:\n            return sub, 0\n        mid = n // 2\n        left, inv_left = merge_sort_with_count(sub[:mid])\n        right, inv_right = merge_sort_with_count(sub[mid:])\n        merged = []\n        i = j = 0\n        inv_split = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_split += len(left) - i\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        total = inv_left + inv_right + inv_split\n        return merged, total\n\n    _, count = merge_sort_with_count(a)\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "\"\"\"\nWrite a function to find the nth newman\u2013shanks\u2013williams prime number.\nassert newman_prime(3) == 7\n\"\"\"\ndef newman_shanks_williams_prime(n):\n    \"\"\"\n    Return the nth Newman\u2013Shanks\u2013Williams prime.\n    NSW sequence: s0 = 1, s1 = 1, s_k = 2*s_{k-1} + s_{k-2} for k >= 2.\n    NSW primes are terms s_k that are prime. The function is 1-indexed on NSW primes.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        small_primes = (2,3,5,7,11,13,17,19,23,29,31)\n        for p in small_primes:\n            if num % p == 0:\n                return num == p\n        # write num-1 = d * 2^s\n        d = num - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        # Use a set of bases suitable for large numbers (probabilistic)\n        for a in (2, 3, 5, 7, 11, 13, 17):\n            if a >= num:\n                continue\n            x = pow(a, d, num)\n            if x == 1 or x == num - 1:\n                continue\n            composite = True\n            for _ in range(s - 1):\n                x = (x * x) % num\n                if x == num - 1:\n                    composite = False\n                    break\n            if composite:\n                return False\n        return True\n\n    count = 0\n    a0, a1 = 1, 1  # s0, s1\n    while True:\n        s = 2*a1 + a0\n        if is_prime(s):\n            count += 1\n            if count == n:\n                return s\n        a0, a1 = a1, s", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "\"\"\"\nWrite a function to apply a given format string to all of the elements in a list.\nassert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']\n\"\"\"\ndef apply_format_to_list(items, format_string):\n    \"\"\"\n    Apply a given format string to each element in the input list.\n    Each element is formatted using the standard str.format mechanism with the\n    element as the sole positional argument.\n    Returns a new list of formatted strings.\n    If formatting fails for an element, its string representation is used instead.\n    \"\"\"\n    result = []\n    for x in items:\n        try:\n            result.append(format_string.format(x))\n        except Exception:\n            result.append(str(x))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "\"\"\"\nWrite a python function to find the first non-repeated character in a given string.\nassert first_non_repeating_character(\"abcabc\") == None\n\"\"\"\ndef first_non_repeated_char(s):\n    \"\"\"\n    Return the first non-repeated character in string s.\n    If there is no such character, return None.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    from collections import Counter\n    counts = Counter(s)\n    for ch in s:\n        if counts[ch] == 1:\n            return ch\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "\"\"\"\nWrite a python function to find the highest power of 2 that is less than or equal to n.\nassert highest_Power_of_2(10) == 8\n\"\"\"\ndef highest_power_of_2_leq(n):\n    \"\"\"\n    Return the largest power of 2 that is less than or equal to n.\n    If n < 1, returns 0.\n    Accepts integers or values convertible to int.\n    \"\"\"\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"n must be an integer or numeric value convertible to int\")\n\n    if n < 1:\n        return 0\n    return 1 << (n.bit_length() - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "\"\"\"\nWrite a function to find the median of three numbers.\nassert median_numbers(25,55,65)==55.0\n\"\"\"\ndef median_of_three(a, b, c):\n    \"\"\"\n    Return the median value among a, b, and c.\n    Works for integers and floats.\n    \"\"\"\n    return a + b + c - max(a, b, c) - min(a, b, c)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "\"\"\"\nWrite a function to check if given tuple contains no duplicates.\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False\n\"\"\"\ndef has_no_duplicates(t: tuple) -> bool:\n    \"\"\"\n    Return True if the input tuple 't' contains no duplicate elements.\n    Handles both hashable and unhashable elements.\n    \"\"\"\n    seen_hashable = set()\n    seen_unhashable = []\n    for x in t:\n        try:\n            if x in seen_hashable:\n                return False\n            seen_hashable.add(x)\n        except TypeError:\n            for y in seen_unhashable:\n                if x == y:\n                    return False\n            seen_unhashable.append(x)\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "\"\"\"\nWrite a function to compute the sum of digits of each number of a given list.\nassert sum_of_digits([10,2,56])==14\n\"\"\"\ndef sum_of_digits_per_number(nums):\n    \"\"\"\n    Given an iterable of integers, return a list where each element is the sum of digits\n    of the corresponding number. Negative numbers are treated by using the digits of their\n    absolute value.\n    \"\"\"\n    return [sum(int(ch) for ch in str(abs(int(n)))) for n in nums]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "\"\"\"\nWrite a function to check whether an element exists within a tuple.\nassert check_tuplex((\"w\", 3, \"r\", \"e\", \"s\", \"o\", \"u\", \"r\", \"c\", \"e\"),'r')==True\n\"\"\"\ndef element_in_tuple(t, x):\n    \"\"\"\n    Check whether element x exists in tuple t.\n    Returns True if x is in t, else False.\n    \"\"\"\n    return x in t", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "\"\"\"\nWrite a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\nassert get_max_sum(60) == 106\n\"\"\"\ndef max_sum(n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x <= 0:\n            return 0\n        s = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        return max(s, x)\n\n    return f(n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "\"\"\"\nWrite a function to find the third side of a right angled triangle.\nassert otherside_rightangle(7,8)==10.63014581273465\n\"\"\"\nimport math\n\ndef third_side(a=None, b=None, c=None):\n    \"\"\"\n    Compute the missing side of a right triangle given the other two sides.\n    Exactly one of a, b, c must be None (the side to compute).\n    - If c is missing: c = sqrt(a^2 + b^2)\n    - If a is missing: a = sqrt(c^2 - b^2)\n    - If b is missing: b = sqrt(c^2 - a^2)\n    All provided sides must be non-negative numbers.\n    \"\"\"\n    missing = [name for name, val in (('a', a), ('b', b), ('c', c)) if val is None]\n    if len(missing) != 1:\n        raise ValueError(\"Exactly one of a, b, or c must be provided as None to compute the third side.\")\n    # Validate provided values\n    for name, val in (('a', a), ('b', b), ('c', c)):\n        if val is not None:\n            if not isinstance(val, (int, float)):\n                raise TypeError(f\"{name} must be numeric.\")\n            if val < 0:\n                raise ValueError(f\"{name} must be non-negative.\")\n    epsilon = 1e-12\n    if c is None:\n        return math.hypot(a, b)\n    elif a is None:\n        val = c*c - b*b\n        if val < 0:\n            if abs(val) < epsilon:\n                val = 0.0\n            else:\n                raise ValueError(\"Invalid side lengths: c^2 must be >= b^2.\")\n        return math.sqrt(val)\n    else:  # b is None\n        val = c*c - a*a\n        if val < 0:\n            if abs(val) < epsilon:\n                val = 0.0\n            else:\n                raise ValueError(\"Invalid side lengths: c^2 must be >= a^2.\")\n        return math.sqrt(val)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "\"\"\"\nWrite a python function to set the left most unset bit.\nassert set_left_most_unset_bit(10) == 14\n\"\"\"\ndef set_leftmost_unset_bit(n: int, width: int = 32) -> int:\n    \"\"\"\n    Set the leftmost (most significant) unset bit within a fixed bit width.\n\n    Parameters:\n        n: non-negative integer\n        width: number of bits to consider (default 32)\n\n    Returns:\n        Integer with the leftmost unset bit set to 1 within the given width.\n        If all bits in the width are 1, the next higher bit is set (width-th bit).\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if width <= 0:\n        raise ValueError(\"width must be a positive integer\")\n\n    for i in range(width - 1, -1, -1):\n        if ((n >> i) & 1) == 0:\n            return n | (1 << i)\n    return n | (1 << width)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "\"\"\"\nWrite a python function to find the minimum of two numbers.\nassert minimum(1,2) == 1\n\"\"\"\ndef min_of_two(a, b):\n    \"\"\"Return the smaller of two numbers a and b.\"\"\"\n    return a if a <= b else b", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "\"\"\"\nWrite a function to find the depth of a dictionary.\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4\n\"\"\"\ndef dict_depth(d):\n    \"\"\"\n    Compute the maximum depth of a dictionary, counting nested dictionaries\n    that appear in values as well as dictionaries inside lists/tuples/sets.\n    An empty dictionary has depth 1. If the input is not a dict, returns 0.\n    \"\"\"\n    def _depth(o, seen):\n        if id(o) in seen:\n            return 0\n        if isinstance(o, dict):\n            seen.add(id(o))\n            if not o:\n                seen.remove(id(o))\n                return 1\n            max_child = 0\n            for v in o.values():\n                depth_v = _depth(v, seen)\n                if depth_v > max_child:\n                    max_child = depth_v\n            seen.remove(id(o))\n            return max_child + 1\n        elif isinstance(o, (list, tuple, set)):\n            max_child = 0\n            for item in o:\n                depth_item = _depth(item, seen)\n                if depth_item > max_child:\n                    max_child = depth_item\n            return max_child\n        else:\n            return 0\n    if not isinstance(d, dict):\n        return 0\n    return _depth(d, set())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[{"1": null, "2": {"3": [1, 2, 3, "four", {"five": []}]}}]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "\"\"\"\nWrite a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nassert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]\n\"\"\"\ndef k_largest_pair_products(list1, list2, k):\n    \"\"\"\n    Return the k largest products obtainable by multiplying one element\n    from list1 with one element from list2.\n\n    Parameters:\n    - list1: iterable of numbers\n    - list2: iterable of numbers\n    - k: int, number of largest products to return\n\n    Returns:\n    - List of the k largest products in descending order.\n      If k > total number of products, all products are returned sorted descending.\n    \"\"\"\n    a = list(list1)\n    b = list(list2)\n    n, m = len(a), len(b)\n\n    if n == 0 or m == 0 or k <= 0:\n        return []\n\n    total = n * m\n    if k >= total:\n        products = [x * y for x in a for y in b]\n        return sorted(products, reverse=True)\n\n    import heapq\n    minheap = []\n    for x in a:\n        for y in b:\n            p = x * y\n            if len(minheap) < k:\n                heapq.heappush(minheap, p)\n            else:\n                if p > minheap[0]:\n                    heapq.heapreplace(minheap, p)\n\n    return sorted(minheap, reverse=True)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "\"\"\"\nWrite a python function to find whether the parity of a given number is odd.\nassert find_Parity(12) == False\n\"\"\"\ndef is_odd_parity(n: int) -> bool:\n    \"\"\"\n    Determine if the parity of n is odd.\n    Returns True if n is odd, otherwise False.\n    \"\"\"\n    return (n & 1) != 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "\"\"\"\nWrite a function to find the maximum value in a given heterogeneous list.\nassert max_val(['Python', 3, 2, 4, 5, 'version'])==5\n\"\"\"\ndef max_in_heterogeneous_list(lst):\n    if lst is None or len(lst) == 0:\n        raise ValueError(\"max_in_heterogeneous_list() arg is an empty sequence\")\n\n    def _type_order(x):\n        t = type(x)\n        order = {\n            bool: 0,\n            int: 1,\n            float: 2,\n            complex: 3,\n            str: 4,\n            tuple: 5,\n            list: 6,\n            set: 7,\n            dict: 8,\n        }\n        return order.get(t, 9)\n\n    def _compare(a, b):\n        try:\n            if a > b:\n                return 1\n            if a < b:\n                return -1\n            return 0\n        except Exception:\n            pass\n\n        ta, tb = type(a), type(b)\n        if ta == tb:\n            sa, sb = str(a), str(b)\n            if sa > sb:\n                return 1\n            if sa < sb:\n                return -1\n            return 0\n\n        oa, ob = _type_order(a), _type_order(b)\n        if oa != ob:\n            return 1 if oa > ob else -1\n\n        ia, ib = id(a), id(b)\n        if ia > ib:\n            return 1\n        if ia < ib:\n            return -1\n        return 0\n\n    max_val = lst[0]\n    for item in lst[1:]:\n        if _compare(item, max_val) > 0:\n            max_val = item\n    return max_val", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "\"\"\"\nWrite a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\nassert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243\n\"\"\"\ndef round_and_sum_times_length(nums):\n    total = sum(round(x) for x in nums)\n    result = total * len(nums)\n    print(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "\"\"\"\nWrite a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nassert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11\n\"\"\"\ndef max_sum_increasing_subseq_with_k(arr, i, k):\n    \"\"\"\n    Compute the maximum sum of an increasing subsequence that consists of:\n    a subsequence from indices [0..i] (possibly empty) followed by arr[k],\n    with the requirement that the subsequence is strictly increasing and k > i.\n    Returns the maximum possible sum.\n    \"\"\"\n    n = len(arr)\n    if not (0 <= i < k < n):\n        raise ValueError(\"Require 0 <= i < k < len(arr)\")\n    \n    # msis_end[j] = maximum sum of an increasing subsequence that ends at index j\n    msis_end = [0] * k\n    for j in range(k):\n        best = 0\n        for t in range(j):\n            if arr[t] < arr[j] and msis_end[t] > best:\n                best = msis_end[t]\n        msis_end[j] = arr[j] + best\n\n    # Find best sum from prefix [0..i] that can be extended by arr[k]\n    max_prefix_sum = 0\n    for j in range(min(i + 1, k)):\n        if arr[j] < arr[k] and msis_end[j] > max_prefix_sum:\n            max_prefix_sum = msis_end[j]\n\n    return max(arr[k], max_prefix_sum + arr[k])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "\"\"\"\nWrite a function to find the n'th lucas number.\nassert find_lucas(9) == 76\n\"\"\"\ndef lucas(n):\n    \"\"\"Return the nth Lucas number (L0 = 2, L1 = 1, L_n = L_{n-1} + L_{n-2}).\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    def fib_pair(k):\n        if k == 0:\n            return (0, 1)\n        a, b = fib_pair(k >> 1)\n        c = a * ((b << 1) - a)  # F(2m)\n        d = a * a + b * b         # F(2m + 1)\n        if (k & 1) == 0:\n            return (c, d)\n        else:\n            return (d, c + d)\n\n    F_n, F_n_plus_1 = fib_pair(n)\n    return 2 * F_n_plus_1 - F_n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "\"\"\"\nWrite a python function to check whether any value in a sequence exists in a sequence or not.\nassert overlapping([1,2,3,4,5],[6,7,8,9]) == False\n\"\"\"\ndef any_value_in_sequences(seq_a, seq_b):\n    \"\"\"\n    Return True if there exists any value that appears in both seq_a and seq_b.\n    Works with hashable and non-hashable elements (falls back to O(n*m) if needed).\n    \"\"\"\n    a = list(seq_a)\n    b = list(seq_b)\n    if not a or not b:\n        return False\n    try:\n        if len(a) <= len(b):\n            set_b = set(b)\n            for x in a:\n                if x in set_b:\n                    return True\n            return False\n        else:\n            set_a = set(a)\n            for x in b:\n                if x in set_a:\n                    return True\n            return False\n    except TypeError:\n        # Fallback for unhashable elements\n        for x in a:\n            for y in b:\n                if x == y:\n                    return True\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "\"\"\"\nWrite a python function to find the cube sum of first n even natural numbers.\nassert cube_Sum(2) == 72\n\"\"\"\ndef cube_sum_of_first_n_even_numbers(n):\n    \"\"\"\n    Return the sum of cubes of the first n even natural numbers (2, 4, ..., 2n).\n    Uses the closed-form: sum_{k=1..n} (2k)^3 = 2 * n^2 * (n+1)^2\n    \"\"\"\n    if isinstance(n, bool) or not isinstance(n, int):\n        raise TypeError(\"n must be a non-negative integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return 2 * (n ** 2) * ((n + 1) ** 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "\"\"\"\nWrite a python function to find the element of a list having maximum length.\nassert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']\n\"\"\"\ndef max_length_element(iterable):\n    \"\"\"\n    Return the first element in 'iterable' with the maximum length among elements\n    that support len(). If no such element exists, raise ValueError.\n    \"\"\"\n    best = None\n    best_len = -1\n    found = False\n    for item in iterable:\n        try:\n            cur_len = len(item)\n        except TypeError:\n            continue\n        if not found or cur_len > best_len:\n            best_len = cur_len\n            best = item\n            found = True\n    if not found:\n        raise ValueError(\"No element with a measurable length found.\")\n    return best", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "\"\"\"\nWrite a function to concatenate each element of tuple by the delimiter.\nassert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\") ) == 'ID-is-4-UTS'\n\"\"\"\ndef join_tuple_elements(tup, delimiter):\n    \"\"\"\n    Concatenate each element of a tuple into a single string, separated by the given delimiter.\n    Each element is converted to string. Raises TypeError if input is not a tuple.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    delim = \"\" if delimiter is None else str(delimiter)\n    return delim.join(str(x) for x in tup)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "\"\"\"\nWrite a function to extract the nth element from a given list of tuples.\nassert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\n\"\"\"\ndef extract_nth_elements(tuple_list, n):\n    \"\"\"\n    Return a list containing the nth element (0-based) from each tuple in tuple_list.\n    Raises:\n        TypeError: if inputs are not of expected types.\n        IndexError: if any tuple does not have index n.\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"tuple_list must be a list of tuples\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    result = []\n    for t in tuple_list:\n        if not isinstance(t, tuple):\n            raise TypeError(\"All items in tuple_list must be tuples\")\n        result.append(t[n])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "\"\"\"\nWrite a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\n\"\"\"\ndef convert_date_yyyy_mm_dd_to_dd_mm_yyyy(date_str: str) -> str:\n    from datetime import datetime\n    dt = datetime.strptime(date_str.strip(), \"%Y-%m-%d\")\n    return dt.strftime(\"%d-%m-%Y\")", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "\"\"\"\nWrite a function to extract only the rear index element of each string in the given tuple.\nassert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']\n\"\"\"\nfrom typing import Tuple\n\ndef extract_rear_index_elements(strings: Tuple[str, ...]) -> Tuple[str, ...]:\n    \"\"\"\n    Given a tuple of strings, return a tuple containing the last character of each string.\n    If a string is empty, place an empty string in the corresponding position.\n    \"\"\"\n    return tuple(s[-1] if s else \"\" for s in strings)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "\"\"\"\nWrite a python function to find the average of cubes of first n natural numbers.\nassert find_Average_Of_Cube(2) == 4.5\n\"\"\"\ndef average_of_cubes_of_first_n(n: int) -> float:\n    \"\"\"\n    Returns the average of cubes of the first n natural numbers (1^3 + 2^3 + ... + n^3) / n.\n    Uses the closed-form formula: sum of cubes is (n(n+1)/2)^2, so average is n*(n+1)^2 / 4.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return (n * (n + 1) * (n + 1)) / 4.0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "\"\"\"\nWrite a function to count the number of sublists containing a particular element.\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3\n\"\"\"\ndef count_sublists_with_element(nested, element):\n    \"\"\"\n    Return the number of sublists within 'nested' that contain 'element'.\n    Each sublist is checked with 'element in sub'.\n    Non-iterable sublists are ignored.\n    \"\"\"\n    count = 0\n    for sub in nested:\n        try:\n            if element in sub:\n                count += 1\n        except TypeError:\n            continue\n    return count", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "\"\"\"\nWrite a function to sort the given array by using shell sort.\nassert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]\n\"\"\"\ndef shell_sort(arr):\n    \"\"\"\n    Sort the input list in place using the Shell Sort algorithm and return the sorted list.\n    \"\"\"\n    if arr is None:\n        return None\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "\"\"\"\nWrite a function to filter odd numbers.\nassert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]\n\"\"\"\ndef filter_odds(iterable):\n    \"\"\"Return a list of odd integers from the given iterable. Non-integer values are ignored.\"\"\"\n    return [n for n in iterable if isinstance(n, int) and n % 2 != 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "\"\"\"\nWrite a function to find the surface area of a cube of a given size.\nassert surfacearea_cube(5)==150\n\"\"\"\ndef cube_surface_area(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given the side length.\n    Surface area = 6 * (side_length ** 2)\n    \"\"\"\n    return 6 * (side_length ** 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "\"\"\"\nWrite a python function to remove odd numbers from a given list.\nassert remove_odd([1,2,3]) == [2]\n\"\"\"\ndef remove_odd_numbers(nums):\n    \"\"\"\n    Remove odd integers from the list in place.\n    Non-integer values are left untouched.\n    Returns the mutated list for convenience.\n    \"\"\"\n    nums[:] = [x for x in nums if not (isinstance(x, int) and x % 2 != 0)]\n    return nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "\"\"\"\nWrite a function to convert more than one list to nested dictionary.\nassert convert_list_dictionary([\"S001\", \"S002\", \"S003\", \"S004\"],[\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"] ,[85, 98, 89, 92])==[{'S001': {'Adina Park': 85}}, {'S002': {'Leyton Marsh': 98}}, {'S003': {'Duncan Boyle': 89}}, {'S004': {'Saim Richards': 92}}]\n\"\"\"\ndef lists_to_nested_dict(paths):\n    \"\"\"\n    Convert a collection of paths (each path is an iterable of hashable keys)\n    into a nested dictionary where each path's keys define a nesting.\n    Example:\n    [[1, 2, 3], [1, 2, 4], [1, 5]] -> {1: {2: {3: {}, 4: {}}, 5: {}}}\n    \"\"\"\n    nested = {}\n    for path in paths:\n        if not path:\n            continue\n        node = nested\n        for key in path:\n            if key not in node or not isinstance(node[key], dict):\n                node[key] = {}\n            node = node[key]\n    return nested", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "\"\"\"\nWrite a function to perform index wise multiplication of tuple elements in the given two tuples.\nassert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))\n\"\"\"\ndef index_wise_multiply(tup1, tup2):\n    \"\"\"\n    Returns a tuple containing the products of corresponding elements from tup1 and tup2.\n    Both inputs must be tuples of equal length.\n    \"\"\"\n    if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(tup1) != len(tup2):\n        raise ValueError(\"Tuples must have the same length for index-wise multiplication.\")\n    return tuple(a * b for a, b in zip(tup1, tup2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "\"\"\"\nWrite a function to remove odd characters in a string.\nassert remove_odd(\"python\")==(\"yhn\")\n\"\"\"\ndef remove_odd_characters(s: str) -> str:\n    \"\"\"\n    Remove characters at odd indices (0-based) from the string.\n    Returns a string consisting of characters at even indices.\n    \"\"\"\n    return s[::2]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "\"\"\"\nWrite a function to check whether the entered number is greater than the elements of the given array.\nassert check_greater([1, 2, 3, 4, 5], 4) == False\n\"\"\"\ndef is_greater_than_all(num, arr):\n    \"\"\"\n    Check if the given number is greater than every element in the array.\n    Returns True if num > x for all x in arr. If arr is empty, returns True.\n    \"\"\"\n    return all(num > x for x in arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "\"\"\"\nWrite a python function to find a pair with highest product from a given array of integers.\nassert max_Product([1,2,3,4,7,0,8,4]) == (7,8)\n\"\"\"\ndef max_product_pair(arr):\n    \"\"\"\n    Returns a tuple containing two numbers from arr whose product is maximum.\n    Works for integers (positive, negative, and zero).\n    Raises ValueError if fewer than 2 elements.\n    \"\"\"\n    if arr is None or len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    \n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    \n    for x in arr:\n        # Update the largest two\n        if x > max1:\n            max2 = max1\n            max1 = x\n        elif x > max2:\n            max2 = x\n        \n        # Update the smallest two\n        if x < min1:\n            min2 = min1\n            min1 = x\n        elif x < min2:\n            min2 = x\n    \n    product1 = max1 * max2\n    product2 = min1 * min2\n    \n    if product1 >= product2:\n        return (max1, max2)\n    else:\n        return (min1, min2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "\"\"\"\nWrite a python function to find the last digit of a given number.\nassert last_Digit(123) == 3\n\"\"\"\ndef last_digit(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return abs(n) % 10", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "\"\"\"\nWrite a python function to return the negative numbers in a list.\nassert neg_nos([-1,4,5,-6]) == [-1,-6]\n\"\"\"\ndef negative_numbers(lst):\n    \"\"\"Return all negative numbers from the given list.\"\"\"\n    return [x for x in lst if isinstance(x, (int, float)) and not isinstance(x, bool) and x < 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "\"\"\"\nWrite a function to find the median length of a trapezium.\nassert median_trapezium(15,25,35)==20\n\"\"\"\ndef trapezium_median_length(a, b):\n    \"\"\"\n    Returns the median (midline) length of a trapezium given the lengths of its two parallel sides (bases).\n    The median length m equals the average of the bases: m = (a + b) / 2.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Base lengths must be numeric (int or float).\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Base lengths must be positive.\")\n    return (a + b) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "\"\"\"\nWrite a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\nassert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30\n\"\"\"\ndef max_subarray_sum_k_times(arr, k):\n    \"\"\"\n    Return the maximum subarray sum in the array formed by concatenating arr k times.\n    \"\"\"\n    if not arr or k <= 0:\n        return 0\n\n    def kadane(a):\n        cur = a[0]\n        best = a[0]\n        for x in a[1:]:\n            cur = max(x, cur + x)\n            if cur > best:\n                best = cur\n        return best\n\n    def max_prefix_sum(a):\n        s = 0\n        best = a[0]\n        for x in a:\n            s += x\n            if s > best:\n                best = s\n        return best\n\n    def max_suffix_sum(a):\n        s = 0\n        best = a[-1]\n        for x in reversed(a):\n            s += x\n            if s > best:\n                best = s\n        return best\n\n    s1 = kadane(arr)\n    s2 = kadane(arr + arr)\n\n    if k == 1:\n        return s1\n\n    total = sum(arr)\n    pref = max_prefix_sum(arr)\n    suff = max_suffix_sum(arr)\n\n    cross = suff + pref + (k - 2) * total\n    return max(s2, cross)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "\"\"\"\nWrite a function to find cubes of individual elements in a list.\nassert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]\n\"\"\"\ndef cube_elements(lst):\n    \"\"\"\n    Return a list containing the cube of each element in the input list.\n    Each element x is transformed to x**3.\n    \"\"\"\n    return [x ** 3 for x in lst]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "\"\"\"\nWrite a function to reverse each string in a given list of string values.\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\n\"\"\"\nfrom typing import List\n\ndef reverse_strings_in_list(strings: List[str]) -> List[str]:\n    return [s[::-1] for s in strings]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "\"\"\"\nWrite a python function to count the occurence of all elements of list in a tuple.\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3\n\"\"\"\ndef count_occurrences_of_list_in_tuple(elements, tup):\n    \"\"\"\n    Count occurrences of each element from the given list in the provided tuple.\n    Returns a dictionary mapping each distinct element from 'elements' (preserving first-appearance order)\n    to its count in 'tup'. Elements not present in tup will have count 0.\n    \"\"\"\n    counts = {}\n    for el in elements:\n        if el not in counts:\n            counts[el] = tup.count(el)\n    return counts", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "\"\"\"\nWrite a function to join a list of multiple integers into a single integer.\nassert multiple_to_single([11, 33, 50])==113350\n\"\"\"\nimport math\n\ndef join_integers_to_number(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list of non-negative integers\")\n    if len(nums) == 0:\n        raise ValueError(\"nums must be a non-empty list\")\n    for n in nums:\n        if not isinstance(n, int):\n            raise TypeError(\"All elements must be integers\")\n        if n < 0:\n            raise ValueError(\"All numbers must be non-negative\")\n    result = 0\n    for n in nums:\n        digits = 1 if n == 0 else int(math.log10(n)) + 1\n        result = result * (10 ** digits) + n\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "\"\"\"\nWrite a function to check whether the given month number contains 31 days or not.\nassert check_monthnumb_number(5)==True\n\"\"\"\ndef has_31_days(month: int) -> bool:\n    \"\"\"\n    Return True if the given month number (1-12) has 31 days, otherwise False.\n    Invalid inputs return False.\n    \"\"\"\n    if not isinstance(month, int):\n        return False\n    if month < 1 or month > 12:\n        return False\n    return month in (1, 3, 5, 7, 8, 10, 12)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "\"\"\"\nWrite a function to extract the elementwise and tuples from the given two tuples.\nassert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)\n\"\"\"\ndef extract_elementwise_and_tuples(t1, t2):\n    \"\"\"\n    Given two sequences (tuples) of equal length, return a tuple consisting of:\n      - a tuple of elementwise 'AND' results\n      - a tuple of paired elements (tuples) from both input sequences\n    \"\"\"\n    t1 = tuple(t1)\n    t2 = tuple(t2)\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    paired = tuple(zip(t1, t2))\n    results = []\n    for a, b in paired:\n        try:\n            if isinstance(a, bool) and isinstance(b, bool):\n                results.append(a and b)\n            elif isinstance(a, int) and isinstance(b, int):\n                results.append(a & b)\n            else:\n                results.append(a & b)\n        except Exception:\n            results.append(bool(a) and bool(b))\n    return (tuple(results), paired)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "\"\"\"\nWrite a function to find the area of a rectangle.\nassert rectangle_area(10,20)==200\n\"\"\"\ndef rectangle_area(length, width):\n    return length * width", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "\"\"\"\nWrite a function to extract specified size of strings from a given list of string values.\nassert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']\n\"\"\"\nfrom typing import Iterable, List\n\ndef extract_strings_of_size(values: Iterable[str], size: int) -> List[str]:\n    \"\"\"\n    Extract strings from a list that have the specified length.\n\n    Parameters:\n        values: An iterable of strings.\n        size: The desired length for strings to be extracted (non-negative integer).\n\n    Returns:\n        A list of strings from values whose length equals size.\n    \"\"\"\n    if not isinstance(size, int) or size < 0:\n        raise ValueError(\"size must be a non-negative integer\")\n\n    return [v for v in values if isinstance(v, str) and len(v) == size]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "\"\"\"\nWrite a function to remove all whitespaces from the given string.\nassert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\n\"\"\"\ndef remove_whitespaces(s: str) -> str:\n    \"\"\"Remove all whitespace characters from the input string and return the result.\"\"\"\n    return ''.join(s.split())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\t"]]}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "\"\"\"\nWrite a function to find the minimum value in a given heterogeneous list.\nassert min_val(['Python', 3, 2, 4, 5, 'version'])==2\n\"\"\"\ndef min_value_heterogeneous(lst):\n    \"\"\"\n    Return the minimum element in a heterogeneous list.\n    Ordering rules:\n    - Booleans and numbers (int/float) are considered numbers and ordered by their numeric value.\n    - All other types are ordered by their string representation (repr).\n    - Numbers are prioritized before non-numbers.\n    Raises ValueError if the list is empty and TypeError if input is not a list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    if not lst:\n        raise ValueError(\"min_value_heterogeneous() arg is an empty sequence\")\n\n    def key(x):\n        if isinstance(x, bool):\n            return (0, int(x))\n        if isinstance(x, (int, float)):\n            return (0, x)\n        # complex or other non-numeric types are treated as non-numeric\n        return (1, repr(x))\n\n    return min(lst, key=key)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "\"\"\"\nWrite a python function to find the sum of even factors of a number.\nassert sumofFactors(18) == 26\n\"\"\"\ndef sum_even_factors(n):\n    \"\"\"\n    Return the sum of all positive even divisors of n.\n    For non-positive or odd n, returns 0.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        return 0\n\n    m = n // 2\n    s = 0\n    i = 1\n    while i * i <= m:\n        if m % i == 0:\n            s += i\n            j = m // i\n            if j != i:\n                s += j\n        i += 1\n    return 2 * s", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "\"\"\"\nWrite a python function to get the first element of each sublist.\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\n\"\"\"\ndef first_of_each_sublist(sublists):\n    \"\"\"\n    Return a list containing the first element of each sublist.\n    Assumes each sublist is non-empty.\n    \"\"\"\n    return [sub[0] for sub in sublists]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "\"\"\"\nWrite a function to find the maximum product subarray of the given array.\nassert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112\n\"\"\"\ndef max_product_subarray(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = result = nums[0]\n    for x in nums[1:]:\n        if x < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(x, max_prod * x)\n        min_prod = min(x, min_prod * x)\n        result = max(result, max_prod)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "\"\"\"\nWrite a python function to find the product of the array multiplication modulo n.\nassert find_remainder([ 100, 10, 5, 25, 35, 14 ],11) ==9\n\"\"\"\ndef product_of_array_mod(arr, n):\n    \"\"\"\n    Returns the product of all integers in arr modulo n.\n    arr: iterable of integers\n    n: positive integer modulus\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    result = 1 % n\n    for a in arr:\n        result = (result * (a % n)) % n\n        if result == 0:\n            return 0\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "\"\"\"\nWrite a function to find the pairwise addition of the neighboring elements of the given tuple.\nassert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)\n\"\"\"\ndef pairwise_addition_of_neighbors(t: tuple) -> tuple:\n    \"\"\"\n    Return a tuple containing the sums of each pair of neighboring elements in the input tuple.\n    For a tuple of length n, returns a tuple of length n-1 where result[i] = t[i] + t[i+1].\n    If input length < 2, returns an empty tuple.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if len(t) < 2:\n        return tuple()\n    return tuple(t[i] + t[i + 1] for i in range(len(t) - 1))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "\"\"\"\nWrite a function that matches a word containing 'z'.\nassert text_match_wordz(\"pythonz.\")==True\n\"\"\"\ndef find_words_with_z(text):\n    import re\n    pattern = re.compile(r'\\b\\w*z\\w*\\b', re.IGNORECASE)\n    return pattern.findall(text)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "\"\"\"\nWrite a function to sort a dictionary by value.\nassert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]\n\"\"\"\ndef sort_dict_by_value(d, reverse=False):\n    \"\"\"\n    Return a new dictionary sorted by its values.\n    The resulting dictionary preserves the sorted order (Python 3.7+).\n    \"\"\"\n    return dict(sorted(d.items(), key=lambda item: item[1], reverse=reverse))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "\"\"\"\nWrite a python function to convert the given string to lower case.\nassert is_lower(\"InValid\") == \"invalid\"\n\"\"\"\ndef to_lower_case(s: str) -> str:\n    \"\"\"\n    Convert the input string to lowercase and return the result.\n    \"\"\"\n    return s.lower()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "\"\"\"\nWrite a function to calculate the sum of perrin numbers.\nassert cal_sum(9) == 49\n\"\"\"\ndef sum_perrin(n: int) -> int:\n    \"\"\"\n    Return the sum of Perrin numbers P(0) through P(n) inclusive.\n    Perrin numbers: P(0)=3, P(1)=0, P(2)=2, and P(k)=P(k-2)+P(k-3) for k>=3.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n\n    # Sum up to P(2)\n    s = 3 + 0 + 2  # 3\n    # Rolling window for P(i-1), P(i-2), P(i-3) => start with P(2), P(1), P(0)\n    p0, p1, p2 = 2, 0, 3  # P(2), P(1), P(0)\n\n    for i in range(3, n + 1):\n        p = p1 + p2      # P(i) = P(i-2) + P(i-3)\n        s += p\n        p0, p1, p2 = p, p0, p1  # advance window to (P(i), P(i-1), P(i-2))\n\n    return s", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "\"\"\"\nWrite a function to replace characters in a string.\nassert replace_char(\"polygon\",'y','l')==(\"pollgon\")\n\"\"\"\ndef replace_chars(s, mapping):\n    \"\"\"\n    Replace characters in the string 's' using a mapping dict.\n    mapping: dict where keys are single-character strings and values are replacement strings.\n    For each character in 's', if it exists as a key in 'mapping', it is replaced by mapping[char].\n    Otherwise, the character is kept unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"s must be a string\")\n    if not isinstance(mapping, dict):\n        raise TypeError(\"mapping must be a dict\")\n    for k, v in mapping.items():\n        if not isinstance(k, str) or len(k) != 1:\n            raise ValueError(\"mapping keys must be single-character strings\")\n        if not isinstance(v, str):\n            raise ValueError(\"mapping values must be strings\")\n    return ''.join(mapping.get(ch, ch) for ch in s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "\"\"\"\nWrite a python function to find the sublist having minimum length.\nassert Find_Min([[1],[1,2],[1,2,3]]) == [1]\n\"\"\"\ndef sublist_with_min_length(lists_of_sublists):\n    \"\"\"\n    Returns the sublist with the minimum length from a list/tuple of sublists.\n    If input is empty, returns an empty list.\n    \"\"\"\n    if not isinstance(lists_of_sublists, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple of sublists.\")\n    if len(lists_of_sublists) == 0:\n        return []\n    return min(lists_of_sublists, key=len)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "\"\"\"\nWrite a function to find the tuple intersection of elements in the given tuple list irrespective of their order.\nassert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}\n\"\"\"\ndef tuple_intersection_of_tuples(tuple_list):\n    \"\"\"\n    Returns a tuple containing elements common to all tuples in tuple_list.\n    The order of elements in the result follows their first appearance in the first tuple,\n    and duplicates are removed.\n    \"\"\"\n    if not tuple_list:\n        return tuple()\n    common = set(tuple_list[0])\n    for t in tuple_list[1:]:\n        common &= set(t)\n        if not common:\n            return tuple()\n    first = tuple_list[0]\n    seen = set()\n    res = []\n    for x in first:\n        if x in common and x not in seen:\n            seen.add(x)\n            res.append(x)\n    return tuple(res)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "\"\"\"\nWrite a function to find all possible combinations of the elements of a given list.\nassert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]\n\"\"\"\ndef all_combinations(lst):\n    \"\"\"\n    Return all possible combinations (the power set) of elements from the given list.\n    Each combination is represented as a list, and the empty combination is included.\n    \"\"\"\n    items = list(lst)\n    result = [[]]\n    for item in items:\n        new_combinations = [subset + [item] for subset in result]\n        result.extend(new_combinations)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "\"\"\"\nWrite a python function to find the sum of the largest and smallest value in a given array.\nassert big_sum([1,2,3]) == 4\n\"\"\"\ndef sum_of_min_max(arr):\n    if arr is None:\n        raise ValueError(\"Input array is None\")\n    it = iter(arr)\n    try:\n        first = next(it)\n    except StopIteration:\n        raise ValueError(\"Input array must contain at least one element\")\n    mn = mx = first\n    for x in it:\n        if x < mn:\n            mn = x\n        if x > mx:\n            mx = x\n    return mn + mx", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "\"\"\"\nWrite a function to remove uppercase substrings from a given string.\nassert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\n\"\"\"\ndef remove_uppercase_substrings(s: str) -> str:\n    \"\"\"\n    Remove all substrings consisting of uppercase letters from the input string.\n    This implementation removes every uppercase character, which effectively\n    collapses all uppercase sequences.\n    \"\"\"\n    return ''.join(ch for ch in s if not ch.isupper())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "\"\"\"\nWrite a function to find the directrix of a parabola.\nassert parabola_directrix(5,3,2)==-198\n\"\"\"\ndef directrix_of_parabola(parabola):\n    \"\"\"\n    Compute the directrix line coefficients (A, B, C) for a parabola described in standard oriented form.\n    \n    Supported forms:\n      - {'shape': 'horizontal', 'h': ..., 'k': ..., 'a': ...}\n        Represents (y - k)^2 = 4 a (x - h). Directrix: x = h - a.\n      - {'shape': 'vertical', 'h': ..., 'k': ..., 'a': ...}\n        Represents (x - h)^2 = 4 a (y - k). Directrix: y = k - a.\n    \n    Returns:\n        A tuple (A, B, C) such that the directrix line is A*x + B*y + C = 0.\n    \"\"\"\n    shape = parabola.get('shape')\n    if shape == 'horizontal':\n        h = parabola.get('h', 0.0)\n        a = parabola.get('a')\n        if a is None:\n            raise ValueError(\"Parameter 'a' must be provided for a horizontal parabola.\")\n        A, B, C = 1.0, 0.0, -(h - a)  # x = h - a  =>  1*x + 0*y - (h - a) = 0\n    elif shape == 'vertical':\n        k = parabola.get('k', 0.0)\n        a = parabola.get('a')\n        if a is None:\n            raise ValueError(\"Parameter 'a' must be provided for a vertical parabola.\")\n        A, B, C = 0.0, 1.0, -(k - a)  # y = k - a  =>  0*x + 1*y - (k - a) = 0\n    else:\n        raise ValueError(\"Unsupported shape. Use 'horizontal' or 'vertical'.\")\n    return (A, B, C)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "\"\"\"\nWrite a function to find the union of the elements of two given tuples and output them in sorted order.\nassert union_elements((3, 4, 5, 6),(5, 7, 4, 10) ) == (3, 4, 5, 6, 7, 10)\n\"\"\"\ndef union_of_tuples(tup1, tup2):\n    \"\"\"\n    Return a list containing the union of elements from tup1 and tup2 in sorted order.\n    Elements are assumed to be hashable and comparable.\n    \"\"\"\n    return sorted(set(tup1) | set(tup2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "\"\"\"\nWrite a function to toggle the case of all characters in a string.\nassert toggle_string(\"Python\")==(\"pYTHON\")\n\"\"\"\ndef toggle_case(s: str) -> str:\n    return s.swapcase()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "\"\"\"\nWrite a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\nassert difference(3) == 30\n\"\"\"\ndef difference_sum_cubes_and_sum(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    s = n * (n + 1) // 2\n    sum_cubes = s * s\n    return sum_cubes - s", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\"\"\"\nWrite a python function which takes a list of integers and only returns the odd ones.\nassert Split([1,2,3,4,5,6]) == [1,3,5]\n\"\"\"\ndef filter_odds(nums):\n    return [n for n in nums if n % 2 != 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "\"\"\"\nWrite a python function to check whether the given list contains consecutive numbers or not.\nassert check_Consecutive([1,2,3,4,5]) == True\n\"\"\"\ndef has_consecutive_numbers(nums):\n    \"\"\"\n    Check if the given list contains consecutive numbers.\n    Returns True if the numbers form a consecutive sequence from\n    the minimum to the maximum value (duplicates allowed).\n    \"\"\"\n    if nums is None:\n        return False\n    if len(nums) <= 1:\n        return True\n    mn = min(nums)\n    mx = max(nums)\n    return (mx - mn + 1) == len(set(nums))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "\"\"\"\nWrite a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\nassert count_Pairs([1,2,1],3) == 2\n\"\"\"\nfrom collections import Counter\n\ndef count_unequal_pairs(nums):\n    n = len(nums)\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    freq = Counter(nums)\n    equal_pairs = sum(v * (v - 1) // 2 for v in freq.values())\n    return total_pairs - equal_pairs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "\"\"\"\nWrite a python function to find the sum of the per-digit difference between two integers.\nassert digit_distance_nums(1,2) == 1\n\"\"\"\ndef sum_per_digit_difference(a: int, b: int) -> int:\n    \"\"\"\n    Return the sum of the absolute differences of corresponding digits of a and b.\n    Digits are aligned from least significant digit; if lengths differ, the extra\n    digits are treated as differences with 0.\n    \"\"\"\n    a = abs(int(a))\n    b = abs(int(b))\n    total = 0\n    while a > 0 or b > 0:\n        total += abs((a % 10) - (b % 10))\n        a //= 10\n        b //= 10\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "\"\"\"\nWrite a function to get the sum of the digits of a non-negative integer.\nassert sum_digits(345)==12\n\"\"\"\ndef sum_of_digits(n: int) -> int:\n    \"\"\"\n    Return the sum of the digits of a non-negative integer n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    total = 0\n    while n:\n        total += n % 10\n        n //= 10\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "\"\"\"\nWrite a function to check whether a specified list is sorted or not.\nassert issort_list([1,2,4,6,8,10,12,14,16,17])==True\n\"\"\"\ndef is_sorted(lst):\n    \"\"\"\n    Check if the given list is sorted in non-decreasing order.\n    Returns True if sorted, False otherwise.\n    An empty list or a list with one element is considered sorted.\n    \"\"\"\n    if len(lst) < 2:\n        return True\n    prev = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] < prev:\n            return False\n        prev = lst[i]\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "\"\"\"\nWrite a function to find the sum of the largest contiguous sublist in the given list.\nassert max_sub_array_sum([-2, -3, 4, -1, -2, 1, 5, -3], 8) == 7\n\"\"\"\ndef max_subarray_sum(nums):\n    \"\"\"\n    Returns the sum of the largest contiguous subarray within nums.\n    If nums is empty, returns 0.\n    \"\"\"\n    nums = list(nums)\n    if not nums:\n        return 0\n\n    max_ending_here = max_so_far = nums[0]\n    for x in nums[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "\"\"\"\nWrite a function to remove lowercase substrings from a given string.\nassert remove_lowercase(\"PYTHon\")==('PYTH')\n\"\"\"\ndef remove_lowercase_substrings(s: str) -> str:\n    \"\"\"\n    Remove all contiguous substrings consisting of lowercase (Unicode-aware) letters from the input string.\n    \"\"\"\n    if not s:\n        return s\n    res = []\n    i = 0\n    n = len(s)\n    while i < n:\n        if s[i].islower():\n            j = i\n            while j < n and s[j].islower():\n                j += 1\n            i = j\n        else:\n            res.append(s[i])\n            i += 1\n    return ''.join(res)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "\"\"\"\nWrite a function to find the first adverb and their positions in a given sentence.\nassert find_adverb_position(\"clearly!! we can see the sky\")==(0, 7, 'clearly')\n\"\"\"\nimport re\nfrom typing import List, Tuple, Optional\n\n_ADVERB_WORDS = {\n    \"not\",\"very\",\"quite\",\"too\",\"almost\",\"barely\",\"frequently\",\"often\",\"usually\",\"normally\",\"always\",\"never\",\"seldom\",\"rarely\",\n    \"early\",\"late\",\"now\",\"soon\",\"there\",\"therefore\",\"thus\",\"however\",\"anyway\",\"anyhow\",\"still\",\"already\",\"just\",\"simply\",\n    \"nearly\",\"properly\",\"straight\",\"quickly\",\"slowly\",\"hard\",\"fast\",\"well\"\n}\n\ndef _is_adverb(token: str) -> bool:\n    lower = token.lower()\n    if lower in _ADVERB_WORDS:\n        return True\n    if len(lower) > 2 and lower.endswith(\"ly\"):\n        return True\n    return False\n\ndef find_first_adverb_and_positions(sentence: str) -> Tuple[Optional[str], List[int]]:\n    \"\"\"\n    Find the first adverb in the sentence and all positions (token indices) where that adverb occurs.\n    Returns a tuple: (first_adverb_lowercased, positions_list)\n    If no adverb is found, returns (None, []).\n    Positions are 0-based indices based on tokenized words.\n    \"\"\"\n    if sentence is None:\n        return None, []\n    tokens = re.findall(r\"\\b[\\w'-]+\\b\", sentence)\n    first = None\n    for t in tokens:\n        if _is_adverb(t):\n            first = t.lower()\n            break\n    if first is None:\n        return None, []\n    positions = [i for i, t in enumerate(tokens) if t.lower() == first]\n    return first, positions", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "\"\"\"\nWrite a python function to split a string into characters.\nassert split('python') == ['p','y','t','h','o','n']\n\"\"\"\ndef split_string_into_characters(s):\n    \"\"\"Split a string into its characters and return as a list.\"\"\"\n    return list(s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "\"\"\"\nWrite a function to extract values between quotation marks from a string.\nassert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java']\n\"\"\"\ndef extract_quoted_values(s):\n    \"\"\"\n    Extract all substrings that are enclosed in matching quotation marks\n    (single ' or double \"). Supports escaping with a backslash.\n    Returns a list of strings without the surrounding quotes.\n    \"\"\"\n    values = []\n    i = 0\n    n = len(s)\n    while i < n:\n        c = s[i]\n        if c == '\"' or c == \"'\":\n            quote = c\n            i += 1\n            current = []\n            while i < n:\n                ch = s[i]\n                if ch == '\\\\':\n                    if i + 1 < n:\n                        current.append(s[i + 1])\n                        i += 2\n                        continue\n                    else:\n                        i += 1\n                        continue\n                if ch == quote:\n                    values.append(''.join(current))\n                    i += 1\n                    break\n                else:\n                    current.append(ch)\n                    i += 1\n            # If no closing quote is found, skip\n        else:\n            i += 1\n    return values", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "\"\"\"\nWrite a python function to find the length of the longest sublists.\nassert Find_Max_Length([[1],[1,4],[5,6,7,8]]) == 4\n\"\"\"\ndef longest_sublist_length(list_of_sublists):\n    \"\"\"\n    Returns the length of the longest sublist (list or tuple) in list_of_sublists.\n    If there are no sublists, returns 0.\n    \"\"\"\n    max_len = 0\n    for sub in list_of_sublists:\n        if isinstance(sub, (list, tuple)):\n            l = len(sub)\n            if l > max_len:\n                max_len = l\n    return max_len", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "\"\"\"\nWrite a function to create a list of N empty dictionaries.\nassert empty_list(5)==[{},{},{},{},{}]\n\"\"\"\ndef create_list_of_empty_dicts(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return [{} for _ in range(n)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "\"\"\"\nWrite a python function to count the number of pairs whose xor value is odd.\nassert find_Odd_Pair([5,4,7,2,1],5) == 6\n\"\"\"\ndef count_pairs_with_odd_xor(nums):\n    \"\"\"\n    Count number of pairs (i, j) with i < j and nums[i] ^ nums[j] is odd.\n    XOR is odd iff one number is even and the other is odd.\n    Therefore, answer = (#even) * (#odd).\n    \"\"\"\n    nums = list(nums)\n    even = sum(1 for x in nums if (x & 1) == 0)\n    odd = len(nums) - even\n    return even * odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "\"\"\"\nWrite a function to sort each sublist of strings in a given list of lists.\nassert sort_sublists([['green', 'orange'], ['black', 'white'], ['white', 'black', 'orange']])==[['green', 'orange'], ['black', 'white'], ['black', 'orange', 'white']]\n\"\"\"\ndef sort_sublists_of_strings(data):\n    return [sorted(sub) for sub in data]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "\"\"\"\nWrite a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nassert max_product([3, 100, 4, 5, 150, 6]) == 3000\n\"\"\"\ndef max_product_increasing_subsequence(arr):\n    \"\"\"\n    Returns the maximum product obtainable by multiplying numbers of an increasing subsequence\n    (strictly increasing) of the given array. Subsequence length can be 1.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_end = [0] * n\n    min_end = [0] * n\n    best = float('-inf')\n    for i in range(n):\n        max_end[i] = arr[i]\n        min_end[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                a = max_end[j] * arr[i]\n                b = min_end[j] * arr[i]\n                max_end[i] = max(max_end[i], a, b)\n                min_end[i] = min(min_end[i], a, b)\n        if max_end[i] > best:\n            best = max_end[i]\n    return best", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "\"\"\"\nWrite a python function to check whether a list is sublist of another or not.\nassert is_Sub_Array([1,4,3,5],[1,2]) == False\n\"\"\"\ndef is_sublist(sub, lst):\n    \"\"\"\n    Return True if 'sub' appears as a contiguous subsequence (sublist) of 'lst'.\n    An empty list is considered a sublist of any list.\n    \"\"\"\n    if not isinstance(sub, list) or not isinstance(lst, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if not sub:\n        return True\n    m, n = len(sub), len(lst)\n    if m > n:\n        return False\n    for i in range(n - m + 1):\n        if lst[i:i + m] == sub:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "\"\"\"\nWrite a python function to find the surface area of a square pyramid with a given base edge and height.\nassert surface_Area(3,4) == 33\n\"\"\"\nimport math\n\ndef square_pyramid_surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid given the base edge and height.\n    Surface area = base_area + lateral_area\n    base_area = base_edge^2\n    lateral_area = 4 * (1/2 * base_edge * slant_height) = 2 * base_edge * slant_height\n    slant_height l = sqrt((base_edge/2)^2 + height^2)\n    \"\"\"\n    if base_edge < 0 or height < 0:\n        raise ValueError(\"base_edge and height must be non-negative\")\n    slant_height = math.hypot(base_edge / 2.0, height)\n    return base_edge * base_edge + 2.0 * base_edge * slant_height", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "\"\"\"\nWrite a python function to find the first digit of a given number.\nassert first_Digit(123) == 1\n\"\"\"\ndef first_digit(n):\n    \"\"\"\n    Return the most significant digit of the given number (based on its absolute value).\n    For zero, returns 0. Works with int and float types.\n    \"\"\"\n    if isinstance(n, bool) or not isinstance(n, (int, float)):\n        raise TypeError(\"n must be an int or float\")\n    n = abs(n)\n    if n == 0:\n        return 0\n    n_int = int(n)\n    while n_int >= 10:\n        n_int //= 10\n    return n_int", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "\"\"\"\nWrite a function to convert a list to a tuple.\nassert list_tuple([5, 10, 7, 4, 15, 3])==(5, 10, 7, 4, 15, 3)\n\"\"\"\ndef list_to_tuple(lst):\n    return tuple(lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "\"\"\"\nWrite a python function to remove duplicate numbers from a given number of lists.\nassert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5]\n\"\"\"\nfrom typing import Iterable, List, Any\n\ndef remove_duplicates_from_lists(*lists: Iterable[Any]) -> List[List[Any]]:\n    \"\"\"\n    Remove duplicates within each provided iterable, preserving order.\n    Each input iterable is treated as a separate list.\n    Returns a list of lists with duplicates removed per input, keeping first occurrences.\n    \"\"\"\n    result: List[List[Any]] = []\n    for lst in lists:\n        seen = set()\n        uniq = []\n        for item in lst:\n            if item not in seen:\n                seen.add(item)\n                uniq.append(item)\n        result.append(uniq)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "\"\"\"\nWrite a function to find the minimum product from the pairs of tuples within a given list.\nassert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8\n\"\"\"\ndef min_product_of_two_numbers(nums):\n    \"\"\"\n    Return the minimum product obtainable by multiplying any two distinct numbers from nums.\n    Handles integers and floats, including negatives and zeros.\n    Raises ValueError if len(nums) < 2.\n    \"\"\"\n    if nums is None or len(nums) < 2:\n        raise ValueError(\"Need at least two numbers to form a product.\")\n\n    INF = float('inf')\n    NINF = -float('inf')\n\n    # Track two smallest and two largest numbers\n    min1, min2 = INF, INF\n    max1, max2 = NINF, NINF\n\n    # Helpers for negatives/positives\n    neg_min = None   # most negative\n    neg_max = None   # least negative (closest to zero, i.e., max negative)\n    pos_min = None   # smallest positive\n    pos_max = None   # largest positive\n    has_zero = False\n\n    for x in nums:\n        # two smallest\n        if x <= min1:\n            min2 = min1\n            min1 = x\n        elif x < min2:\n            min2 = x\n\n        # two largest\n        if x >= max1:\n            max2 = max1\n            max1 = x\n        elif x > max2:\n            max2 = x\n\n        # classify\n        if x < 0:\n            if neg_min is None or x < neg_min:\n                neg_min = x\n            if neg_max is None or x > neg_max:\n                neg_max = x\n        elif x > 0:\n            if pos_min is None or x < pos_min:\n                pos_min = x\n            if pos_max is None or x > pos_max:\n                pos_max = x\n        else:\n            has_zero = True\n\n    candidates = []\n    if min2 != INF:\n        candidates.append(min1 * min2)\n    if max2 != NINF:\n        candidates.append(max1 * max2)\n    if neg_min is not None and pos_max is not None:\n        candidates.append(neg_min * pos_max)\n    if neg_max is not None and pos_min is not None:\n        candidates.append(neg_max * pos_min)\n    if has_zero:\n        candidates.append(0)\n\n    if not candidates:\n        raise ValueError(\"Unable to determine minimum product.\")\n\n    return min(candidates)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "\"\"\"\nWrite a function to drop empty items from a given dictionary.\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}\n\"\"\"\ndef drop_empty_items(d: dict, recursive: bool = False) -> dict:\n    \"\"\"\n    Drop entries with empty values from a dictionary.\n    Empty is defined as None, '', [], {}, (), or set().\n    If recursive is True, this is applied recursively to nested dicts and lists.\n    \"\"\"\n    def is_empty(val):\n        if val is None:\n            return True\n        if isinstance(val, (str, bytes)) and len(val) == 0:\n            return True\n        if isinstance(val, (list, tuple, set, dict)) and len(val) == 0:\n            return True\n        return False\n\n    def process_item(val):\n        if isinstance(val, dict) and recursive:\n            return drop(val)\n        if isinstance(val, list) and recursive:\n            new_list = []\n            for item in val:\n                if isinstance(item, dict):\n                    item2 = drop(item)\n                    if not is_empty(item2):\n                        new_list.append(item2)\n                else:\n                    if not is_empty(item):\n                        new_list.append(item)\n            return new_list\n        return val\n\n    def drop(cur):\n        res = {}\n        for k, v in cur.items():\n            if isinstance(v, dict) and recursive:\n                v2 = drop(v)\n                if not is_empty(v2):\n                    res[k] = v2\n            else:\n                v2 = process_item(v)\n                if not is_empty(v2):\n                    res[k] = v2\n        return res\n\n    if not isinstance(d, dict):\n        raise TypeError(\"drop_empty_items expects a dict\")\n    return drop(dict(d))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "\"\"\"\nWrite a function to interleave 3 lists of the same length into a single flat list.\nassert interleave_lists([1,2,3,4,5,6,7],[10,20,30,40,50,60,70],[100,200,300,400,500,600,700])==[1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]\n\"\"\"\ndef interleave_three_lists(l1, l2, l3):\n    \"\"\"\n    Interleave three lists of identical length into a single flat list.\n    Example: [1, 2], [3, 4], [5, 6] -> [1, 3, 5, 2, 4, 6]\n    \"\"\"\n    if not (isinstance(l1, list) and isinstance(l2, list) and isinstance(l3, list)):\n        raise TypeError(\"All arguments must be lists.\")\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        raise ValueError(\"All lists must have the same length.\")\n    return [item for triple in zip(l1, l2, l3) for item in triple]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "\"\"\"\nWrite a python function to find the last digit in factorial of a given number.\nassert last_Digit_Factorial(4) == 4\n\"\"\"\ndef last_digit_of_factorial(n):\n    \"\"\"\n    Return the last digit of n! for a non-negative integer n.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n >= 5:\n        return 0\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 10\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "\"\"\"\nWrite a function to find the dissimilar elements in the given two tuples.\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)\n\"\"\"\ndef find_dissimilar_elements(t1, t2):\n    \"\"\"\n    Return elements that are present in one of the tuples but not in both.\n    The result contains unique elements (order not guaranteed).\n    \"\"\"\n    return list(set(t1) ^ set(t2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "\"\"\"\nWrite a function to convert polar coordinates to rectangular coordinates.\nassert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j))\n\"\"\"\nimport math\n\ndef polar_to_rectangular(r, theta, degrees=False):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n    If degrees is True, theta is interpreted in degrees; otherwise radians.\n    Returns a tuple (x, y).\n    \"\"\"\n    if degrees:\n        theta = math.radians(theta)\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "\"\"\"\nWrite a python function to find the difference between largest and smallest value in a given list.\nassert big_diff([1,2,3,4]) == 3\n\"\"\"\ndef max_min_difference(nums):\n    \"\"\"\n    Return the difference between the largest and smallest values in nums.\n    Raises ValueError if nums is empty.\n    \"\"\"\n    if nums is None:\n        raise TypeError(\"nums must not be None\")\n    if len(nums) == 0:\n        raise ValueError(\"Cannot compute difference of empty list\")\n    \n    min_val = max_val = nums[0]\n    for n in nums[1:]:\n        if n < min_val:\n            min_val = n\n        if n > max_val:\n            max_val = n\n    return max_val - min_val", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "\"\"\"\nWrite a function to remove leading zeroes from an ip address.\nassert removezero_ip(\"216.08.094.196\")==('216.8.94.196')\n\"\"\"\ndef remove_ip_leading_zeros(ip: str) -> str:\n    ip = ip.strip()\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return ip\n    cleaned = []\n    for part in parts:\n        if part == '':\n            cleaned.append('0')\n            continue\n        if not part.isdigit():\n            raise ValueError(\"Invalid IP address segment: {!r}\".format(part))\n        cleaned.append(str(int(part)))\n    return '.'.join(cleaned)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "\"\"\"\nWrite a python function to interchange the first and last elements in a list.\nassert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12]\n\"\"\"\ndef interchange_first_last(lst):\n    \"\"\"\n    Interchange the first and last elements of the given list in place.\n    If the list has fewer than 2 elements, it is returned unchanged.\n    \"\"\"\n    if len(lst) >= 2:\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "\"\"\"\nWrite a python function to calculate the product of the unique numbers in a given list.\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) ==  720000000\n\"\"\"\ndef product_of_unique_numbers(nums):\n    unique_vals = set(nums)\n    prod = 1\n    for v in unique_vals:\n        prod *= v\n    return prod", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "\"\"\"\nWrite a function to find perfect squares between two given numbers.\nassert perfect_squares(1,30)==[1, 4, 9, 16, 25]\n\"\"\"\nimport math\n\ndef perfect_squares_in_range(a, b):\n    \"\"\"\n    Return a sorted list of perfect squares within the inclusive range [min(a,b), max(a,b)].\n    \"\"\"\n    lo, hi = (a, b) if a <= b else (b, a)\n    if hi < 0:\n        return []\n    if lo < 0:\n        lo = 0\n    m = math.isqrt(lo)\n    if m * m < lo:\n        m += 1\n    n = math.isqrt(hi)\n    if m > n:\n        return []\n    return [i * i for i in range(m, n + 1)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "\"\"\"\nWrite a function to check if the given integer is a prime number.\nassert prime_num(13)==True\n\"\"\"\ndef is_prime(n: int) -> bool:\n    \"\"\"\n    Return True if n is a prime number, otherwise False.\n    Handles integers less than 2 as non-prime.\n    Uses 6k +/- 1 optimization for efficiency.\n    \"\"\"\n    if n < 2:\n        return False\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "\"\"\"\nWrite a python function to find the first repeated character in a given string.\nassert first_repeated_char(\"abcabc\") == \"a\"\n\"\"\"\nfrom typing import Optional\n\ndef first_repeated_character(s: str) -> Optional[str]:\n    \"\"\"\n    Returns the first character that repeats in the string when scanned from left to right.\n    If no character repeats, returns None.\n    \"\"\"\n    if s is None:\n        return None\n    seen = set()\n    for ch in s:\n        if ch in seen:\n            return ch\n        seen.add(ch)\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "\"\"\"\nWrite a function which returns nth catalan number.\nassert catalan_number(10)==16796\n\"\"\"\ndef catalan(n):\n    \"\"\"\n    Return the nth Catalan number (0-indexed).\n    C_0 = 1, and C_n = binom(2n, n) / (n + 1).\n    This implementation uses the multiplicative formula to compute binom(2n, n).\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be a non-negative integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    res = 1\n    for k in range(1, n + 1):\n        res = res * (n + k) // k  # binom(2n, n)\n    return res // (n + 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "\"\"\"\nWrite a function to check whether the given number is armstrong or not.\nassert armstrong_number(153)==True\n\"\"\"\ndef is_armstrong(number: int) -> bool:\n    \"\"\"\n    Check if a non-negative integer is an Armstrong (narcissistic) number.\n    An Armstrong number is equal to the sum of its digits each raised to the power\n    of the number of digits.\n    \"\"\"\n    if number < 0:\n        return False\n    digits = [int(d) for d in str(number)]\n    power = len(digits)\n    total = sum(d ** power for d in digits)\n    return total == number", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "\"\"\"\nWrite a function to convert degrees to radians.\nassert radian_degree(90)==1.5707963267948966\n\"\"\"\ndef degrees_to_radians(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \"\"\"\n    from math import pi\n    return degrees * pi / 180.0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "\"\"\"\nWrite a function to find the difference of the first even and first odd number of a given list.\nassert diff_even_odd([1,3,5,7,4,1,6,8])==3\n\"\"\"\ndef diff_first_even_odd(nums):\n    if nums is None or len(nums) == 0:\n        raise ValueError(\"Input must be a non-empty iterable of integers\")\n    \n    first_even = None\n    first_odd = None\n\n    for n in nums:\n        if isinstance(n, int) and not isinstance(n, bool):\n            if first_even is None and n % 2 == 0:\n                first_even = n\n            if first_odd is None and n % 2 != 0:\n                first_odd = n\n            if first_even is not None and first_odd is not None:\n                break\n\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd integer\")\n\n    return first_even - first_odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "\"\"\"\nWrite a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\nassert find_literals('The quick brown fox jumps over the lazy dog.', 'fox') == ('fox', 16, 19)\n\"\"\"\nimport re\n\ndef search_regex_in_string(s, pattern, flags=0):\n    \"\"\"\n    Search for the first occurrence of the regex pattern in s.\n    Returns a tuple: (matched_substring, start_index, end_index)\n    If no match is found, returns (None, -1, -1).\n    \"\"\"\n    if s is None or pattern is None:\n        return (None, -1, -1)\n\n    try:\n        # Allow passing either a string pattern or a compiled regex object\n        if hasattr(pattern, \"search\") and callable(pattern.search):\n            regex = pattern\n        else:\n            regex = re.compile(pattern, flags)\n    except re.error:\n        return (None, -1, -1)\n\n    m = regex.search(s)\n    if m:\n        return (m.group(0), m.start(), m.end())\n    else:\n        return (None, -1, -1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "\"\"\"\nWrite a function to reverse words seperated by spaces in a given string.\nassert reverse_words(\"python program\")==(\"program python\")\n\"\"\"\ndef reverse_words(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a string. Words are considered sequences\n    separated by whitespace. Consecutive whitespace is treated as a single separator.\n    \"\"\"\n    return ' '.join(s.split()[::-1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "\"\"\"\nWrite a function to find sum and average of first n natural numbers.\nassert sum_average(10)==(55, 5.5)\n\"\"\"\ndef sum_and_average(n):\n    \"\"\"\n    Compute the sum and average of the first n natural numbers (1..n).\n    Returns a tuple (total_sum, average).\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    total = n * (n + 1) // 2\n    average = total / n\n    return total, average", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "\"\"\"\nWrite a function to find the size in bytes of the given tuple.\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3) ) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))\n\"\"\"\ndef tuple_size_in_bytes(t):\n    \"\"\"\n    Return the memory size in bytes of the given tuple object using sys.getsizeof.\n    This size accounts for the tuple object itself, not recursively the sizes of contained objects.\n    \"\"\"\n    import sys\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return sys.getsizeof(t)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "\"\"\"\nWrite a python function to split a list at the nth eelment and add the first part to the end.\nassert split_Arr([12,10,5,6,52,36],2) == [5,6,52,36,12,10]\n\"\"\"\ndef split_at_n_and_append_first(lst, n):\n    \"\"\"\n    Split lst at the nth element and append the first part to the end.\n    Returns a new list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    m = len(lst)\n    if m == 0:\n        return []\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    k = n % m\n    return lst[k:] + lst[:k]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "\"\"\"\nWrite a python function which takes a list and returns a list with the same elements, but the k'th element removed.\nassert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]\n\"\"\"\ndef remove_kth(lst, k):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k out of range\")\n    return lst[:k-1] + lst[k:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "\"\"\"\nWrite a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\nassert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n\"\"\"\ndef unzip_pairs(pairs):\n    first = []\n    second = []\n    for pair in pairs:\n        a, b = pair\n        first.append(a)\n        second.append(b)\n    return [first, second]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "\"\"\"\nWrite a python function to find the sum of the product of consecutive binomial co-efficients.\nassert sum_Of_product(3) == 15\n\"\"\"\nimport math\n\ndef sum_consecutive_binomial_products(n: int) -> int:\n    \"\"\"\n    Returns the sum of products of consecutive binomial coefficients in the nth row:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    For n >= 1, this equals C(2n, n-1). For n <= 0, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return math.comb(2 * n, n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "\"\"\"\nWrite a python function to check whether the given number is even or not.\nassert is_Even(1) == False\n\"\"\"\ndef is_even(n):\n    return n % 2 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "\"\"\"\nWrite a function to find the cumulative sum of all the values that are present in the given tuple list.\nassert cummulative_sum([(1, 3), (5, 6, 7), (2, 6)]) == 30\n\"\"\"\ndef cumulative_sum_of_values_in_tuples(tuple_list):\n    \"\"\"\n    Return the sum of all numeric values contained in a list of tuples.\n    Each element in each tuple is assumed to be a number.\n    \"\"\"\n    return sum(sum(t) for t in tuple_list)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "\"\"\"\nWrite a function to move all the numbers to the end of the given string.\nassert move_num('I1love143you55three3000thousand') == 'Iloveyouthreethousand1143553000'\n\"\"\"\ndef move_numbers_to_end(s: str) -> str:\n    non_digits = []\n    digits = []\n    for ch in s:\n        if ch.isdigit():\n            digits.append(ch)\n        else:\n            non_digits.append(ch)\n    return ''.join(non_digits + digits)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "\"\"\"\nWrite a python function to convert a given string to uppercase.\nassert is_upper(\"person\") ==\"PERSON\"\n\"\"\"\ndef to_uppercase(s: str) -> str:\n    \"\"\"\n    Convert the input string to uppercase.\n    \"\"\"\n    return s.upper()", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "\"\"\"\nWrite a function which takes a tuple of tuples and returns the average value for each tuple as a list.\nassert average_tuple(((10, 10, 10, 12), (30, 45, 56, 45), (81, 80, 39, 32), (1, 2, 3, 4)))==[30.5, 34.25, 27.0, 23.25]\n\"\"\"\ndef averages_of_tuples(data):\n    \"\"\"\n    Given a tuple of tuples of numbers, returns a list containing the average of each inner tuple.\n    If an inner tuple is empty, its average is 0.0.\n    \"\"\"\n    return [sum(inner) / len(inner) if inner else 0.0 for inner in data]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "\"\"\"\nWrite a function to replace all spaces in the given string with '%20'.\nassert replace_spaces(\"My Name is Dawood\") == 'My%20Name%20is%20Dawood'\n\"\"\"\ndef replace_spaces(s: str) -> str:\n    return s.replace(' ', '%20')", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "\"\"\"\nWrite a function which takes two tuples of the same length and performs the element wise modulo.\nassert tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5)) == (0, 4, 5, 1)\n\"\"\"\ndef elementwise_modulo(a: tuple, b: tuple) -> tuple:\n    if len(a) != len(b):\n        raise ValueError(\"Tuples must have the same length\")\n    return tuple(x % y for x, y in zip(a, b))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "\"\"\"\nWrite a python function to find nth bell number.\nassert bell_Number(2) == 2\n\"\"\"\ndef bell_number(n):\n    \"\"\"\n    Return the nth Bell number B(n) (0-indexed), i.e., the number of partitions of a set of size n.\n    Uses Bell's triangle (Aitken's array) with O(n^2) time and O(n) space.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    prev = [1]  # row 0\n    for i in range(1, n + 1):\n        cur = [0] * (i + 1)\n        cur[0] = prev[-1]  # B[i][0] = B[i-1][i-1]\n        for j in range(1, i + 1):\n            cur[j] = cur[j - 1] + prev[j - 1]\n        prev = cur\n    return prev[0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "\"\"\"\nWrite a function which given a matrix represented as a list of lists returns the max of the n'th column.\nassert max_of_nth([[5, 6, 7], [1, 3, 5], [8, 9, 19]], 2) == 19\n\"\"\"\ndef max_in_column(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column (0-based index) of a matrix\n    represented as a list of lists.\n    All rows must have at least n+1 elements and contain numeric values.\n    \"\"\"\n    if not isinstance(matrix, list) or len(matrix) == 0:\n        raise ValueError(\"matrix must be a non-empty list of lists\")\n    if not isinstance(n, int):\n        raise ValueError(\"column index must be an integer\")\n    values = []\n    for i, row in enumerate(matrix):\n        if not isinstance(row, list):\n            raise ValueError(\"matrix must be a list of lists\")\n        if n < 0 or n >= len(row):\n            raise ValueError(\"column index out of range in row {}\".format(i))\n        val = row[n]\n        if not isinstance(val, (int, float)):\n            raise ValueError(\"matrix elements must be numeric\")\n        values.append(val)\n    if not values:\n        raise ValueError(\"no values found in specified column\")\n    return max(values)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "\"\"\"\nWrite a function to find kth element from the given two sorted arrays.\nassert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n\"\"\"\ndef find_kth_sorted_arrays(A, B, k):\n    \"\"\"\n    Return the k-th smallest element (1-based) from the union of two sorted arrays A and B.\n    Arrays are assumed to be sorted in non-decreasing order.\n    Raises ValueError if k is out of bounds.\n    \"\"\"\n    m, n = len(A), len(B)\n    if k < 1 or k > m + n:\n        raise ValueError(\"k is out of bounds\")\n\n    i = 0  # pointer into A\n    j = 0  # pointer into B\n\n    while True:\n        if i == m:\n            return B[j + k - 1]\n        if j == n:\n            return A[i + k - 1]\n        if k == 1:\n            return A[i] if A[i] <= B[j] else B[j]\n\n        half = k // 2\n        new_i = min(i + half, m) - 1\n        new_j = min(j + half, n) - 1\n\n        if A[new_i] <= B[new_j]:\n            k -= (new_i - i + 1)\n            i = new_i + 1\n        else:\n            k -= (new_j - j + 1)\n            j = new_j + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "\"\"\"\nWrite a function to find the n most expensive items in a given dataset.\nassert expensive_items([{'name': 'Item-1', 'price': 101.1},{'name': 'Item-2', 'price': 555.22}],1)==[{'name': 'Item-2', 'price': 555.22}]\n\"\"\"\ndef top_n_expensive(items, n, price_key='price'):\n    \"\"\"\n    Return the n items with the highest price from a dataset.\n\n    The dataset can be:\n      - a list of dictionaries with a price field (price_key or common keys),\n      - objects with an attribute named price_key,\n      - sequences like (id, price) where price is the second element.\n\n    Parameters:\n      items: iterable of items\n      n: number of top items to return\n      price_key: key/name used to fetch price from dict or attribute (optional)\n\n    Returns:\n      List of top-n items by price. Items without a retrievable price are ignored.\n    \"\"\"\n    if n is None or not isinstance(n, int) or n <= 0:\n        return []\n\n    def extract_price(item):\n        # dict\n        if isinstance(item, dict):\n            if price_key is not None and price_key in item:\n                return item[price_key]\n            for k in ('price', 'cost', 'amount', 'value'):\n                if k in item:\n                    return item[k]\n            raise KeyError(\"Price not found in dict item.\")\n        # attribute\n        if price_key is not None and hasattr(item, price_key):\n            return getattr(item, price_key)\n        for k in ('price', 'cost', 'amount', 'value'):\n            if hasattr(item, k):\n                return getattr(item, k)\n        # sequence-like: assume (id, price)\n        if isinstance(item, (list, tuple)) and len(item) >= 2:\n            p = item[1]\n            if isinstance(p, (int, float)):\n                return p\n        raise TypeError(\"Cannot extract price from item: {}\".format(item))\n\n    priced = []\n    for it in items:\n        try:\n            pr = extract_price(it)\n            priced.append((pr, it))\n        except Exception:\n            continue\n\n    if not priced:\n        return []\n\n    priced.sort(key=lambda x: x[0], reverse=True)\n    top = priced[:n]\n    return [item for _, item in top]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "\"\"\"\nWrite a function to divide two lists element wise.\nassert div_list([4,5,6],[1, 2, 3])==[4.0,2.5,2.0]\n\"\"\"\ndef elementwise_divide(a, b):\n    \"\"\"\n    Divide two lists element-wise: return a new list where result[i] = a[i] / b[i].\n    Raises:\n      ValueError if lengths differ\n      TypeError if inputs are not lists or elements are non-numeric\n      ZeroDivisionError if any division by zero occurs\n    \"\"\"\n    if not isinstance(a, list) or not isinstance(b, list):\n        raise TypeError(\"Both inputs must be lists.\")\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length.\")\n    result = []\n    for i, (x, y) in enumerate(zip(a, b)):\n        if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n            raise TypeError(f\"Non-numeric values at index {i}: {type(x)} and {type(y)}\")\n        if y == 0:\n            raise ZeroDivisionError(f\"Division by zero at index {i}.\")\n        result.append(x / y)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "\"\"\"\nWrite a function to remove uneven elements in the nested mixed tuple.\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)\n\"\"\"\ndef remove_uneven_elements(nested):\n    \"\"\"\n    Recursively remove odd integers from a nested structure of lists/tuples.\n    Preserves the original nesting. Empty containers resulting from removals are dropped.\n    \"\"\"\n    def _process(obj):\n        if isinstance(obj, int):\n            return obj if obj % 2 == 0 else None\n        if isinstance(obj, tuple):\n            processed = [_process(item) for item in obj]\n            processed = [p for p in processed if p is not None]\n            cleaned = []\n            for p in processed:\n                if isinstance(p, (list, tuple)) and len(p) == 0:\n                    continue\n                cleaned.append(p)\n            return tuple(cleaned)\n        if isinstance(obj, list):\n            processed = [_process(item) for item in obj]\n            processed = [p for p in processed if p is not None]\n            cleaned = []\n            for p in processed:\n                if isinstance(p, (list, tuple)) and len(p) == 0:\n                    continue\n                cleaned.append(p)\n            return cleaned\n        return obj\n\n    return _process(nested)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "\"\"\"\nWrite a python function to move all zeroes to the end of the given list.\nassert move_zero([1,0,2,0,3,4]) == [1,2,3,4,0,0]\n\"\"\"\ndef move_zeroes_to_end(nums):\n    \"\"\"\n    Move all zeros to the end of the list in-place, preserving the order of non-zero elements.\n    Returns the modified list.\n    \"\"\"\n    insert_pos = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[insert_pos] = nums[i]\n            insert_pos += 1\n    for i in range(insert_pos, len(nums)):\n        nums[i] = 0\n    return nums", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "\"\"\"\nWrite a function to sort the given list.\nassert heap_sort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\"\"\"\ndef sort_list(lst, key=None, reverse=False):\n    \"\"\"\n    Sorts the given list in-place and returns it.\n    - lst: list to sort\n    - key: optional callable to extract comparison key\n    - reverse: if True, sorts in descending order\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    lst.sort(key=key, reverse=reverse)\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "\"\"\"\nWrite a python function to find even numbers from a list of numbers.\nassert Split([1,2,3,4,5]) == [2,4]\n\"\"\"\ndef find_even_numbers(nums):\n    \"\"\"Return a list of even integers from the input list.\"\"\"\n    return [n for n in nums if isinstance(n, int) and not isinstance(n, bool) and n % 2 == 0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "\"\"\"\nWrite a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\nassert triangle_area(-1) == None\n\"\"\"\ndef largest_triangle_area_semicircle(radius):\n    \"\"\"\n    Area of the largest triangle inscribed in a semicircle of radius 'radius'.\n    The maximum area is R^2, achieved by using the diameter as the base\n    and the apex at the top of the semicircle.\n    \"\"\"\n    try:\n        R = float(radius)\n    except (TypeError, ValueError):\n        raise ValueError(\"radius must be a real number\")\n    if R <= 0:\n        return 0.0\n    return R * R", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "\"\"\"\nWrite a function to compute the n-th power of each number in a list.\nassert nth_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],2)==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\"\"\"\ndef nth_powers(nums, n):\n    \"\"\"\n    Return a list with each element of nums raised to the n-th power.\n    n must be an integer.\n    \"\"\"\n    try:\n        exp = int(n)\n    except Exception:\n        raise TypeError(\"Exponent must be an integer.\")\n    if exp != n:\n        raise TypeError(\"Exponent must be an integer.\")\n    return [x ** exp for x in nums]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "\"\"\"\nWrite a function that checks if a strings contains 'z', except at the start and end of the word.\nassert text_match_wordz_middle(\"pythonzabc.\")==True\n\"\"\"\ndef contains_z_not_at_ends(s: str) -> bool:\n    \"\"\"\n    Returns True if the string s contains the character 'z'\n    somewhere other than the first or last position.\n    \"\"\"\n    return 'z' in s[1:-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "\"\"\"\nWrite a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a tuple for each combination.\nassert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]\n\"\"\"\ndef generate_combinations_with_repetition(lst, n):\n    \"\"\"\n    Generate all combinations with repetition of elements from lst of length n.\n    Returns a list of tuples, each tuple representing one combination.\n    \"\"\"\n    # Treat duplicates in the input as the same element by using unique values\n    unique_vals = list(dict.fromkeys(lst))\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return [()]\n    result = []\n\n    def backtrack(start, path):\n        if len(path) == n:\n            result.append(tuple(path))\n            return\n        for i in range(start, len(unique_vals)):\n            path.append(unique_vals[i])\n            backtrack(i, path)  # allow repetition of the same element\n            path.pop()\n\n    backtrack(0, [])\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "\"\"\"\nWrite a function to check whether the given amount has no profit and no loss\nassert noprofit_noloss(1500,1200)==False\n\"\"\"\ndef is_break_even(cost_price, selling_price):\n    \"\"\"\n    Check if there is no profit and no loss (break-even).\n    Returns True if selling_price equals cost_price, otherwise False.\n    \"\"\"\n    return selling_price == cost_price", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "\"\"\"\nWrite a function to replace whitespaces with an underscore and vice versa in a given string.\nassert replace_spaces('Jumanji The Jungle') == 'Jumanji_The_Jungle'\n\"\"\"\ndef swap_spaces_and_underscores(s: str) -> str:\n    \"\"\"\n    Swap spaces and underscores in the input string.\n    Spaces become underscores and underscores become spaces.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "\"\"\"\nWrite a function to find the nth nonagonal number.\nassert is_nonagonal(10) == 325\n\"\"\"\ndef nth_nonagonal(n):\n    \"\"\"\n    Return the nth nonagonal (9-gonal) number.\n    N(n) = n*(7n - 5)/2\n    n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (7 * n - 5) // 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "\"\"\"\nWrite a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\nassert power_base_sum(2,100)==115\n\"\"\"\ndef sum_digits_of_power(base, power):\n    \"\"\"\n    Compute the sum of digits of (base ** power).\n    Both base and power should be integers, with power >= 0.\n    Returns the sum of digits as an integer.\n    \"\"\"\n    if not isinstance(base, int) or not isinstance(power, int):\n        raise TypeError(\"base and power must be integers\")\n    if power < 0:\n        raise ValueError(\"power must be non-negative\")\n\n    value = pow(base, power)\n    return sum(int(ch) for ch in str(abs(value)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "\"\"\"\nWrite a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\nassert sum_list([10,20,30],[15,25,35])==[25,45,65]\n\"\"\"\ndef add_vectors(a: list, b: list) -> list:\n    if len(a) != len(b):\n        raise ValueError(\"Input lists must have the same length.\")\n    return [x + y for x, y in zip(a, b)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "\"\"\"\nWrite a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nassert wind_chill(120,35)==40\n\"\"\"\ndef wind_chill_index(temperature_c, wind_speed_kmh):\n    \"\"\"\n    Calculate wind chill index (Celsius) for a given temperature and wind speed in km/h.\n    The result is rounded up to the next integer.\n    If wind speed <= 0, the wind chill is the ambient temperature.\n    \"\"\"\n    import math\n\n    t = float(temperature_c)\n    v = float(wind_speed_kmh)\n\n    if v <= 0:\n        return int(math.ceil(t))\n\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    return int(math.ceil(wci))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "\"\"\"\nThe input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\nassert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4\n\"\"\"\ndef count_matching_indices(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Input sequences must have the same length.\")\n    return sum(1 for x, y in zip(a, b) if x == y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "\"\"\"\nWrite a function to add a dictionary to the tuple. The output should be a tuple.\nassert add_dict_to_tuple((4, 5, 6), {\"MSAM\" : 1, \"is\" : 2, \"best\" : 3} ) == (4, 5, 6, {'MSAM': 1, 'is': 2, 'best': 3})\n\"\"\"\ndef add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Return a new tuple with the given dictionary appended to the end.\n    Validates inputs: tup must be a tuple, dct must be a dict.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    if not isinstance(dct, dict):\n        raise TypeError(\"dct must be a dict\")\n    return tup + (dct,)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "\"\"\"\nThe input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\nassert filter_data({'Cierra Vega': (6.2, 70), 'Alden Cantrell': (5.9, 65), 'Kierra Gentry': (6.0, 68), 'Pierre Cox': (5.8, 66)},6.0,70)=={'Cierra Vega': (6.2, 70)}\n\"\"\"\ndef filter_students_by_minimum(students, min_height, min_weight):\n    \"\"\"\n    Filter students whose height and weight are strictly greater than the given minimums.\n    - students: dict with student name as key and (height, weight) as value\n    - min_height: minimum height threshold\n    - min_weight: minimum weight threshold\n    Returns a dict with the filtered students.\n    \"\"\"\n    return {name: (height, weight) for name, (height, weight) in students.items() if height > min_height and weight > min_weight}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "\"\"\"\nWrite a function that takes as input a tuple of numbers (t_1,...,t_{N+1}) and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\nassert multiply_elements((1, 5, 7, 8, 10)) == (5, 35, 56, 80)\n\"\"\"\ndef pairwise_product(t: tuple) -> tuple:\n    \"\"\"\n    Given a tuple t of numbers (t_1, ..., t_{N+1}),\n    return a tuple of length N where each element is t_i * t_{i+1}.\n    \"\"\"\n    return tuple(a * b for a, b in zip(t, t[1:]))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "\"\"\"\nWrite a function to remove consecutive duplicates of a given list.\nassert consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4 ])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4]\n\"\"\"\ndef remove_consecutive_duplicates(lst):\n    \"\"\"\n    Return a new list with consecutive duplicates removed from the input list.\n    Consecutive duplicates are collapsed to a single occurrence.\n    \"\"\"\n    if not lst:\n        return []\n    result = [lst[0]]\n    for item in lst[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "\"\"\"\nWrite a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\nassert sample_nam(['sally', 'Dylan', 'rebecca', 'Diana', 'Joanne', 'keith'])==16\n\"\"\"\ndef sum_lengths_of_names(names):\n    total = 0\n    for n in names:\n        if isinstance(n, str) and n and n[0].islower():\n            continue\n        if isinstance(n, str):\n            total += len(n)\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "\"\"\"\nWrite a function to find the index of the first occurrence of a given number in a sorted array.\nassert find_first_occurrence([2, 5, 5, 5, 6, 6, 8, 9, 9, 9], 5) == 1\n\"\"\"\ndef first_occurrence_index(arr, target):\n    \"\"\"\n    Return the index of the first occurrence of target in a sorted array.\n    If target is not present, return -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] >= target:\n            if arr[mid] == target:\n                index = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return index", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "\"\"\"\nWrite a python function to reverse an array upto a given position.\nassert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]\n\"\"\"\ndef reverse_upto(arr, pos):\n    if arr is None:\n        return arr\n    n = len(arr)\n    if n == 0:\n        return arr\n    end = min(int(pos), n - 1)\n    if end < 0:\n        return arr\n    i, j = 0, end\n    while i < j:\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n        j -= 1\n    return arr", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "\"\"\"\nWrite a function to find the median of two sorted lists of same size.\nassert get_median([1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5) == 16.0\n\"\"\"\ndef median_of_two_sorted_lists_same_size(a, b):\n    if a is None or b is None:\n        raise ValueError(\"Inputs cannot be None\")\n    n = len(a)\n    if n != len(b):\n        raise ValueError(\"Lists must have the same length\")\n    if n == 0:\n        raise ValueError(\"Lists must be non-empty\")\n\n    low, high = 0, n\n    while low <= high:\n        i = (low + high) // 2\n        j = n - i\n\n        A_left = a[i - 1] if i > 0 else float('-inf')\n        A_right = a[i] if i < n else float('inf')\n        B_left = b[j - 1] if j > 0 else float('-inf')\n        B_right = b[j] if j < n else float('inf')\n\n        if A_left <= B_right and B_left <= A_right:\n            left_max = A_left if A_left > B_left else B_left\n            right_min = A_right if A_right < B_right else B_right\n            return (left_max + right_min) / 2.0\n        elif A_left > B_right:\n            high = i - 1\n        else:\n            low = i + 1\n\n    # Fallback: merge and compute median\n    merged = []\n    i = j = 0\n    while i < n and j < n:\n        if a[i] <= b[j]:\n            merged.append(a[i]); i += 1\n        else:\n            merged.append(b[j]); j += 1\n    while i < n:\n        merged.append(a[i]); i += 1\n    while j < n:\n        merged.append(b[j]); j += 1\n\n    return (merged[n - 1] + merged[n]) / 2.0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "\"\"\"\nWrite a function to get all lucid numbers smaller than or equal to a given integer.\nassert get_ludic(10) == [1, 2, 3, 5, 7]\n\"\"\"\ndef get_lucid_numbers(limit):\n    if limit < 0:\n        return []\n    result = set()\n    max_len = len(str(limit))\n    # Include all single-digit palindromes (0-9)\n    for d in range(0, 10):\n        if d <= limit:\n            result.add(d)\n    # Generate palindromes of length 2..max_len\n    for length in range(2, max_len + 1):\n        half_len = (length + 1) // 2\n        start = 10 ** (half_len - 1)\n        end = 10 ** half_len\n        for left in range(start, end):\n            left_str = str(left)\n            if length % 2 == 0:\n                pal = int(left_str + left_str[::-1])\n                if pal <= limit:\n                    result.add(pal)\n            else:\n                for mid in range(10):\n                    pal = int(left_str + str(mid) + left_str[::-1])\n                    if pal <= limit:\n                        result.add(pal)\n    return sorted(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "\"\"\"\nWrite a function to find the lateral surface area of a cone given radius r and the height h.\nassert lateralsurface_cone(5,12)==204.20352248333654\n\"\"\"\nimport math\n\ndef cone_lateral_surface_area(r, h):\n    return math.pi * r * math.sqrt(r * r + h * h)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "\"\"\"\nWrite a function to convert the given tuple to a key-value dictionary using adjacent elements. \nassert tuple_to_dict((1, 5, 7, 10, 13, 5)) == {1: 5, 7: 10, 13: 5}\n\"\"\"\ndef tuple_to_adjacent_dict(t: tuple) -> dict:\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key and value.\n    The input tuple must have even length: (k1, v1, k2, v2, ...)\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "\"\"\"\nWrite a function to locate the left insertion point for a specified value in sorted order. \nassert left_insertion([1,2,4,5],6)==4\n\"\"\"\ndef left_insertion_point(arr, x):\n    \"\"\"\n    Return the index where x should be inserted in arr to maintain non-decreasing order.\n    This is the left insertion point (bisect_left).\n    \"\"\"\n    lo, hi = 0, len(arr)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "\"\"\"\nWrite a function to check whether the given string is starting with a vowel or not using regex.\nassert check_str(\"annie\")\n\"\"\"\nimport re\n\ndef starts_with_vowel(s: str) -> bool:\n    \"\"\"\n    Check if the input string starts with a vowel using a regular expression.\n    Returns True if it starts with A, E, I, O, or U (case-insensitive), else False.\n    \"\"\"\n    return bool(re.match(r'^[aeiou]', s, re.IGNORECASE))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "\"\"\"\nWrite a function to rotate a given list by specified number of items to the right direction. \nassert rotate_right([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],3)==[8, 9, 10, 1, 2, 3, 4, 5, 6, 7]\n\"\"\"\nfrom typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef rotate_right(lst: List[T], k: int) -> List[T]:\n    \"\"\"\n    Rotate a list to the right by k positions and return a new list.\n    The original list remains unmodified.\n    \"\"\"\n    n = len(lst)\n    if n == 0:\n        return []\n    k %= n\n    if k == 0:\n        return lst[:]\n    return lst[-k:] + lst[:-k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "\"\"\"\nWrite a python function to check whether all the characters are same or not.\nassert all_Characters_Same(\"python\") == False\n\"\"\"\ndef are_all_chars_same(s: str) -> bool:\n    return len(set(s)) <= 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "\"\"\"\nWrite a python function to find the sum of xor of all pairs of numbers in the given list.\nassert pair_xor_Sum([5,9,7,6],4) == 47\n\"\"\"\ndef sum_pairwise_xor(nums):\n    \"\"\"\n    Compute sum_{i<j} (nums[i] ^ nums[j]).\n    Assumes non-negative integers.\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return 0\n    max_bit = max((x.bit_length() for x in nums), default=0)\n    total = 0\n    for b in range(max_bit + 1):\n        c1 = sum((x >> b) & 1 for x in nums)\n        total += c1 * (n - c1) * (1 << b)\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "\"\"\"\nWrite a python function to find sum of products of all possible sublists of a given list. \nassert sum_Of_Subarray_Prod([1,2,3]) == 20\n\"\"\"\ndef sum_of_subarray_products(arr: list) -> int:\n    \"\"\"\n    Returns the sum of products of all contiguous subarrays of the input list `arr`.\n    \"\"\"\n    total = 0\n    end = 0  # sum of products of subarrays ending at the current position\n    for x in arr:\n        end = x * (end + 1)\n        total += end\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "\"\"\"\nWrite a function to find the size of the largest subset of a list of numbers so that every pair is divisible.\nassert largest_subset([ 1, 3, 6, 13, 17, 18 ]) == 4\n\"\"\"\ndef largest_divisible_subset_size(nums):\n    \"\"\"\n    Returns the size of the largest subset of nums such that for every pair (a, b)\n    in the subset, either a divides b or b divides a (i.e., a % b == 0 or b % a == 0).\n    Uses a dynamic programming approach after sorting (Largest Divisible Subset).\n    At most one zero can be included, since 0 divides only 0 and 0%0 is undefined.\n    \"\"\"\n    if not nums:\n        return 0\n    nums = sorted(nums)\n    n = len(nums)\n    dp = [1] * n\n    max_len = 1\n    for i in range(n):\n        for j in range(i):\n            if nums[j] != 0 and nums[i] % nums[j] == 0:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n        if dp[i] > max_len:\n            max_len = dp[i]\n    return max_len", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "\"\"\"\nWrite a function to replace all occurrences of spaces, commas, or dots with a colon.\nassert replace_specialchar('Python language, Programming language.')==('Python:language::Programming:language:')\n\"\"\"\ndef replace_with_colon(text: str) -> str:\n    \"\"\"Replace spaces, commas, and dots with a colon.\"\"\"\n    return text.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "\"\"\"\nWrite a function to extract all the adjacent coordinates of the given coordinate tuple.\nassert get_coordinates((3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]]\n\"\"\"\ndef adjacent_coords(coord, diagonals=False):\n    \"\"\"\n    Return adjacent coordinates for a 2D point.\n    By default returns 4-neighborhood (up, down, left, right).\n    If diagonals is True, include diagonal neighbors.\n    \"\"\"\n    x, y = coord\n    if diagonals:\n        deltas = [(-1, 0), (1, 0), (0, -1), (0, 1),\n                  (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    else:\n        deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    return [(x + dx, y + dy) for dx, dy in deltas]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "\"\"\"\nWrite a function to add the given tuple to the given list.\nassert add_tuple([5, 6, 7], (9, 10)) == [5, 6, 7, 9, 10]\n\"\"\"\ndef add_tuple_to_list(lst, tup):\n    lst.append(tup)\n    return lst", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "\"\"\"\nWrite a function to extract values between quotation marks \" \" of the given string.\nassert extract_quotation('Cortex \"A53\" Based \"multi\" tasking \"Processor\"') == ['A53', 'multi', 'Processor']\n\"\"\"\ndef extract_values_between_quotes(s):\n    \"\"\"\n    Extract substrings between double quotes in the input string, handling escaped quotes.\n    Returns a list of substrings (without surrounding quotes).\n    \"\"\"\n    results = []\n    current = []\n    in_quotes = False\n    escaping = False\n\n    for ch in s:\n        if escaping:\n            current.append(ch)\n            escaping = False\n        elif ch == '\\\\':\n            if in_quotes:\n                escaping = True\n            else:\n                # Backslash outside quotes has no effect\n                pass\n        elif ch == '\"':\n            if in_quotes:\n                results.append(''.join(current))\n                current = []\n                in_quotes = False\n            else:\n                in_quotes = True\n        else:\n            if in_quotes:\n                current.append(ch)\n\n    return results", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "\"\"\"\nWrite a function to check if the given tuple has any none value or not.\nassert check_none((10, 4, 5, 6, None)) == True\n\"\"\"\ndef has_none_in_tuple(t: tuple) -> bool:\n    \"\"\"\n    Check whether the given tuple (and nested tuples inside it) contains a None value.\n    Returns True if at least one element is None, otherwise False.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    for item in t:\n        if item is None:\n            return True\n        if isinstance(item, tuple):\n            if has_none_in_tuple(item):\n                return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "\"\"\"\nWrite a python function to toggle bits of the number except the first and the last bit. \nassert toggle_middle_bits(9) == 15\n\"\"\"\ndef toggle_bits_except_first_last(n: int) -> int:\n    \"\"\"\n    Toggle all bits of n except the most significant (first) and least significant (last) bits.\n    If n has less than 3 bits (bit length <= 2), the number remains unchanged.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    bl = n.bit_length()\n    if bl <= 2:\n        return n\n    mask = ((1 << (bl - 2)) - 1) << 1\n    return n ^ mask", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "\"\"\"\nWrite a function to check if the given array represents min heap or not. \nassert check_min_heap([1, 2, 3, 4, 5, 6]) == True\n\"\"\"\ndef is_min_heap(arr):\n    \"\"\"\n    Check if the given list represents a min-heap (0-indexed array representation).\n    Returns True if every node is <= its children.\n    \"\"\"\n    n = len(arr)\n    for i in range(n // 2):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "\"\"\"\nWe say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\nassert extract_index_list([1, 1, 3, 4, 5, 6, 7],[0, 1, 2, 3, 4, 5, 7],[0, 1, 2, 3, 4, 5, 7])==[1, 7]\n\"\"\"\ndef common_by_index(l1, l2, l3):\n    n = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(n) if l1[i] == l2[i] == l3[i]]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "\"\"\"\nWrite a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. \nassert divisible_by_digits(1,22)==[1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n\"\"\"\ndef find_self_dividing_numbers(startnum, endnum):\n    lo, hi = (startnum, endnum)\n    if lo > hi:\n        lo, hi = hi, lo\n    result = []\n    for n in range(lo, hi + 1):\n        m = abs(n)\n        if m == 0:\n            continue\n        s = str(m)\n        if '0' in s:\n            continue\n        if all(m % int(ch) == 0 for ch in s):\n            result.append(n)\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "\"\"\"\nGiven a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nassert maxAverageOfPath([[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2\n\"\"\"\ndef max_average_path(grid):\n    if not grid or not grid[0]:\n        return 0.0, []\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n                parent[i][j] = (i, j - 1)\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                parent[i][j] = (i - 1, j)\n            else:\n                if dp[i - 1][j] >= dp[i][j - 1]:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                    parent[i][j] = (i - 1, j)\n                else:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                    parent[i][j] = (i, j - 1)\n\n    max_sum = dp[rows - 1][cols - 1]\n    path = []\n    i, j = rows - 1, cols - 1\n    while True:\n        path.append((i, j))\n        if i == 0 and j == 0:\n            break\n        pi, pj = parent[i][j]\n        i, j = pi, pj\n    path.reverse()\n\n    length = rows + cols - 1\n    average = max_sum / length\n    return average, path", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "\"\"\"\nWrite a function to count the pairs of reverse strings in the given string list. \nassert count_reverse_pairs([\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"])== 2\n\"\"\"\nfrom collections import Counter\n\ndef count_reverse_pairs(strings):\n    \"\"\"\n    Count pairs of strings where one is the reverse of the other.\n    Palindromic strings contribute C(n, 2) pairs for their occurrences.\n    \"\"\"\n    freq = Counter(strings)\n    count = 0\n    for s in freq:\n        rev = s[::-1]\n        if rev in freq:\n            if s == rev:\n                n = freq[s]\n                count += n * (n - 1) // 2\n            elif s < rev:\n                count += freq[s] * freq[rev]\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "\"\"\"\nWrite a function to sort a given list of strings of numbers numerically. \nassert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200]\n\"\"\"\nfrom typing import List\n\ndef sort_numeric_strings(nums: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of numeric strings by their numeric value in ascending order.\n    \"\"\"\n    return sorted(nums, key=lambda s: int(s))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["4", "12", "45", "7", "0", "100", "200", "-12", "-500"]]], "plus_fail_tests": [[["10000000000", "99999999", "88888888", "7777777", "666666", "-55555", "-4444", "-333", "222", "111", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "\"\"\"\nWrite a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\nassert check_monthnumber_number(6)==True\n\"\"\"\ndef has_30_days(month):\n    \"\"\"\n    Returns True if the given month (1-12) has 30 days, otherwise False.\n    Months with 30 days: April(4), June(6), September(9), November(11)\n    \"\"\"\n    return month in (4, 6, 9, 11)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "\"\"\"\nWrite a python function to count number of digits in a given string.\nassert number_ctr('program2bedone') == 1\n\"\"\"\ndef count_digits(s: str) -> int:\n    \"\"\"\n    Return the number of digit characters (0-9) in the input string.\n    \"\"\"\n    return sum(1 for ch in s if '0' <= ch <= '9')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "\"\"\"\nWrite a function to caluclate the area of a tetrahedron.\nassert area_tetrahedron(3)==15.588457268119894\n\"\"\"\ndef tetrahedron_surface_area(vertices):\n    \"\"\"\n    Compute the total surface area of a tetrahedron given its four 3D vertices.\n    vertices: iterable of four points, each a sequence of 3 numbers (x, y, z).\n    Returns a float representing the surface area.\n    \"\"\"\n    verts = list(vertices)\n    if len(verts) != 4:\n        raise ValueError(\"Exactly four vertices are required.\")\n    pts = []\n    for p in verts:\n        if len(p) != 3:\n            raise ValueError(\"Each vertex must be a 3D point with 3 coordinates.\")\n        pts.append(tuple(float(coord) for coord in p))\n\n    def vec(a, b):\n        return (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n\n    def cross(u, v):\n        return (u[1]*v[2]-u[2]*v[1],\n                u[2]*v[0]-u[0]*v[2],\n                u[0]*v[1]-u[1]*v[0])\n\n    def norm(u):\n        return (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n\n    def tri_area(a, b, c):\n        ab = vec(a, b)\n        ac = vec(a, c)\n        return norm(cross(ab, ac)) * 0.5\n\n    a, b, c, d = pts\n    area = tri_area(a, b, c) + tri_area(a, b, d) + tri_area(a, c, d) + tri_area(b, c, d)\n    return area", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "\"\"\"\nWrite a function to find minimum k records from tuple list.  - in this case a verbatim copy of test cases\nassert min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2) == [('Akash', 2), ('Akshat', 4)]\n\"\"\"\ndef min_k_records(tuple_list, k):\n    \"\"\"\n    Return the k smallest tuples from tuple_list using lexicographic order.\n    If k <= 0, return an empty list.\n    If k >= len(tuple_list), return the entire list sorted.\n    \"\"\"\n    if k <= 0:\n        return []\n    import heapq\n    return heapq.nsmallest(k, tuple_list)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "\"\"\"\nWrite a function to return a list of all pairs of consecutive items in a given list.\nassert pair_wise([1,1,2,3,3,4,4,5])==[(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]\n\"\"\"\nfrom typing import List, Tuple, Any\n\ndef consecutive_pairs(items: List[Any]) -> List[Tuple[Any, Any]]:\n    return [(items[i], items[i + 1]) for i in range(len(items) - 1)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "\"\"\"\nWrite a python function to check whether a list of numbers contains only one distinct element or not.\nassert unique_Element([1,1,1]) == True\n\"\"\"\ndef has_only_one_distinct_element(nums):\n    return len(set(nums)) == 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "\"\"\"\nWrite a python function to find the minimum difference between any two elements in a given array. \nassert find_min_diff((1,5,3,19,18,25),6) == 1\n\"\"\"\ndef minimum_difference(arr):\n    \"\"\"\n    Returns the minimum absolute difference between any two elements in arr.\n    If fewer than 2 elements, raises ValueError.\n    \"\"\"\n    if arr is None:\n        raise ValueError(\"Input array must not be None\")\n    n = len(arr)\n    if n < 2:\n        raise ValueError(\"At least two elements are required to compute a difference.\")\n    a = sorted(arr)\n    min_diff = a[1] - a[0]\n    if min_diff == 0:\n        return 0\n    for i in range(1, n - 1):\n        diff = a[i + 1] - a[i]\n        if diff < min_diff:\n            min_diff = diff\n            if min_diff == 0:\n                break\n    return min_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "\"\"\"\nWrite a function to find the nth jacobsthal number.  0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nassert jacobsthal_num(5) == 11\n\"\"\"\ndef jacobsthal(n):\n    \"\"\"\n    Return the nth Jacobsthal number.\n    J(0) = 0, J(1) = 1, J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    Uses closed-form: J(n) = (2^n - (-1)^n) / 3\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return ((1 << n) - ((-1) ** n)) // 3", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "\"\"\"\nWrite a function to check if the given expression is balanced or not. \nassert check_expression(\"{()}[{}]\") == True\n\"\"\"\ndef is_balanced(expression: str) -> bool:\n    if not expression:\n        return True\n\n    stack = []\n    opening = {'(', '[', '{'}\n    matching = {')': '(', ']': '[', '}': '{'}\n\n    for ch in expression:\n        if ch in opening:\n            stack.append(ch)\n        elif ch in matching:\n            if not stack or stack[-1] != matching[ch]:\n                return False\n            stack.pop()\n\n    return not stack", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "\"\"\"\nWrite a python function to check whether every odd index contains odd numbers of a given list.\nassert odd_position([2,1,4,3,6,7,6,3]) == True\n\"\"\"\ndef all_odd_indices_are_odd(nums):\n    \"\"\"\n    Return True if every element at odd indices (1, 3, 5, ...) in nums is odd.\n    \"\"\"\n    return all(isinstance(x, int) and x % 2 != 0 for x in (nums[i] for i in range(1, len(nums), 2)))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "\"\"\"\nWrite a function to put spaces between words starting with capital letters in a given string.\nassert capital_words_spaces(\"Python\") == 'Python'\n\"\"\"\ndef split_camel_case(s: str) -> str:\n    \"\"\"\n    Insert spaces before words that start with a capital letter in a camel-cased string.\n    Example: \"ThisIsATest\" -> \"This Is A Test\"\n    Avoids inserting extra spaces if words are already separated by spaces.\n    \"\"\"\n    import re\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    # Insert a space before a capital letter that starts a new word, but only if not at the start\n    # and not already preceded by whitespace\n    pattern = r'(?<!^)(?<!\\s)(?=[A-Z][a-z])'\n    return re.sub(pattern, ' ', s)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"\nfrom typing import Iterable, List, TypeVar\n\nT = TypeVar('T')\n\ndef list_difference(a: List[T], b: Iterable[T]) -> List[T]:\n    \"\"\"\n    Return elements in list a that are not in list b.\n    Preserves the order of a and keeps duplicates from a.\n    If elements in b are unhashable, falls back to a linear search.\n    \"\"\"\n    try:\n        b_set = set(b)\n        return [x for x in a if x not in b_set]\n    except TypeError:\n        b_list = list(b)\n        return [x for x in a if x not in b_list]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "\"\"\"\nWrite a function to check whether a given string is a decimal number with a precision of 2.\nassert is_decimal('123.11')==True\n\"\"\"\ndef is_decimal_with_precision_two(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    s = s.strip()\n    if not s:\n        return False\n    import re\n    return bool(re.fullmatch(r'[+-]?\\d+\\.\\d{2}', s))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "\"\"\"\nWrite a function to find the second smallest number in a list.\nassert second_smallest([1, 2, -8, -2, 0, -2])==-2\n\"\"\"\ndef second_smallest(nums):\n    \"\"\"\n    Return the second smallest distinct number from the input list.\n    Raises ValueError if there are fewer than two distinct numbers.\n    \"\"\"\n    if nums is None:\n        raise ValueError(\"Input must be a non-empty list of numbers\")\n\n    min1 = None\n    min2 = None\n\n    for x in nums:\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be numbers\")\n\n        if min1 is None or x < min1:\n            min2 = min1\n            min1 = x\n        elif x != min1 and (min2 is None or x < min2):\n            min2 = x\n\n    if min2 is None:\n        raise ValueError(\"List must contain at least two distinct numbers\")\n\n    return min2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 2]]], "plus_fail_tests": [[[]]]}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "\"\"\"\nWrite a python function to find the sum of non-repeated elements in a given list.\nassert find_sum([1,2,3,1,1,4,5,6]) == 21\n\"\"\"\ndef sum_of_non_repeated_elements(lst):\n    \"\"\"\n    Return the sum of elements that appear exactly once in the input list.\n    Assumes elements are hashable.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return sum(x for x, c in counts.items() if c == 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "\"\"\"\nWrite a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\nassert get_pairs_count([1,1,1,1],2) == 6\n\"\"\"\ndef count_pairs_with_sum(nums, target):\n    counts = {}\n    total = 0\n    for x in nums:\n        total += counts.get(target - x, 0)\n        counts[x] = counts.get(x, 0) + 1\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "\"\"\"\nWrite a function that matches a string that has an a followed by three 'b'.\nassert not text_match_three(\"ac\")\n\"\"\"\ndef matches_a_followed_by_three_b(s: str) -> bool:\n    return 'abbb' in s", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "\"\"\"\nWrite a function to locate the right insertion point for a specified value in sorted order.\nassert right_insertion([1,2,4,5],6)==4\n\"\"\"\ndef find_right_insertion_point(sorted_list, value):\n    \"\"\"\n    Return the index where 'value' should be inserted to maintain non-decreasing order.\n    This is equivalent to the right-side insertion point (like bisect_right).\n    \"\"\"\n    left, right = 0, len(sorted_list)\n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] <= value:\n            left = mid + 1\n        else:\n            right = mid\n    return left", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "\"\"\"\nWrite a python function to check whether every even index contains even numbers of a given list.\nassert even_position([3,2,1]) == False\n\"\"\"\ndef are_even_indices_even(lst):\n    return all(isinstance(lst[i], int) and lst[i] % 2 == 0 for i in range(0, len(lst), 2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "\"\"\"\nWrite a function to pack consecutive duplicates of a given list elements into sublists.\nassert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]]\n\"\"\"\ndef pack(iterable):\n    \"\"\"\n    Pack consecutive duplicates of the elements of 'iterable' into sublists.\n    Example: pack([1,1,2,3,3,3]) -> [[1, 1], [2], [3, 3, 3]]\n    \"\"\"\n    from itertools import groupby\n    return [list(group) for _, group in groupby(iterable)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "\"\"\"\nWrite a function to find the combinations of sums with tuples in the given tuple list. \nassert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)]\n\"\"\"\ndef sums_by_combination(tuple_list):\n    \"\"\"\n    Return all possible sums by selecting one element from each tuple/list in tuple_list.\n    Example: [(1,2), (3,4)] -> [4, 5, 5, 6]\n    \"\"\"\n    if not tuple_list:\n        return []\n    for t in tuple_list:\n        if not isinstance(t, (tuple, list)):\n            raise TypeError(\"All elements must be tuples or lists.\")\n        if len(t) == 0:\n            return []\n    from itertools import product\n    return [sum(comb) for comb in product(*tuple_list)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "\"\"\"\nWrite a python function to check whether the count of divisors is even. \nassert count_divisors(10)\n\"\"\"\nimport math\n\ndef is_divisor_count_even(n: int) -> bool:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    r = math.isqrt(n)\n    return r * r != n", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "\"\"\"\nWrite a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\nassert occurance_substring('python programming, python language','python')==('python', 0, 6)\n\"\"\"\ndef find_substring_occurrences(text, substrings):\n    \"\"\"\n    Find all overlapping occurrences of substrings within text.\n    Returns a dict mapping each substring to a list of starting indices where it occurs.\n    If none of the substrings occur, returns None.\n    \"\"\"\n    if text is None:\n        return None\n    if isinstance(substrings, str):\n        substrings = [substrings]\n    try:\n        iter(substrings)\n    except TypeError:\n        return None\n    results = {}\n    seen = set()\n    text_str = str(text)\n    for sub in substrings:\n        if not isinstance(sub, str) or sub == \"\":\n            continue\n        if sub in seen:\n            continue\n        seen.add(sub)\n        positions = []\n        start = 0\n        while True:\n            idx = text_str.find(sub, start)\n            if idx == -1:\n                break\n            positions.append(idx)\n            start = idx + 1  # allow overlapping occurrences\n        if positions:\n            results[sub] = positions\n    return results if results else None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "\"\"\"\nWrite a function to find the product of first even and odd number of a given list.\nassert mul_even_odd([1,3,5,7,4,1,6,8])==4\n\"\"\"\ndef product_of_first_even_and_odd(nums):\n    \"\"\"\n    Returns the product of the first even and first odd integers found in the list `nums`.\n    Non-integer elements are ignored. If the list does not contain at least one even and one odd integer,\n    a ValueError is raised.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    for x in nums:\n        if isinstance(x, bool):\n            continue  # Ignore booleans\n        if isinstance(x, int):\n            if first_even is None and x % 2 == 0:\n                first_even = x\n            elif first_odd is None and x % 2 != 0:\n                first_odd = x\n            if first_even is not None and first_odd is not None:\n                break\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd integer.\")\n    return first_even * first_odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "\"\"\"\nWrite a function to remove tuples from the given tuple.\nassert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)\n\"\"\"\ndef remove_tuples_from_tuple(t: tuple) -> tuple:\n    \"\"\"\n    Return a new tuple containing only non-tuple elements from the input tuple.\n    Top-level elements that are tuples are removed.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return tuple(item for item in t if not isinstance(item, tuple))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "\"\"\"\nWrite a python function to find the last position of an element in a sorted array.\nassert last([1,2,3],1) == 0\n\"\"\"\ndef last_position(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            if arr[mid] == target:\n                result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "\"\"\"\nWrite a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] )=={(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n\"\"\"\ndef count_lists_in_list(lst):\n    \"\"\"\n    Recursively count all lists found in lst (including lst itself).\n    Each list is converted to a tuple (with nested lists converted similarly),\n    and the dictionary maps that tuple to the number of times that list content occurs\n    in the input structure.\n    \"\"\"\n    from collections import defaultdict\n\n    def freeze(item):\n        if isinstance(item, list):\n            return tuple(freeze(e) for e in item)\n        return item\n\n    counts = defaultdict(int)\n\n    def dfs(x):\n        if not isinstance(x, list):\n            return\n        frozen = freeze(x)\n        counts[frozen] += 1\n        for y in x:\n            if isinstance(y, list):\n                dfs(y)\n\n    if isinstance(lst, list):\n        dfs(lst)\n\n    return dict(counts)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "\"\"\"\nWrite a python function to count the number of lists in a given number of lists.\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4\n\"\"\"\ndef count_lists_in_list(lst):\n    \"\"\"\n    Count how many elements of the input list are themselves lists.\n\n    Parameters:\n        lst (list): A list containing elements, some of which may be lists.\n\n    Returns:\n        int: The number of elements that are lists.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    return sum(1 for item in lst if isinstance(item, list))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "\"\"\"\nWrite a function to remove all the words with k length in the given string.\nassert remove_length('The person is most value tet', 3) == 'person is most value'\n\"\"\"\ndef remove_words_with_k_length(text, k):\n    \"\"\"\n    Remove all words of length k from the input string.\n    A word is defined as a sequence of non-whitespace characters separated by whitespace.\n    The function returns a new string with remaining words joined by a single space.\n    \"\"\"\n    if k <= 0:\n        return text\n    words = text.split()\n    return ' '.join(w for w in words if len(w) != k)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "\"\"\"\nWrite a python function to find the sum of an array.\nassert _sum([1, 2, 3]) == 6\n\"\"\"\ndef sum_array(arr):\n    \"\"\"Return the sum of numeric values in the given array-like iterable.\"\"\"\n    total = 0\n    for x in arr:\n        total += x\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "\"\"\"\nWrite a python function to find the sum of all odd natural numbers within the range l and r.\nassert sum_in_range(2,5) == 8\n\"\"\"\ndef sum_odd_naturals_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Return sum of all odd natural numbers in the inclusive range [l, r].\n    If the range contains no natural odd numbers, returns 0.\n    \"\"\"\n    if l > r:\n        return 0\n    L = max(l, 1)\n    if L > r:\n        return 0\n    sum_up_to_r = ((r + 1) // 2) ** 2\n    sum_up_to_before_L = (L // 2) ** 2\n    return sum_up_to_r - sum_up_to_before_L", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "\"\"\"\nWrite a python function to count the number of equal numbers from three given integers.\nassert test_three_equal(1,1,1) == 3\n\"\"\"\ndef count_equal_numbers(a: int, b: int, c: int) -> int:\n    if a == b == c:\n        return 3\n    if a == b or b == c or a == c:\n        return 2\n    return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "\"\"\"\nWrite a function to check whether the product of numbers in a list is even or not.\nassert is_product_even([1,2,3])\n\"\"\"\ndef is_product_even(nums):\n    \"\"\"\n    Return True if the product of the numbers in 'nums' is even, otherwise False.\n    If the list is empty, returns False (the product of an empty set is 1, which is odd).\n    \"\"\"\n    if not nums:\n        return False\n    for n in nums:\n        if n % 2 == 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "\"\"\"\nWrite function to find the sum of all items in the given dictionary.\nassert return_sum({'a': 100, 'b':200, 'c':300}) == 600\n\"\"\"\ndef sum_dict_items(d):\n    \"\"\"\n    Recursively sums all numeric values contained in the dictionary 'd'.\n    Numeric values can be int or float. If nested dictionaries or sequences\n    (list, tuple, set) are encountered, their numeric contents are included.\n    Non-numeric values are ignored.\n    \"\"\"\n    total = 0\n    if isinstance(d, dict):\n        for v in d.values():\n            total += sum_dict_items(v)\n    elif isinstance(d, (list, tuple, set)):\n        for item in d:\n            total += sum_dict_items(item)\n    elif isinstance(d, (int, float)):\n        total += d\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "\"\"\"\nWrite a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\nassert left_rotate(16,2) == 64\n\"\"\"\ndef rotl32(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left a 32-bit unsigned integer n by d bits.\n    Returns a value in the range [0, 0xFFFFFFFF].\n    \"\"\"\n    n &= 0xFFFFFFFF\n    d %= 32\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "\"\"\"\nWrite a function to find maximum run of uppercase characters in the given string.\nassert max_run_uppercase('GeMKSForGERksISBESt') == 5\n\"\"\"\ndef max_upper_run(s: str) -> int:\n    \"\"\"\n    Returns the length of the longest consecutive run of uppercase characters in the string s.\n    Non-uppercase characters break the run.\n    \"\"\"\n    max_run = 0\n    current = 0\n    for ch in s:\n        if ch.isupper():\n            current += 1\n            if current > max_run:\n                max_run = current\n        else:\n            current = 0\n    return max_run", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "\"\"\"\nWrite a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\nassert check_smaller((1, 2, 3), (2, 3, 4)) == False\n\"\"\"\ndef are_elements_of_second_smaller(first: tuple, second: tuple) -> bool:\n    if len(first) != len(second):\n        raise ValueError(\"Both tuples must have the same length.\")\n    return all(s < f for f, s in zip(first, second))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "\"\"\"\nWrite a function to remove all whitespaces from a string.\nassert remove_all_spaces('python  program')==('pythonprogram')\n\"\"\"\ndef remove_whitespace(s: str) -> str:\n    \"\"\"Remove all whitespace characters from the input string.\"\"\"\n    return ''.join(ch for ch in s if not ch.isspace())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "\"\"\"\nWrite a function to create a new tuple from the given string and list.\nassert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')\n\"\"\"\ndef create_tuple_from_string_and_list(string: str, lst: list) -> tuple:\n    return (string, lst)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "\"\"\"\nWrite a function to check whether the given number is a perfect square or not. \nassert not is_perfect_square(10)\n\"\"\"\ndef is_perfect_square(n):\n    \"\"\"\n    Check if a non-negative integer n is a perfect square.\n    Returns True if n is a perfect square, otherwise False.\n    \"\"\"\n    if n < 0:\n        return False\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == n:\n            return True\n        elif sq < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "\"\"\"\nWrite a python function to find the sum of fourth power of first n odd natural numbers.\nassert odd_num_sum(2) == 82\n\"\"\"\ndef sum_fourth_powers_of_first_n_odds(n: int) -> int:\n    \"\"\"\n    Return the sum of the fourth powers of the first n odd natural numbers.\n    For non-positive n, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    nn = int(n)\n    term1 = (8 * nn * (nn + 1) * (2 * nn + 1) * (3 * nn * nn + 3 * nn - 1)) // 15\n    term2 = 8 * nn * nn * (nn + 1) * (nn + 1)\n    term3 = 4 * nn * (nn + 1) * (2 * nn + 1)\n    term4 = 4 * nn * (nn + 1)\n    return term1 - term2 + term3 - term4 + nn", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "\"\"\"\nWrite a function that returns the list in a list of lists whose sum of elements is the highest.\nassert max_sum_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[10, 11, 12]\n\"\"\"\ndef max_sum_sublist(list_of_lists):\n    \"\"\"\n    Returns the sublist with the maximum sum of its elements.\n    If multiple sublists have the same maximum sum, the first encountered is returned.\n    If input is empty or contains no valid sublists, returns [].\n    \"\"\"\n    if not list_of_lists:\n        return []\n    best_sub = []\n    best_sum = None\n    for sub in list_of_lists:\n        try:\n            s = sum(sub)\n        except TypeError:\n            # skip invalid sublists\n            continue\n        if best_sum is None or s > best_sum:\n            best_sum = s\n            best_sub = list(sub)\n    return best_sub", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "\"\"\"\nWrite a python function to find the first odd number in a given list of numbers.\nassert first_odd([1,3,5]) == 1\n\"\"\"\ndef first_odd_number(nums):\n    \"\"\"\n    Return the first odd integer in nums (including numbers that are floats but integral),\n    or None if no such number exists.\n    Booleans are ignored.\n    \"\"\"\n    for n in nums:\n        if isinstance(n, bool):\n            continue\n        if isinstance(n, int):\n            if n % 2 != 0:\n                return n\n        elif isinstance(n, float):\n            if n.is_integer():\n                m = int(n)\n                if m % 2 != 0:\n                    return m\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "\"\"\"\nWrite a python function to find the index of smallest triangular number with n digits. \nassert find_Index(2) == 4\n\"\"\"\ndef index_of_smallest_triangular_with_n_digits(n):\n    \"\"\"\n    Return the index k of the smallest triangular number T_k = k*(k+1)/2\n    that has exactly n digits.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    threshold = 10**(n - 1)\n    D = 1 + 8 * threshold\n    s = __import__(\"math\").isqrt(D)\n    if s * s == D:\n        k = (s - 1) // 2\n    else:\n        k = (s - 1) // 2 + 1\n    t = k * (k + 1) // 2\n\n    # Ensure t has less than 10^n digits\n    while t >= 10**n:\n        k -= 1\n        if k <= 0:\n            break\n        t = k * (k + 1) // 2\n\n    # Ensure t has at least n digits\n    while t < threshold:\n        k += 1\n        t = k * (k + 1) // 2\n\n    return k", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "\"\"\"\nWrite a function to convert tuple string to integer tuple.\nassert tuple_str_int(\"(7, 8, 9)\") == (7, 8, 9)\n\"\"\"\ndef tuple_string_to_int_tuple(s: str) -> tuple:\n    \"\"\"\n    Convert a string representation of a tuple into a tuple of integers.\n    Accepts inputs like \"(1, 2, -3)\", \"1,2,3\", \"(1, '2', 3)\", etc.\n    Returns an empty tuple for empty input.\n    Raises ValueError if any element cannot be converted to int.\n    \"\"\"\n    import ast\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    s = s.strip()\n    if not s:\n        return ()\n    if not (s.startswith(\"(\") and s.endswith(\")\")):\n        s = \"(\" + s + \")\"\n    try:\n        parsed = ast.literal_eval(s)\n    except Exception as e:\n        raise ValueError(\"Input string is not a valid tuple literal\") from e\n    if isinstance(parsed, tuple):\n        items = parsed\n    elif isinstance(parsed, list):\n        items = tuple(parsed)\n    else:\n        raise ValueError(\"Parsed value is not a tuple or list\")\n    result = []\n    for item in items:\n        try:\n            result.append(int(item))\n        except Exception as e:\n            raise ValueError(f\"Element {item!r} cannot be converted to int\") from e\n    return tuple(result)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "\"\"\"\nWrite a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nassert text_starta_endb(\"aabbbb\")\n\"\"\"\ndef matches_a_followed_by_any_ending_b(s: str) -> bool:\n    return 'a' in s and s.endswith('b')", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "\"\"\"\nWrite a function to check if the given tuples contain the k or not.\nassert check_K((10, 4, 5, 6, 8), 6) == True\n\"\"\"\ndef contains_k_in_tuples(tuples_collection, k):\n    \"\"\"\n    Check whether the given collection of tuples contains the value k.\n    - If a single tuple is provided, it checks whether k is in that tuple.\n    - If an iterable of tuples is provided, it returns True if k is in any of the inner tuples.\n    Returns True if found, otherwise False.\n    \"\"\"\n    # If a single tuple (not a collection of tuples)\n    if isinstance(tuples_collection, tuple) and not any(isinstance(x, tuple) for x in tuples_collection):\n        return k in tuples_collection\n    try:\n        for t in tuples_collection:\n            if isinstance(t, tuple):\n                if k in t:\n                    return True\n            else:\n                # Treat non-tuple elements as a scalar; match directly\n                if t == k:\n                    return True\n        return False\n    except TypeError:\n        # Not iterable\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "\"\"\"\nWrite a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\nassert is_polite(7) == 11\n\"\"\"\ndef nth_polite(n):\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    limit = max(100, n * 12)\n    while True:\n        # Sieve of Eratosthenes to find primes up to limit using a memory-efficient bytearray\n        is_prime = bytearray(b'\\x01') * (limit + 1)\n        is_prime[0] = 0\n        is_prime[1] = 0\n        m = int(limit ** 0.5)\n        for i in range(2, m + 1):\n            if is_prime[i]:\n                step = i\n                start = i * i\n                is_prime[start:limit + 1:step] = b'\\x00' * (((limit - start) // step) + 1)\n        primes = [i for i in range(2, limit + 1) if is_prime[i]]\n\n        # Mark prime powers\n        is_pp = bytearray(limit + 1)\n        for p in primes:\n            val = p\n            while val <= limit:\n                is_pp[val] = 1\n                if val > limit // p:\n                    break\n                val *= p\n\n        # Count polite numbers (numbers >= 2 that are not prime powers)\n        count = 0\n        for x in range(2, limit + 1):\n            if not is_pp[x]:\n                count += 1\n                if count == n:\n                    return x\n        limit *= 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "\"\"\"\nWrite a python function to find the sum of all odd length subarrays. \nassert odd_length_sum([1,2,4]) == 14\n\"\"\"\ndef sum_odd_length_subarrays(arr):\n    n = len(arr)\n    total = 0\n    for i, val in enumerate(arr):\n        left = i + 1\n        right = n - i\n        count = (left * right + 1) // 2\n        total += val * count\n    return total", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}]}}