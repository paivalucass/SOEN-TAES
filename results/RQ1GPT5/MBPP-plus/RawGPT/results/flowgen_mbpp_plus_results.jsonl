{"task_id": "Mbpp/17", "completion": "def square_perimeter(side_length):\n    \"\"\"\n    Return the perimeter of a square with the given side length.\n    side_length should be a non-negative number (int or float).\n    \"\"\"\n    return 4 * side_length"}
{"task_id": "Mbpp/8", "completion": "def square_elements(lst):\n    \"\"\"\n    Return a list containing the squares of each element in the input list.\n    Assumes numeric elements (int, float). For non-numeric elements, a TypeError will be raised.\n    \"\"\"\n    return [x * x for x in lst]"}
{"task_id": "Mbpp/18", "completion": "def remove_chars_from_string(s1, s2):\n    to_remove = set(s2)\n    return ''.join(ch for ch in s1 if ch not in to_remove)"}
{"task_id": "Mbpp/59", "completion": "def nth_octagonal(n: int) -> int:\n    \"\"\"\n    Return the nth octagonal number.\n    The nth octagonal number is O_n = n * (3n - 2) for n >= 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/19", "completion": "def contains_duplicate(nums):\n    return len(nums) != len(set(nums))"}
{"task_id": "Mbpp/14", "completion": "def triangular_prism_volume(base: float, height: float, length: float) -> float:\n    \"\"\"\n    Calculate the volume of a triangular prism.\n    V = (1/2) * base * height * length\n    where 'base' and 'height' define the triangular base area, and 'length' is the prism length.\n    \"\"\"\n    if any(x is None for x in (base, height, length)):\n        raise ValueError(\"base, height, and length must be provided\")\n    try:\n        b = float(base)\n        h = float(height)\n        L = float(length)\n    except (TypeError, ValueError):\n        raise ValueError(\"base, height, and length must be numeric\")\n    if b < 0 or h < 0 or L < 0:\n        raise ValueError(\"base, height, and length must be non-negative\")\n    return 0.5 * b * h * L"}
{"task_id": "Mbpp/56", "completion": "def is_one_less_than_twice_reverse(n: int) -> bool:\n    if n < 0:\n        return False\n    rev = int(str(n)[::-1])\n    return n == 2 * rev - 1"}
{"task_id": "Mbpp/2", "completion": "def find_shared_elements(list1, list2):\n    \"\"\"\n    Return the elements that appear in both input lists.\n    The result contains unique elements, preserving the order\n    of their first appearance in list1.\n    Works for hashable elements (fast). Falls back to equality-based check\n    for unhashable elements.\n    \"\"\"\n    try:\n        set2 = set(list2)\n        seen = set()\n        result = []\n        for x in list1:\n            if x in set2 and x not in seen:\n                result.append(x)\n                seen.add(x)\n        return result\n    except TypeError:\n        # Fallback for unhashable elements\n        seen = []\n        result = []\n        for x in list1:\n            if any(x == y for y in list2) and not any(x == s for s in seen):\n                result.append(x)\n                seen.append(x)\n        return result"}
{"task_id": "Mbpp/11", "completion": "def remove_first_and_last_occurrence(s: str, ch: str) -> str:\n    \"\"\"\n    Remove the first and last occurrence of the character `ch` from string `s`.\n    If `ch` does not occur in `s`, return `s` unchanged.\n    If `ch` occurs only once, remove that single occurrence.\n    \"\"\"\n    if not isinstance(s, str) or not isinstance(ch, str) or len(ch) != 1:\n        raise ValueError(\"s must be a string and ch must be a single character\")\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first + 1 :]\n    return s[:first] + s[first + 1 : last] + s[last + 1 :]"}
{"task_id": "Mbpp/62", "completion": "def find_smallest_number(numbers):\n    if numbers is None or len(numbers) == 0:\n        raise ValueError(\"The input list is empty.\")\n    min_val = numbers[0]\n    for i in range(1, len(numbers)):\n        if numbers[i] < min_val:\n            min_val = numbers[i]\n    return min_val"}
{"task_id": "Mbpp/7", "completion": "def find_words_at_least_four(text):\n    \"\"\"\n    Return a list of all sequences of consecutive alphabetic characters in 'text'\n    that have length >= 4. A word is defined as a maximal run of Unicode letters.\n    \"\"\"\n    result = []\n    current = []\n    for ch in text:\n        if ch.isalpha():\n            current.append(ch)\n        else:\n            if len(current) >= 4:\n                result.append(''.join(current))\n            current = []\n    if len(current) >= 4:\n        result.append(''.join(current))\n    return result"}
{"task_id": "Mbpp/61", "completion": "def count_substrings_with_sum_of_digits_equal_length(s: str) -> int:\n    from collections import defaultdict\n\n    freq = defaultdict(int)\n    freq[0] = 1  # prefix sum of 0 length\n    pref = 0\n    ans = 0\n\n    for ch in s:\n        d = ord(ch) - 48  # digit value\n        pref += d - 1     # sum of (digit - 1)\n        ans += freq[pref]\n        freq[pref] += 1\n\n    return ans"}
{"task_id": "Mbpp/6", "completion": "def differ_by_one_bit(a, b):\n    diff = a ^ b\n    return diff > 0 and (diff & (diff - 1)) == 0"}
{"task_id": "Mbpp/4", "completion": "import heapq\nfrom typing import List\n\ndef n_largest_integers(nums: List[int], n: int) -> List[int]:\n    \"\"\"\n    Return the n largest integers from nums in descending order.\n    If n <= 0 or nums is empty, return an empty list.\n    If n >= len(nums), return the entire list sorted in descending order.\n    \"\"\"\n    if n <= 0 or not nums:\n        return []\n    if n >= len(nums):\n        return sorted(nums, reverse=True)\n    return heapq.nlargest(n, nums)"}
{"task_id": "Mbpp/58", "completion": "def opposite_signs(a: int, b: int) -> bool:\n    \"\"\"\n    Check if two integers have opposite signs.\n    Returns True if one is positive and the other is negative.\n    Zeros are not considered to have a sign, so (0, x) or (x, 0) returns False.\n    \"\"\"\n    return a * b < 0"}
{"task_id": "Mbpp/12", "completion": "def sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sorts a matrix (list of lists) by the ascending sum of each row.\n    Returns a new matrix with rows reordered accordingly.\n    \"\"\"\n    if matrix is None:\n        raise ValueError(\"matrix cannot be None\")\n    if not isinstance(matrix, list):\n        raise TypeError(\"matrix must be a list of rows\")\n    for i, row in enumerate(matrix):\n        if not isinstance(row, list):\n            raise TypeError(\"matrix must be a list of lists (rows)\")\n        if not all(isinstance(x, (int, float)) for x in row):\n            raise TypeError(\"all row elements must be numeric (int or float)\")\n    sorted_rows = sorted(matrix, key=lambda r: sum(r))\n    return [row[:] for row in sorted_rows]"}
{"task_id": "Mbpp/20", "completion": "def is_woodball(n: int) -> bool:\n    \"\"\"\n    Check if n is a Woodall number: n = k * 2^k - 1 for some integer k >= 1.\n    Returns True if such k exists, otherwise False.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        return False\n    t = n + 1\n    k = 1\n    while True:\n        val = k * (1 << k)\n        if val == t:\n            return True\n        if val > t:\n            return False\n        k += 1"}
{"task_id": "Mbpp/57", "completion": "def largest_number_from_digits(digits):\n    \"\"\"\n    Return the largest integer that can be formed by permuting the given digits (0-9).\n    If digits is empty, return 0.\n    \"\"\"\n    if digits is None:\n        raise ValueError(\"digits must not be None\")\n    if not isinstance(digits, (list, tuple)):\n        raise TypeError(\"digits must be a list or tuple of integers 0-9\")\n    if len(digits) == 0:\n        return 0\n    for d in digits:\n        if not isinstance(d, int) or d < 0 or d > 9:\n            raise ValueError(\"all elements must be integers in the range 0-9\")\n    sorted_digits = sorted(digits, reverse=True)\n    result = ''.join(str(d) for d in sorted_digits)\n    return int(result)"}
{"task_id": "Mbpp/79", "completion": "def is_word_length_odd(word: str) -> bool:\n    \"\"\"\n    Return True if the length of the input word is odd, otherwise False.\n    \"\"\"\n    return len(word) % 2 == 1"}
{"task_id": "Mbpp/63", "completion": "def max_pair_difference(pairs):\n    \"\"\"\n    Return the maximum absolute difference between the two elements of any 2-element tuple\n    in the input list 'pairs'. If the list is empty, return 0.\n    \"\"\"\n    if not pairs:\n        return 0\n\n    max_diff = 0\n    for t in pairs:\n        if not isinstance(t, tuple) or len(t) != 2:\n            raise ValueError(\"Each item must be a 2-element tuple.\")\n        a, b = t\n        diff = abs(a - b)\n        if diff > max_diff:\n            max_diff = diff\n\n    return max_diff"}
{"task_id": "Mbpp/68", "completion": "def is_monotonic(arr):\n    return all(arr[i] >= arr[i - 1] for i in range(1, len(arr))) or all(arr[i] <= arr[i - 1] for i in range(1, len(arr)))"}
{"task_id": "Mbpp/69", "completion": "def contains_sublist(lst, sublst):\n    \"\"\"\n    Return True if sublst appears as a contiguous subsequence of lst.\n    An empty sublst is considered to be contained in any list.\n    \"\"\"\n    if not isinstance(lst, list) or not isinstance(sublst, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if not sublst:\n        return True\n    if len(sublst) > len(lst):\n        return False\n\n    sub_len = len(sublst)\n    for i in range(len(lst) - sub_len + 1):\n        if lst[i:i + sub_len] == sublst:\n            return True\n    return False"}
{"task_id": "Mbpp/3", "completion": "def identify_non_primes(numbers):\n    \"\"\"\n    Given an iterable of integers, return a list of non-prime numbers\n    among them. Non-prime includes numbers < 2 (e.g., 0, 1) and composite numbers.\n    The input order is preserved.\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        if n % 2 == 0:\n            return n == 2\n        if n % 3 == 0:\n            return n == 3\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    out = []\n    for x in numbers:\n        if not isinstance(x, int):\n            raise TypeError(\"All elements must be integers.\")\n        if not is_prime(x):\n            out.append(x)\n    return out"}
{"task_id": "Mbpp/70", "completion": "def all_tuples_equal_length(tuples):\n    \"\"\"\n    Return True if all tuples in the iterable have the same length.\n    Empty iterable or a single tuple is considered to have equal lengths.\n    Raises TypeError if any element in the iterable is not a tuple.\n    \"\"\"\n    lengths = set()\n    for item in tuples:\n        if not isinstance(item, tuple):\n            raise TypeError(\"All elements must be tuples\")\n        lengths.add(len(item))\n        if len(lengths) > 1:\n            return False\n    return True"}
{"task_id": "Mbpp/66", "completion": "def count_positive_numbers(nums):\n    count = 0\n    for x in nums:\n        try:\n            if x > 0:\n                count += 1\n        except TypeError:\n            pass\n    return count"}
{"task_id": "Mbpp/64", "completion": "def sort_by_second(tuples_list, reverse=False):\n    \"\"\"\n    Return a new list of tuples sorted by their second element (index 1).\n    Tuples without a second element are placed after those that have one.\n    \"\"\"\n    return sorted(tuples_list, key=lambda t: (0, t[1]) if len(t) > 1 else (1, None), reverse=reverse)"}
{"task_id": "Mbpp/85", "completion": "import math\n\ndef surface_area_of_sphere(radius: float) -> float:\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n    Surface area = 4 * pi * r^2\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 4 * math.pi * (radius ** 2)"}
{"task_id": "Mbpp/80", "completion": "def tetrahedral_number(n: int) -> int:\n    \"\"\"\n    Return the nth tetrahedral number T_n = n*(n+1)*(n+2)/6.\n    n must be a non-negative integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": "Mbpp/16", "completion": "def contains_lowercase_sequences_joined_with_underscore(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    parts = s.split('_')\n    if len(parts) < 2:\n        return False\n    for part in parts:\n        if not part or not all('a' <= ch <= 'z' for ch in part):\n            return False\n    return True"}
{"task_id": "Mbpp/88", "completion": "def frequency_dict(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq"}
{"task_id": "Mbpp/72", "completion": "def can_be_difference_of_squares(n):\n    \"\"\"\n    Check if integer n can be represented as x^2 - y^2 for some integers x, y.\n    A number can be represented as a difference of two squares iff n is not congruent to 2 modulo 4.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return n % 4 != 2"}
{"task_id": "Mbpp/67", "completion": "def number_of_partitions_of_set_of_bell_numbers(n):\n    \"\"\"\n    Return the number of ways to partition a set of size n (i.e., the Bell number B(n)).\n    Uses the recurrence B(0)=1, B(n+1)=sum_{k=0}^n C(n,k)*B(k).\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    bell = [0] * (n + 1)\n    bell[0] = 1\n    for m in range(n):\n        total = 0\n        c = 1  # C(m, 0)\n        for k in range(0, m + 1):\n            total += c * bell[k]\n            if k < m:\n                c = c * (m - k) // (k + 1)\n        bell[m + 1] = total\n    return bell[n]"}
{"task_id": "Mbpp/84", "completion": "def newman_conway(n):\n    \"\"\"\n    Return the nth term of the Newman-Conway sequence (A004001).\n    a(1) = 1, a(2) = 1, for n > 2: a(n) = a(a(n-1)) + a(n - a(n-1))\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    if n <= 2:\n        return 1\n    a = [0] * (n + 1)\n    a[1] = 1\n    a[2] = 1\n    for i in range(3, n + 1):\n        k = a[i - 1]\n        a[i] = a[k] + a[i - k]\n    return a[n]"}
{"task_id": "Mbpp/65", "completion": "def flatten_and_sum(data):\n    \"\"\"\n    Flatten a nested list (containing lists or numbers) and return the sum of all numeric elements.\n    Nested structures are explored recursively. Only numbers (int/float) are summed.\n    \"\"\"\n    if isinstance(data, (int, float)):\n        return data\n    if not isinstance(data, list):\n        raise TypeError(\"Input must be a list or nested lists of numbers.\")\n    total = 0\n    for item in data:\n        if isinstance(item, list):\n            total += flatten_and_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n        else:\n            raise TypeError(\"All elements must be numbers or lists of numbers.\")\n    return total"}
{"task_id": "Mbpp/77", "completion": "def is_divisible_by_11(n):\n    \"\"\"\n    Check divisibility by 11 for an integer.\n    Accepts int or string (optional leading +/-).\n    Returns True if divisible by 11, else False.\n    \"\"\"\n    if isinstance(n, int):\n        return n % 11 == 0\n    if isinstance(n, str):\n        s = n.strip()\n        if not s:\n            raise ValueError(\"Input string is empty.\")\n        if s[0] in '+-':\n            s = s[1:]\n        if not s.isdigit():\n            raise ValueError(\"Input string must be a valid integer.\")\n        rem = 0\n        for ch in s:\n            rem = (rem * 10 + (ord(ch) - 48)) % 11\n        return rem == 0\n    raise TypeError(\"Input must be an int or string representing an integer.\")"}
{"task_id": "Mbpp/9", "completion": "def min_rotations_to_match(s: str) -> int:\n    \"\"\"\n    Return the smallest positive k such that rotating s left by k positions yields s.\n    If no such k exists for k < len(s), return len(s).\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # Build prefix function (KMP) for s\n    lps = [0] * n\n    length = 0\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    period = n - lps[-1]\n    if lps[-1] > 0 and n % period == 0:\n        return period\n    return n"}
{"task_id": "Mbpp/86", "completion": "def nth_centered_hexagonal(n):\n    \"\"\"\n    Return the nth centered hexagonal number.\n    The sequence starts with n = 1 -> 1, n = 2 -> 7, n = 3 -> 19, ...\n    Formula: H(n) = 3n(n - 1) + 1\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return 3 * n * (n - 1) + 1"}
{"task_id": "Mbpp/71", "completion": "from typing import Iterable, Callable, TypeVar, List, Optional, Any\n\nT = TypeVar('T')\n\ndef sort_list(items: Iterable[T], key: Optional[Callable[[T], Any]] = None, reverse: bool = False) -> List[T]:\n    \"\"\"\n    Return a new list containing all elements from items sorted in ascending order by the provided key.\n    - key: function applied to elements to determine sort order. If None, elements themselves are compared.\n    - reverse: if True, sort in descending order.\n    \"\"\"\n    arr = list(items)\n\n    def k(x: T) -> Any:\n        return key(x) if key is not None else x\n\n    def merge(left: List[T], right: List[T]) -> List[T]:\n        i = j = 0\n        merged: List[T] = []\n        while i < len(left) and j < len(right):\n            if k(left[i]) <= k(right[j]):\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        return merged\n\n    def merge_sort(seq: List[T]) -> List[T]:\n        n = len(seq)\n        if n <= 1:\n            return seq[:]\n        mid = n // 2\n        left = merge_sort(seq[:mid])\n        right = merge_sort(seq[mid:])\n        return merge(left, right)\n\n    sorted_list = merge_sort(arr)\n    if reverse:\n        sorted_list.reverse()\n    return sorted_list"}
{"task_id": "Mbpp/82", "completion": "def volume_of_sphere(radius):\n    \"\"\"\n    Compute the volume of a sphere with the given radius.\n    Volume = (4/3) * pi * r^3\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    return (4.0/3.0) * 3.141592653589793 * (radius ** 3)"}
{"task_id": "Mbpp/75", "completion": "def find_tuples_divisible_by_k(tuples_list, k):\n    if k == 0:\n        raise ValueError(\"k must be non-zero\")\n    result = []\n    for t in tuples_list:\n        if isinstance(t, tuple):\n            if all(isinstance(x, (int, float)) and (x % k) == 0 for x in t):\n                result.append(t)\n    return result"}
{"task_id": "Mbpp/90", "completion": "def longest_word_length(text: str) -> int:\n    \"\"\"\n    Return the length of the longest word in the input string.\n    A word is defined as a maximal sequence of non-space characters.\n    \"\"\"\n    if not isinstance(text, str):\n        raise TypeError(\"text must be a string\")\n    words = text.split()\n    return max((len(word) for word in words), default=0)"}
{"task_id": "Mbpp/95", "completion": "def length_of_smallest_sublist(list_of_lists):\n    \"\"\"\n    Return the length of the smallest sublist within a list of lists.\n    Raises ValueError if the outer list is empty.\n    \"\"\"\n    if not isinstance(list_of_lists, list) or len(list_of_lists) == 0:\n        raise ValueError(\"Input must be a non-empty list of lists.\")\n    return min(len(sub) for sub in list_of_lists)"}
{"task_id": "Mbpp/89", "completion": "def closest_smaller(nums, n):\n    \"\"\"\n    Return the closest number in nums that is strictly less than n.\n    If no such number exists, return None.\n    \"\"\"\n    closest = None\n    for x in nums:\n        if x < n:\n            if closest is None or x > closest:\n                closest = x\n    return closest"}
{"task_id": "Mbpp/91", "completion": "from typing import Iterable\n\ndef is_substring_in_list(substr: str, values: Iterable[str]) -> bool:\n    return any(substr in s for s in values)"}
{"task_id": "Mbpp/97", "completion": "def frequency_of_elements(list_of_lists):\n    \"\"\"\n    Flatten a list of lists and count frequency of each element.\n    Returns a dictionary {element: count}.\n    \"\"\"\n    freq = {}\n    for sub in list_of_lists:\n        for item in sub:\n            freq[item] = freq.get(item, 0) + 1\n    return freq"}
{"task_id": "Mbpp/101", "completion": "def kth_element(arr, k):\n    \"\"\"\n    Return the kth element (1-based) from the sequence 'arr'.\n    Raises:\n        TypeError: if arr is not a sequence or k is not an integer.\n        IndexError: if k is out of bounds (1 <= k <= len(arr)).\n    \"\"\"\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    try:\n        n = len(arr)\n    except TypeError:\n        raise TypeError(\"arr must be a sequence with a length\")\n    if k < 1 or k > n:\n        raise IndexError(\"k is out of range for the given array\")\n    return arr[k - 1]"}
{"task_id": "Mbpp/93", "completion": "def power(a, b):\n    \"\"\"\n    Compute a raised to the power b.\n    Supports integer exponents efficiently using exponentiation by squaring.\n    For non-integer exponents, falls back to Python's built-in operator.\n    \"\"\"\n    if b == 0:\n        return 1\n    if a == 0:\n        if b > 0:\n            return 0\n        elif b < 0:\n            raise ValueError(\"0 cannot be raised to a negative power\")\n        else:\n            return 1\n    if isinstance(b, int):\n        exp = b\n        base = a\n        if exp < 0:\n            base = 1.0 / a\n            exp = -exp\n        result = 1\n        while exp:\n            if exp & 1:\n                result *= base\n            base *= base\n            exp >>= 1\n        return result\n    else:\n        return a ** b"}
{"task_id": "Mbpp/94", "completion": "def first_value_of_min_second(pairs):\n    \"\"\"\n    Returns the first element of the tuple with the smallest second element.\n    If the input list is empty, returns None.\n    All tuples are expected to have at least two elements.\n    Ties are resolved by choosing the earliest tuple in the list.\n    \"\"\"\n    if not pairs:\n        return None\n    best = None\n    for t in pairs:\n        if len(t) < 2:\n            raise ValueError(\"Each tuple must have at least two elements.\")\n        if best is None or t[1] < best[1]:\n            best = t\n    return best[0]"}
{"task_id": "Mbpp/92", "completion": "def is_undulating(number):\n    n = abs(int(number))\n    digits = [int(ch) for ch in str(n)]\n    if len(digits) <= 1:\n        return True\n    diffs = []\n    for i in range(1, len(digits)):\n        diff = digits[i] - digits[i - 1]\n        if diff == 0:\n            return False\n        diffs.append(diff)\n    for i in range(1, len(diffs)):\n        if diffs[i] * diffs[i - 1] >= 0:\n            return False\n    return True"}
{"task_id": "Mbpp/98", "completion": "def multiply_and_divide_by_length(nums):\n    \"\"\"\n    Multiply all numbers in nums and divide by the length of nums.\n    Returns the resulting float. Raises ValueError if nums is empty.\n    \"\"\"\n    try:\n        values = list(nums)\n    except TypeError as e:\n        raise TypeError(\"nums must be an iterable of numbers\") from e\n\n    n = len(values)\n    if n == 0:\n        raise ValueError(\"Input must contain at least one number.\")\n\n    product = 1.0\n    for v in values:\n        if not isinstance(v, (int, float)):\n            raise TypeError(\"All elements must be numeric (int or float).\")\n        product *= v\n\n    return product / n"}
{"task_id": "Mbpp/99", "completion": "def decimal_to_binary(n: int) -> str:\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    if n == 0:\n        return \"0\"\n    sign = '-' if n < 0 else ''\n    m = abs(n)\n    bits = []\n    while m:\n        bits.append('1' if (m & 1) else '0')\n        m >>= 1\n    return sign + ''.join(reversed(bits))"}
{"task_id": "Mbpp/96", "completion": "def count_divisors(n: int) -> int:\n    \"\"\"\n    Return the number of positive divisors of n.\n    For n == 0, returns 0 (defined as a placeholder since zero has infinite divisors).\n    For negative n, the function uses the absolute value.\n    \"\"\"\n    if n == 0:\n        return 0\n    n = abs(n)\n    result = 1\n\n    # Factor out the power of 2\n    if n % 2 == 0:\n        exp = 0\n        while n % 2 == 0:\n            n //= 2\n            exp += 1\n        result *= (exp + 1)\n\n    # Factor out odd primes\n    p = 3\n    while p * p <= n:\n        if n % p == 0:\n            exp = 0\n            while n % p == 0:\n                n //= p\n                exp += 1\n            result *= (exp + 1)\n        p += 2\n\n    if n > 1:\n        result *= 2  # remaining prime factor\n\n    return result"}
{"task_id": "Mbpp/74", "completion": "def follows_pattern(sequence, patterns):\n    \"\"\"\n    Check if 'sequence' follows the structure defined by 'patterns'.\n    Returns True if for all i, j: sequence[i] == sequence[j] iff patterns[i] == patterns[j].\n    Works with nested and unhashable elements by converting them to a hashable representation.\n    \"\"\"\n    if len(sequence) != len(patterns):\n        return False\n\n    def to_hashable(x):\n        if isinstance(x, dict):\n            return tuple(sorted((to_hashable(k), to_hashable(v)) for k, v in x.items()))\n        if isinstance(x, (list, tuple)):\n            return tuple(to_hashable(i) for i in x)\n        if isinstance(x, set):\n            return frozenset(to_hashable(i) for i in x)\n        return x\n\n    p2v = {}\n    v2p = {}\n    for p, v in zip(patterns, sequence):\n        hp = to_hashable(p)\n        hv = to_hashable(v)\n        if hp in p2v:\n            if p2v[hp] != hv:\n                return False\n        else:\n            p2v[hp] = hv\n        if hv in v2p:\n            if v2p[hv] != hp:\n                return False\n        else:\n            v2p[hv] = hp\n    return True"}
{"task_id": "Mbpp/102", "completion": "def snake_to_camel(s: str) -> str:\n    \"\"\"\n    Convert a snake_case string to camelCase.\n    Consecutive underscores are treated as separators; leading/trailing underscores are ignored.\n    \"\"\"\n    if not isinstance(s, str):\n        s = str(s)\n    parts = [p for p in s.split('_') if p]\n    if not parts:\n        return \"\"\n    first = parts[0].lower()\n    rest = ''.join(p.capitalize() for p in parts[1:])\n    return first + rest"}
{"task_id": "Mbpp/104", "completion": "from typing import List\n\ndef sort_sublists_of_strings(list_of_lists: List[List[str]]) -> List[List[str]]:\n    \"\"\"\n    Sort each sublist of strings in the given list of lists in-place.\n\n    Assumes every inner element is a list containing strings.\n    Returns the input outer list for convenient chaining.\n    \"\"\"\n    for sublist in list_of_lists:\n        if isinstance(sublist, list):\n            sublist.sort()\n    return list_of_lists"}
{"task_id": "Mbpp/105", "completion": "def count_true_booleans(lst):\n    return sum(1 for item in lst if isinstance(item, bool) and item)"}
{"task_id": "Mbpp/118", "completion": "def split_on_space(s):\n    \"\"\"\n    Split the input string on the space character and return the list of substrings.\n    \"\"\"\n    return s.split(' ')"}
{"task_id": "Mbpp/119", "completion": "def find_single_element(nums):\n    \"\"\"\n    Find the element that appears only once in a sorted array\n    where every other element appears exactly twice.\n    Returns the single element.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input array must not be empty\")\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if mid % 2 == 1:\n            mid -= 1\n        if nums[mid] == nums[mid + 1]:\n            left = mid + 2\n        else:\n            right = mid\n    return nums[left]"}
{"task_id": "Mbpp/106", "completion": "def append_list_to_tuple(tup, lst):\n    \"\"\"\n    Append the elements of the list `lst` to the end of the tuple `tup`\n    and return the resulting tuple.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/113", "completion": "def is_integer_string(s):\n    try:\n        int(s)\n        return True\n    except (ValueError, TypeError):\n        return False"}
{"task_id": "Mbpp/128", "completion": "def words_longer_than(words, n):\n    \"\"\"\n    Return a list of words from the input list that have length strictly greater than n.\n    Non-string elements are ignored.\n    \"\"\"\n    return [w for w in words if isinstance(w, str) and len(w) > n]"}
{"task_id": "Mbpp/87", "completion": "def merge_three_dicts(d1, d2, d3):\n    \"\"\"\n    Merge three dictionaries into a new dictionary.\n    Keys from later dictionaries override earlier ones.\n    \"\"\"\n    result = {}\n    if d1 is not None:\n        result.update(d1)\n    if d2 is not None:\n        result.update(d2)\n    if d3 is not None:\n        result.update(d3)\n    return result"}
{"task_id": "Mbpp/111", "completion": "def common_elements(nested_lists):\n    def flatten(item):\n        if isinstance(item, (list, tuple)):\n            for x in item:\n                yield from flatten(x)\n        else:\n            yield item\n\n    if not nested_lists:\n        return []\n\n    sets = []\n    for sub in nested_lists:\n        s = set()\n        for v in flatten(sub):\n            s.add(v)\n        sets.append(s)\n\n    common = sets[0].copy()\n    for s in sets[1:]:\n        common &= s\n        if not common:\n            break\n\n    if not common:\n        return []\n\n    try:\n        return sorted(common)\n    except TypeError:\n        return list(common)"}
{"task_id": "Mbpp/131", "completion": "def reverse_vowels(s: str) -> str:\n    \"\"\"\n    Return a new string where only the vowels in s are reversed.\n    Vowels are a, e, i, o, u (both cases). 'y' is not considered a vowel.\n    \"\"\"\n    vowels = set(\"aeiouAEIOU\")\n    vlist = [c for c in s if c in vowels]\n    i = len(vlist) - 1\n    out_chars = []\n    for ch in s:\n        if ch in vowels:\n            out_chars.append(vlist[i])\n            i -= 1\n        else:\n            out_chars.append(ch)\n    return ''.join(out_chars)"}
{"task_id": "Mbpp/127", "completion": "def multiply(a: int, b: int) -> int:\n    if a == 0 or b == 0:\n        return 0\n    negative = (a < 0) ^ (b < 0)\n    a, b = abs(a), abs(b)\n    result = 0\n    while b:\n        if b & 1:\n            result += a\n        a <<= 1\n        b >>= 1\n    return -result if negative else result"}
{"task_id": "Mbpp/133", "completion": "def sum_negative_numbers(nums):\n    \"\"\"Return the sum of negative numbers in nums. Non-numeric values are ignored.\"\"\"\n    return sum(x for x in nums if isinstance(x, (int, float)) and x < 0)"}
{"task_id": "Mbpp/108", "completion": "def merge_three_lists(a, b, c):\n    return sorted(list(a) + list(b) + list(c))"}
{"task_id": "Mbpp/135", "completion": "def hexagonal_number(n: int) -> int:\n    \"\"\"\n    Return the nth hexagonal number, H(n) = n(2n - 1).\n    n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/139", "completion": "import math\n\ndef circumference(radius):\n    \"\"\"Return the circumference of a circle given its radius.\"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/130", "completion": "def max_freq_item(lst):\n    if not lst:\n        return None\n    counts = {}\n    for item in lst:\n        counts[item] = counts.get(item, 0) + 1\n    max_count = max(counts.values())\n    for item in lst:\n        if counts[item] == max_count:\n            return item\n    return None"}
{"task_id": "Mbpp/124", "completion": "def angle_of_complex(z):\n    \"\"\"\n    Return the angle (argument) of a complex number z in radians.\n    Accepts any value convertible to a complex number.\n    \"\"\"\n    import cmath\n    return cmath.phase(complex(z))"}
{"task_id": "Mbpp/103", "completion": "def a(n, m):\n    \"\"\"\n    Eulerian number A(n, m): number of permutations of {1..n} with exactly m descents.\n    Returns 0 for invalid inputs.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1 if m == 0 else 0\n    if m < 0 or m >= n:\n        return 0\n\n    dp_prev = [1]  # A(1,0) = 1\n    for k in range(2, n + 1):\n        dp_cur = [0] * k\n        for j in range(k):\n            val = 0\n            if j - 1 >= 0:\n                val += (k - j) * dp_prev[j - 1]\n            if j < len(dp_prev):\n                val += (j + 1) * dp_prev[j]\n            dp_cur[j] = val\n        dp_prev = dp_cur\n\n    return dp_prev[m]"}
{"task_id": "Mbpp/142", "completion": "def count_identical_in_position(a, b, c):\n    \"\"\"\n    Count the number of positions where the three lists have the same value.\n    Considers positions up to the length of the shortest list.\n    \"\"\"\n    return sum(1 for x, y, z in zip(a, b, c) if x == y == z)"}
{"task_id": "Mbpp/138", "completion": "def can_be_sum_of_nonzero_powers_of_two(n):\n    \"\"\"\n    Checks if n can be represented as the sum of non-zero powers of two (2^k for k>=1).\n    This is true exactly when n is a positive even integer.\n    \"\"\"\n    return isinstance(n, int) and n > 0 and n % 2 == 0"}
{"task_id": "Mbpp/116", "completion": "def encode_tuple_to_int(t):\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple of positive integers.\")\n    if len(t) == 0:\n        raise ValueError(\"Tuple must be non-empty.\")\n    for x in t:\n        if not isinstance(x, int) or x <= 0:\n            raise ValueError(\"All elements must be positive integers.\")\n\n    def pair(a, b):\n        s = a + b\n        return s * (s + 1) // 2 + b\n\n    res = t[0]\n    for x in t[1:]:\n        res = pair(res, x)\n    return res"}
{"task_id": "Mbpp/137", "completion": "from typing import Optional, Sequence\n\ndef ratio_zero_to_nonzero(arr: Sequence[int]) -> Optional[float]:\n    \"\"\"\n    Returns the ratio of zeros to non-zero elements in the input sequence.\n    - If there are no non-zero elements but there are zeros, returns float('inf').\n    - If the input is empty (zeros == 0 and non-zeros == 0), returns None.\n    - Otherwise, returns zeros / non_zeros as a float.\n    \"\"\"\n    zeros = 0\n    for x in arr:\n        if x == 0:\n            zeros += 1\n    total = len(arr)\n    nonzeros = total - zeros\n    if nonzeros == 0:\n        return None if zeros == 0 else float('inf')\n    return zeros / nonzeros"}
{"task_id": "Mbpp/132", "completion": "def tuple_to_string(t, sep=\"\"):\n    \"\"\"\n    Converts a tuple to a string by concatenating its elements.\n    - Non-string elements are converted using str().\n    - Nested tuples are flattened recursively.\n    - A custom separator can be provided to join top-level elements.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n\n    def convert(item):\n        if isinstance(item, tuple):\n            return ''.join(convert(e) for e in item)\n        else:\n            return str(item)\n\n    return sep.join(convert(elem) for elem in t)"}
{"task_id": "Mbpp/129", "completion": "def is_magic_square(matrix):\n    \"\"\"\n    Check if the given matrix is a magic square of order n.\n\n    A magic square is an n x n matrix containing the numbers 1 through n^2\n    exactly once, such that the sums of the numbers in each row, each column,\n    and both main diagonals are all equal.\n\n    Returns True if the matrix is a magic square, otherwise False.\n    \"\"\"\n    if not matrix:\n        return False\n\n    n = len(matrix)\n    # Ensure it's a square matrix\n    for row in matrix:\n        if len(row) != n:\n            return False\n\n    # Target sum from the first row\n    target = sum(matrix[0])\n\n    # Check all row sums\n    for row in matrix:\n        if sum(row) != target:\n            return False\n\n    # Check all column sums\n    for c in range(n):\n        s = 0\n        for r in range(n):\n            s += matrix[r][c]\n        if s != target:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != target:\n        return False\n\n    # Check for numbers 1..n^2 exactly once\n    expected = set(range(1, n * n + 1))\n    flat = {matrix[i][j] for i in range(n) for j in range(n)}\n    if flat != expected:\n        return False\n\n    return True"}
{"task_id": "Mbpp/126", "completion": "import math\n\ndef sum_of_common_divisors(a, b):\n    g = math.gcd(abs(a), abs(b))\n    if g == 0:\n        return 0\n    total = 0\n    limit = int(g ** 0.5)\n    for i in range(1, limit + 1):\n        if g % i == 0:\n            total += i\n            other = g // i\n            if other != i:\n                total += other\n    return total"}
{"task_id": "Mbpp/140", "completion": "def flatten_to_set(list_of_lists):\n    \"\"\"\n    Flatten a list of lists into a set of numbers (unique elements).\n    \"\"\"\n    result = set()\n    if not list_of_lists:\n        return result\n    for sub in list_of_lists:\n        if sub is None:\n            continue\n        for item in sub:\n            result.add(item)\n    return result"}
{"task_id": "Mbpp/168", "completion": "def count_occurrences(numbers, target):\n    \"\"\"\n    Return the number of times target appears in the list numbers.\n    \"\"\"\n    count = 0\n    for num in numbers:\n        if num == target:\n            count += 1\n    return count"}
{"task_id": "Mbpp/100", "completion": "def next_smallest_palindrome(n: int) -> int:\n    if n <= 0:\n        return 0\n    if n <= 9:\n        return n - 1\n\n    s = str(n)\n    L = len(s)\n    half = (L + 1) // 2  # length of the left part including middle if odd\n    left = s[:half]\n\n    def build_pal(left_str: str, total_len: int) -> str:\n        if total_len % 2 == 0:\n            return left_str + left_str[::-1]\n        else:\n            return left_str + left_str[:-1][::-1]\n\n    pal_str = build_pal(left, L)\n    if int(pal_str) < n:\n        return int(pal_str)\n\n    left_num = int(left) - 1\n    if left_num < 10 ** (half - 1):\n        return int('9' * (L - 1))\n\n    new_left = str(left_num)\n    pal_str2 = build_pal(new_left, L)\n    return int(pal_str2)"}
{"task_id": "Mbpp/125", "completion": "def max_abs_diff_zero_one_substring(s: str) -> int:\n    \"\"\"\n    Return the maximum absolute difference between the number of '0's and '1's\n    in any substring of the binary string s.\n    \"\"\"\n    if not s:\n        return 0\n\n    max_ending = 0\n    max_sum = float('-inf')\n    min_ending = 0\n    min_sum = float('inf')\n\n    for ch in s:\n        val = 1 if ch == '0' else -1  # '0' -> +1, '1' -> -1\n\n        max_ending = max(val, max_ending + val)\n        max_sum = max(max_sum, max_ending)\n\n        min_ending = min(val, min_ending + val)\n        min_sum = min(min_sum, min_ending)\n\n    return max(max_sum, -min_sum)"}
{"task_id": "Mbpp/171", "completion": "def pentagon_perimeter(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon given the length of one side.\n    For a regular pentagon, perimeter P = 5 * s.\n    \"\"\"\n    if isinstance(side_length, bool):\n        raise TypeError(\"side_length must be a numeric value, not a boolean.\")\n    if not isinstance(side_length, (int, float)):\n        raise TypeError(\"side_length must be a numeric value (int or float).\")\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative.\")\n    return 5 * side_length"}
{"task_id": "Mbpp/226", "completion": "def remove_odd_index_chars(s):\n    \"\"\"\n    Remove characters with odd indices from the input string.\n    Returns a new string consisting of characters at even indices (0, 2, 4, ...).\n    \"\"\"\n    return s[::2]"}
{"task_id": "Mbpp/162", "completion": "def sum_sequence(n):\n    m = n // 2\n    return (m + 1) * (n - m)"}
{"task_id": "Mbpp/165", "completion": "def count_alphabet_position_matches(s: str) -> int:\n    s = s.lower()\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    return sum(1 for i in range(min(len(s), len(alphabet))) if s[i] == alphabet[i])"}
{"task_id": "Mbpp/120", "completion": "def max_abs_product_between_tuples(tuple_list):\n    \"\"\"\n    Given a list of 2-element tuples, returns the maximum absolute product\n    obtainable by choosing one element from two different tuples.\n    \"\"\"\n    n = len(tuple_list)\n    if n < 2:\n        raise ValueError(\"At least two tuples are required.\")\n    max1 = -1\n    max2 = -1\n    for t in tuple_list:\n        a, b = t\n        w = max(abs(a), abs(b))\n        if w > max1:\n            max2 = max1\n            max1 = w\n        elif w > max2:\n            max2 = w\n    return max1 * max2"}
{"task_id": "Mbpp/166", "completion": "def count_pairs_xor_even(nums):\n    evens = 0\n    for x in nums:\n        if x % 2 == 0:\n            evens += 1\n    odds = len(nums) - evens\n    return evens * (evens - 1) // 2 + odds * (odds - 1) // 2"}
{"task_id": "Mbpp/167", "completion": "def smallest_power_of_two_ge(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return 1\n    if (n & (n - 1)) == 0:\n        return n\n    return 1 << n.bit_length()"}
{"task_id": "Mbpp/145", "completion": "def max_difference(arr):\n    if arr is None or len(arr) < 2:\n        return 0\n    return max(arr) - min(arr)"}
{"task_id": "Mbpp/227", "completion": "def min_of_three(a, b, c):\n    m = a\n    if b < m:\n        m = b\n    if c < m:\n        m = c\n    return m"}
{"task_id": "Mbpp/172", "completion": "def count_std(s: str) -> int:\n    \"\"\"\n    Count occurrences of the substring 'std' in the given string.\n    Overlapping occurrences are counted.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    target = 'std'\n    tlen = len(target)\n    count = 0\n    for i in range(len(s) - tlen + 1):\n        if s[i:i + tlen] == target:\n            count += 1\n    return count"}
{"task_id": "Mbpp/234", "completion": "def cube_volume(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n    side_length must be a non-negative number.\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"Side length must be non-negative.\")\n    return side_length ** 3"}
{"task_id": "Mbpp/230", "completion": "def replace_spaces(s: str, ch: str) -> str:\n    return s.replace(' ', ch)"}
{"task_id": "Mbpp/233", "completion": "import math\n\ndef lateral_surface_area(radius, height):\n    \"\"\"\n    Compute the lateral surface area of a cylinder.\n    LSA = 2 * pi * radius * height\n    \"\"\"\n    return 2 * math.pi * radius * height"}
{"task_id": "Mbpp/222", "completion": "def all_same_type(t: tuple) -> bool:\n    \"\"\"\n    Check if all elements in the tuple have the same type.\n    Empty tuple is considered homogeneous.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return len({type(x) for x in t}) <= 1"}
{"task_id": "Mbpp/224", "completion": "def count_set_bits(n):\n    \"\"\"\n    Return the number of set bits (1s) in the binary representation of a non-negative integer n.\n    Uses Brian Kernighan's algorithm for efficient counting.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an int\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count"}
{"task_id": "Mbpp/161", "completion": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef remove_all_present(source: List[T], removal: List[T]) -> List[T]:\n    \"\"\"Return a new list with elements from source not present in removal.\"\"\"\n    try:\n        removal_set = set(removal)\n        return [x for x in source if x not in removal_set]\n    except TypeError:\n        result = []\n        for x in source:\n            if not any(x == r for r in removal):\n                result.append(x)\n        return result"}
{"task_id": "Mbpp/238", "completion": "def count_non_empty_substrings(s: str) -> int:\n    \"\"\"\n    Return the number of non-empty substrings of s.\n    For a string of length n, the total number of substrings (including duplicates) is n*(n+1)//2.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    n = len(s)\n    return n * (n + 1) // 2"}
{"task_id": "Mbpp/160", "completion": "def solve_linear_diophantine(a, b, n):\n    \"\"\"\n    Returns integers x, y such that a*x + b*y == n, or None if no solution exists.\n    \"\"\"\n    # Handle the degenerate case where both coefficients are zero\n    if a == 0 and b == 0:\n        return (0, 0) if n == 0 else None\n\n    # Iterative Extended Euclidean Algorithm\n    def extended_gcd(a, b):\n        old_r, r = a, b\n        old_s, s = 1, 0\n        old_t, t = 0, 1\n        while r != 0:\n            q = old_r // r\n            old_r, r = r, old_r - q * r\n            old_s, s = s, old_s - q * s\n            old_t, t = t, old_t - q * t\n        return old_r, old_s, old_t  # (g, x, y) such that a*x + b*y = g\n\n    g, x0, y0 = extended_gcd(a, b)\n    if g == 0:\n        return None  # Should not happen due to earlier check, but safe guard\n\n    if n % g != 0:\n        return None\n\n    k = n // g\n    return (x0 * k, y0 * k)"}
{"task_id": "Mbpp/232", "completion": "def n_largest_items(lst, n):\n    \"\"\"\n    Return the n largest items from lst as a list in descending order.\n    If n <= 0, returns an empty list. If n >= len(lst), returns all items sorted descending.\n    \"\"\"\n    if n <= 0:\n        return []\n    if n >= len(lst):\n        return sorted(lst, reverse=True)\n    import heapq\n    return heapq.nlargest(n, lst)"}
{"task_id": "Mbpp/242", "completion": "def count_characters(s: str) -> int:\n    \"\"\"\n    Return the total number of characters in the string s.\n    \"\"\"\n    return len(s)"}
{"task_id": "Mbpp/123", "completion": "def sum_amicable_numbers(limit):\n    if limit < 2:\n        return 0\n\n    # Compute sum of proper divisors for all numbers up to limit using a sieve-like approach\n    s = [0] * (limit + 1)\n    for d in range(1, limit // 2 + 1):\n        for m in range(2 * d, limit + 1, d):\n            s[m] += d\n\n    def sum_proper_divisors(n):\n        if n <= 1:\n            return 0\n        total = 1\n        temp = n\n        p = 2\n        while p * p <= temp:\n            if temp % p == 0:\n                sum_p = 1 + p\n                temp //= p\n                power = p\n                while temp % p == 0:\n                    temp //= p\n                    power *= p\n                    sum_p += power\n                total *= sum_p\n            p += 1 if p == 2 else 2\n        if temp > 1:\n            total *= (1 + temp)\n        return total - n\n\n    total_sum = 0\n    for a in range(2, limit + 1):\n        b = s[a]\n        if b != a:\n            if b <= limit:\n                b_sum = s[b]\n            else:\n                b_sum = sum_proper_divisors(b)\n            if b_sum == a:\n                total_sum += a\n\n    return total_sum"}
{"task_id": "Mbpp/109", "completion": "def count_odd_rotations(bin_str: str, times: int) -> int:\n    \"\"\"\n    Return the number of odd-valued rotations when a binary string bin_str\n    is left-rotated exactly 'times' times.\n    A rotation yields an odd value if its least significant bit is '1'.\n    \"\"\"\n    if times <= 0 or not bin_str:\n        return 0\n\n    n = len(bin_str)\n\n    # Prefix sums of ones for quick range queries\n    pref = [0] * (n + 1)\n    for i, ch in enumerate(bin_str):\n        pref[i + 1] = pref[i] + (1 if ch == '1' else 0)\n\n    ones = pref[n]\n    cycles = times // n\n    rem = times % n\n\n    extra = 0\n    if rem:\n        # For the first 'rem' rotations, the last bits come from positions:\n        # n-1, 0, 1, ..., rem-2\n        extra = (1 if bin_str[-1] == '1' else 0) + pref[rem - 1]\n\n    return cycles * ones + extra"}
{"task_id": "Mbpp/240", "completion": "def replace_last_with_list(lst1, lst2):\n    if lst1:\n        lst1[-1:] = lst2\n    else:\n        lst1.extend(lst2)"}
{"task_id": "Mbpp/237", "completion": "def count_tuples(lst):\n    \"\"\"\n    Return a dictionary mapping each unique tuple in lst to its frequency.\n    \"\"\"\n    counts = {}\n    for t in lst:\n        counts[t] = counts.get(t, 0) + 1\n    return counts"}
{"task_id": "Mbpp/250", "completion": "def count_occurrences(t, element):\n    \"\"\"\n    Return the number of times 'element' occurs in the tuple 't'.\n    \"\"\"\n    return t.count(element)"}
{"task_id": "Mbpp/170", "completion": "def sum_in_range(nums, start, end, inclusive=True):\n    \"\"\"\n    Return the sum of elements in nums from the boundary indices start to end.\n    If inclusive is True, include end; else exclude end.\n    Indices can be in any order; the range is interpreted between the two indices.\n    \"\"\"\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"nums must be a list or tuple\")\n    if not isinstance(start, int) or not isinstance(end, int):\n        raise TypeError(\"start and end must be integers\")\n    a, b = sorted((start, end))\n    if inclusive:\n        return sum(nums[a:b+1])\n    else:\n        return sum(nums[a:b])"}
{"task_id": "Mbpp/251", "completion": "def insert_before_each(lst, element):\n    \"\"\"\n    Return a new list with 'element' inserted before each element in 'lst'.\n    \"\"\"\n    result = []\n    for x in lst:\n        result.append(element)\n        result.append(x)\n    return result"}
{"task_id": "Mbpp/259", "completion": "def maximize_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Return a tuple containing the element-wise maximum of t1 and t2.\n    Both inputs must be tuples of the same length.\n    \"\"\"\n    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must be of the same length.\")\n    return tuple(max(a, b) for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/257", "completion": "def swap_second_first(a, b):\n    \"\"\"\n    Return a tuple with the second argument first, then the first argument.\n    \"\"\"\n    return (b, a)"}
{"task_id": "Mbpp/239", "completion": "def count_sequences(m: int, n: int) -> int:\n    if m <= 0 or n <= 0:\n        return 0\n    # Initialize for sequences of length 1: any a1 in [1, m]\n    dp_prev = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp_prev[x] = 1\n\n    for _ in range(2, n + 1):\n        diff = [0] * (m + 2)  # difference array for range updates on [2*p, m]\n        for p in range(1, m + 1):\n            v = dp_prev[p]\n            if v:\n                left = 2 * p\n                if left <= m:\n                    diff[left] += v\n                    diff[m + 1] -= v\n        dp_curr = [0] * (m + 1)\n        acc = 0\n        for x in range(1, m + 1):\n            acc += diff[x]\n            dp_curr[x] = acc\n        dp_prev = dp_curr\n\n    return sum(dp_prev[1:])"}
{"task_id": "Mbpp/253", "completion": "def count_integers(lst):\n    \"\"\"\n    Return the number of elements in lst that are exactly of type int.\n    Booleans are not counted since they are of type bool.\n    \"\"\"\n    return sum(1 for x in lst if type(x) is int)"}
{"task_id": "Mbpp/261", "completion": "def div_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Perform element-wise division of two tuples.\n    Returns a new tuple where each element i is t1[i] / t2[i].\n    Raises ValueError if tuples have different lengths.\n    Propagates ZeroDivisionError if any t2[i] == 0.\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"tuples must be of the same length\")\n    return tuple(a / b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/252", "completion": "import math\n\ndef complex_to_polar(z):\n    \"\"\"\n    Convert a complex number to polar coordinates (r, theta) in radians.\n    Returns a tuple (r, theta) where r >= 0 and theta is in (-pi, pi].\n    \"\"\"\n    z = complex(z)\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)\n    return (r, theta)"}
{"task_id": "Mbpp/141", "completion": "def sort_list(elements):\n    \"\"\"Return a new list containing the elements sorted in ascending order\n    using a stable merge sort. The input is not modified.\n    \"\"\"\n    def merge(left, right):\n        i = j = 0\n        merged = []\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        return merged\n\n    items = list(elements)\n    n = len(items)\n    if n <= 1:\n        return items.copy()\n    mid = n // 2\n    left_sorted = sort_list(items[:mid])\n    right_sorted = sort_list(items[mid:])\n    return merge(left_sorted, right_sorted)"}
{"task_id": "Mbpp/223", "completion": "def is_majority(arr, n, x):\n    \"\"\"\n    Returns True if x is the majority element in the sorted array arr of length n.\n    A majority element occurs more than n/2 times.\n    \"\"\"\n    # Find first occurrence of x via binary search\n    lo, hi = 0, n - 1\n    first = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid - 1\n            if arr[mid] == x:\n                first = mid\n    if first == -1:\n        return False\n\n    # Find last occurrence of x via binary search\n    lo, hi = 0, n - 1\n    last = -1\n    while lo <= hi:\n        mid = (lo + hi) // 2\n        if arr[mid] > x:\n            hi = mid - 1\n        else:\n            lo = mid + 1\n            if arr[mid] == x:\n                last = mid\n\n    count = last - first + 1\n    return count > n // 2"}
{"task_id": "Mbpp/265", "completion": "def split_list_every_n(lst, n):\n    \"\"\"\n    Split lst into chunks of size n. Returns a list of sublists.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    chunks = []\n    for i in range(0, len(lst), n):\n        chunks.append(lst[i:i+n])\n    return chunks"}
{"task_id": "Mbpp/247", "completion": "def longest_palindromic_subsequence_length(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2 if j > i + 1 else 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]"}
{"task_id": "Mbpp/266", "completion": "def lateral_surface_area_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n    Lateral surface area = 4 * side_length^2\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative\")\n    return 4 * (side_length ** 2)"}
{"task_id": "Mbpp/264", "completion": "def dog_years(human_years: float) -> float:\n    \"\"\"\n    Convert human years to dog years using the common approximation:\n    - The first 2 human years equal 21 dog years (10.5 per year)\n    - Each additional human year equals 4 dog years\n    Returns a float to handle partial years.\n    \"\"\"\n    if human_years < 0:\n        raise ValueError(\"human_years must be non-negative\")\n    if human_years <= 2:\n        return human_years * 10.5\n    return 21.0 + (human_years - 2.0) * 4.0"}
{"task_id": "Mbpp/245", "completion": "def max_sum_bitonic_subsequence(arr):\n    \"\"\"\n    Compute the maximum sum of a bitonic subsequence (increasing then decreasing).\n    A bitonic subsequence can be as simple as a single element.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # Maximum sum of increasing subsequence ending at i\n    inc = [0] * n\n    for i in range(n):\n        best = 0\n        for j in range(i):\n            if arr[j] < arr[i] and inc[j] > best:\n                best = inc[j]\n        inc[i] = arr[i] + best\n\n    # Maximum sum of decreasing subsequence starting at i\n    dec = [0] * n\n    for i in range(n - 1, -1, -1):\n        best = 0\n        for j in range(i + 1, n):\n            if arr[j] < arr[i] and dec[j] > best:\n                best = dec[j]\n        dec[i] = arr[i] + best\n\n    # Bitonic with peak at i: inc[i] + dec[i] - arr[i] (arr[i] counted twice)\n    return max(inc[i] + dec[i] - arr[i] for i in range(n))"}
{"task_id": "Mbpp/262", "completion": "def split_list_at(lst, L):\n    \"\"\"\n    Split the list into two parts such that the first part has length L.\n    Returns a tuple: (first_part, second_part)\n    \"\"\"\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/273", "completion": "def subtract_tuples(t1, t2):\n    \"\"\"\n    Subtract elements of t2 from t1 element-wise and return a new tuple.\n    Both inputs must be tuples of equal length.\n    \"\"\"\n    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must be of the same length.\")\n    return tuple(a - b for a, b in zip(t1, t2))"}
{"task_id": "Mbpp/244", "completion": "import math\n\ndef next_perfect_square(n):\n    \"\"\"\n    Return the smallest perfect square strictly greater than n.\n    If n is negative, returns 0.\n    \"\"\"\n    if n < 0:\n        return 0\n    return math.ceil(math.sqrt(n + 1)) ** 2"}
{"task_id": "Mbpp/268", "completion": "def nth_star_number(n: int) -> int:\n    \"\"\"\n    Compute the nth star number.\n    Star numbers are given by S(n) = 6*n*(n-1) + 1, with n >= 1.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return 6 * n * (n - 1) + 1"}
{"task_id": "Mbpp/267", "completion": "def sum_odd_squares(n: int) -> int:\n    \"\"\"\n    Returns the sum of squares of the first n odd natural numbers.\n    Formula: sum_{k=1..n} (2k-1)^2 = n*(2n-1)*(2n+1)/3\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return n * (2 * n - 1) * (2 * n + 1) // 3"}
{"task_id": "Mbpp/276", "completion": "import math\n\ndef cylinder_volume(radius: float, height: float) -> float:\n    \"\"\"Calculate the volume of a cylinder: V = \u03c0 * r^2 * h.\"\"\"\n    return math.pi * (radius ** 2) * height"}
{"task_id": "Mbpp/269", "completion": "def ascii_value(ch: str) -> int:\n    \"\"\"\n    Return the ASCII value of a single character.\n\n    Raises:\n        TypeError: if input is not a string.\n        ValueError: if input is not a single character or if the character is non-ASCII.\n    \"\"\"\n    if not isinstance(ch, str):\n        raise TypeError(\"Input must be a string representing a single character.\")\n    if len(ch) != 1:\n        raise ValueError(\"Input must be a single character.\")\n    val = ord(ch)\n    if val > 127:\n        raise ValueError(\"Character is not ASCII.\")\n    return val"}
{"task_id": "Mbpp/278", "completion": "def count_before_element_in_tuple(tup, element):\n    \"\"\"\n    Return the number of elements that occur before the first occurrence\n    of element in the tuple 'tup'.\n    If the element is not present, return -1.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    try:\n        return tup.index(element)\n    except ValueError:\n        return -1"}
{"task_id": "Mbpp/272", "completion": "def rear_elements(pairs):\n    return [t[-1] for t in pairs]"}
{"task_id": "Mbpp/277", "completion": "def filter_dict_by_min_value(d, n):\n    \"\"\"\n    Return a new dictionary containing items from d whose values are >= n.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise TypeError(\"d must be a dictionary.\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer.\")\n    return {k: v for k, v in d.items() if v >= n}"}
{"task_id": "Mbpp/256", "completion": "def count_primes_less_than(n):\n    \"\"\"\n    Return the number of prime numbers less than n.\n    n is treated as a non-negative integer (floored if given as float).\n    \"\"\"\n    n = int(n)\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    p = 2\n    while p * p < n:\n        if is_prime[p]:\n            for i in range(p * p, n, p):\n                is_prime[i] = False\n        p += 1\n    return sum(is_prime)"}
{"task_id": "Mbpp/270", "completion": "def sum_even_at_even_positions(nums):\n    \"\"\"\n    Returns the sum of elements that are even numbers located at even indices (0-based) in the input list.\n    Non-integer values are ignored.\n    \"\"\"\n    total = 0\n    for idx in range(0, len(nums), 2):\n        val = nums[idx]\n        if isinstance(val, int) and val % 2 == 0:\n            total += val\n    return total"}
{"task_id": "Mbpp/255", "completion": "def generate_combinations_with_repetition(lst, n):\n    \"\"\"\n    Generate all combinations with repetition of elements from lst of length n.\n    Returns a list of tuples, each tuple representing one combination.\n    \"\"\"\n    # Treat duplicates in the input as the same element by using unique values\n    unique_vals = list(dict.fromkeys(lst))\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return [()]\n    result = []\n\n    def backtrack(start, path):\n        if len(path) == n:\n            result.append(tuple(path))\n            return\n        for i in range(start, len(unique_vals)):\n            path.append(unique_vals[i])\n            backtrack(i, path)  # allow repetition of the same element\n            path.pop()\n\n    backtrack(0, [])\n    return result"}
{"task_id": "Mbpp/281", "completion": "def are_elements_unique(lst):\n    \"\"\"\n    Check if all elements in the given list are unique.\n    Returns True if all elements are distinct, False otherwise.\n    Handles hashable elements efficiently; for unhashable elements it falls back to a quadratic comparison.\n    \"\"\"\n    if not isinstance(lst, list):\n        lst = list(lst)\n\n    try:\n        return len(lst) == len(set(lst))\n    except TypeError:\n        n = len(lst)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] == lst[j]:\n                    return False\n        return True"}
{"task_id": "Mbpp/280", "completion": "def find_in_array(arr, element):\n    \"\"\"\n    Returns a tuple (found, index) where found is True if 'element' exists in 'arr',\n    and index is the position of its first occurrence or -1 if not found.\n    \"\"\"\n    for i, val in enumerate(arr):\n        if val == element:\n            return (True, i)\n    return (False, -1)"}
{"task_id": "Mbpp/274", "completion": "def sum_even_index_binomial(n):\n    \"\"\"\n    Return the sum of binomial coefficients C(n, k) for even k (0 <= k <= n).\n    For n >= 1 this equals 2^(n-1).\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 1 << (n - 1)"}
{"task_id": "Mbpp/284", "completion": "def all_equal_to(lst, element):\n    return all(x == element for x in lst)"}
{"task_id": "Mbpp/282", "completion": "from typing import List, Union\n\ndef subtract_lists(a: List[Union[int, float]], b: List[Union[int, float]]) -> List[Union[int, float]]:\n    \"\"\"\n    Subtract two lists element-wise.\n    Both lists must have the same length and contain numeric values.\n    Returns a new list with a[i] - b[i].\n    \"\"\"\n    if not isinstance(a, list) or not isinstance(b, list):\n        raise TypeError(\"Both inputs must be lists.\")\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length.\")\n    return [x - y for x, y in zip(a, b)]"}
{"task_id": "Mbpp/287", "completion": "def sum_squares_first_n_even(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return 2 * n * (n + 1) * (2 * n + 1) // 3"}
{"task_id": "Mbpp/279", "completion": "def nth_decagonal(n: int) -> int:\n    \"\"\"Return the nth decagonal number, defined as P10(n) = n(4n - 3).\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (4 * n - 3)"}
{"task_id": "Mbpp/285", "completion": "def contains_a_followed_by_two_or_three_bs(s: str) -> bool:\n    for i in range(len(s) - 2):\n        if s[i] == 'a' and s[i + 1] == 'b' and s[i + 2] == 'b':\n            return True\n    return False"}
{"task_id": "Mbpp/290", "completion": "def max_length_sublists(lists):\n    if not lists:\n        return []\n    max_len = max(len(sub) for sub in lists)\n    return [sub for sub in lists if len(sub) == max_len]"}
{"task_id": "Mbpp/235", "completion": "def set_even_bits(n):\n    \"\"\"\n    Set all even-indexed bits (0-based, counting from LSB) of n to 1.\n    Handles non-negative integers. For n == 0, bit 0 will be set.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    limit = max(n, 1)\n    mask = 0\n    i = 0\n    while (1 << i) <= limit:\n        mask |= (1 << i)\n        i += 2\n    return n | mask"}
{"task_id": "Mbpp/283", "completion": "def is_digit_frequency_valid(n: int) -> bool:\n    \"\"\"\n    Return True if for every digit present in the absolute value of n,\n    the frequency of that digit is less than or equal to the digit itself.\n    \"\"\"\n    s = str(abs(n))\n    from collections import Counter\n    counts = Counter(s)\n    for ch, cnt in counts.items():\n        d = ord(ch) - ord('0')\n        if cnt > d:\n            return False\n    return True"}
{"task_id": "Mbpp/297", "completion": "def flatten(nested):\n    if not isinstance(nested, (list, tuple)):\n        return [nested]\n    result = []\n    for item in nested:\n        if isinstance(item, (list, tuple)):\n            result.extend(flatten(item))\n        else:\n            result.append(item)\n    return result"}
{"task_id": "Mbpp/299", "completion": "def max_aggregate(list_of_tuples):\n    \"\"\"\n    Compute the maximum aggregate (sum) among a list of tuples.\n    Returns None if the input list is empty.\n    \"\"\"\n    return max((sum(t) for t in list_of_tuples), default=None)"}
{"task_id": "Mbpp/310", "completion": "def string_to_char_tuple(s: str) -> tuple:\n    \"\"\"Convert a string into a tuple of its characters.\"\"\"\n    return tuple(s)"}
{"task_id": "Mbpp/309", "completion": "def max_of_two(a, b):\n    \"\"\"\n    Return the maximum of two numbers.\n    If they are equal, returns a (or b).\n    \"\"\"\n    if a >= b:\n        return a\n    else:\n        return b"}
{"task_id": "Mbpp/271", "completion": "def sum_first_n_even_numbers_fifth(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    a = n * n\n    b = (n + 1) * (n + 1)\n    c = 2 * n * n + 2 * n - 1\n    return (8 * a * b * c) // 3"}
{"task_id": "Mbpp/292", "completion": "def floor_quotient(a, b):\n    \"\"\"\n    Return floor(a / b) as an integer. Raises ZeroDivisionError if b == 0.\n    Works for integers and floating-point numbers.\n    \"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if isinstance(a, int) and isinstance(b, int):\n        return a // b\n    import math\n    return int(math.floor(a / b))"}
{"task_id": "Mbpp/300", "completion": "def comb(n, k):\n    if k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    k = min(k, n - k)\n    result = 1\n    for i in range(1, k + 1):\n        result = result * (n - k + i) // i\n    return result\n\ndef count_sequences(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return comb(2 * n, n)"}
{"task_id": "Mbpp/305", "completion": "def two_p_words(words, case_insensitive=True):\n    \"\"\"\n    Return the first two words from 'words' that start with 'p'.\n    If fewer than two such words exist, raise ValueError.\n    \"\"\"\n    if case_insensitive:\n        predicate = lambda w: isinstance(w, str) and w.lower().startswith('p')\n    else:\n        predicate = lambda w: isinstance(w, str) and w.startswith('p')\n    found = []\n    for w in words:\n        if predicate(w):\n            found.append(w)\n            if len(found) == 2:\n                return (found[0], found[1])\n    raise ValueError(\"Less than two words start with 'p'.\")"}
{"task_id": "Mbpp/312", "completion": "import math\n\ndef volume_of_cone(radius: float, height: float) -> float:\n    \"\"\"\n    Calculate the volume of a cone given its radius and height.\n    Volume = (1/3) * pi * r^2 * h\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"Radius and height must be non-negative.\")\n    return (math.pi * radius * radius * height) / 3.0"}
{"task_id": "Mbpp/296", "completion": "def count_inversions(arr):\n    \"\"\"\n    Count inversions in the array.\n    An inversion is a pair (i, j) with i < j and arr[i] > arr[j].\n    Returns the number of inversions as an integer.\n    \"\"\"\n    a = list(arr)\n\n    def merge_sort_with_count(sub):\n        n = len(sub)\n        if n <= 1:\n            return sub, 0\n        mid = n // 2\n        left, inv_left = merge_sort_with_count(sub[:mid])\n        right, inv_right = merge_sort_with_count(sub[mid:])\n        merged = []\n        i = j = 0\n        inv_split = 0\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                merged.append(left[i])\n                i += 1\n            else:\n                merged.append(right[j])\n                j += 1\n                inv_split += len(left) - i\n        if i < len(left):\n            merged.extend(left[i:])\n        if j < len(right):\n            merged.extend(right[j:])\n        total = inv_left + inv_right + inv_split\n        return merged, total\n\n    _, count = merge_sort_with_count(a)\n    return count"}
{"task_id": "Mbpp/260", "completion": "def newman_shanks_williams_prime(n):\n    \"\"\"\n    Return the nth Newman\u2013Shanks\u2013Williams prime.\n    NSW sequence: s0 = 1, s1 = 1, s_k = 2*s_{k-1} + s_{k-2} for k >= 2.\n    NSW primes are terms s_k that are prime. The function is 1-indexed on NSW primes.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        small_primes = (2,3,5,7,11,13,17,19,23,29,31)\n        for p in small_primes:\n            if num % p == 0:\n                return num == p\n        # write num-1 = d * 2^s\n        d = num - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        # Use a set of bases suitable for large numbers (probabilistic)\n        for a in (2, 3, 5, 7, 11, 13, 17):\n            if a >= num:\n                continue\n            x = pow(a, d, num)\n            if x == 1 or x == num - 1:\n                continue\n            composite = True\n            for _ in range(s - 1):\n                x = (x * x) % num\n                if x == num - 1:\n                    composite = False\n                    break\n            if composite:\n                return False\n        return True\n\n    count = 0\n    a0, a1 = 1, 1  # s0, s1\n    while True:\n        s = 2*a1 + a0\n        if is_prime(s):\n            count += 1\n            if count == n:\n                return s\n        a0, a1 = a1, s"}
{"task_id": "Mbpp/390", "completion": "def apply_format_to_list(items, format_string):\n    \"\"\"\n    Apply a given format string to each element in the input list.\n    Each element is formatted using the standard str.format mechanism with the\n    element as the sole positional argument.\n    Returns a new list of formatted strings.\n    If formatting fails for an element, its string representation is used instead.\n    \"\"\"\n    result = []\n    for x in items:\n        try:\n            result.append(format_string.format(x))\n        except Exception:\n            result.append(str(x))\n    return result"}
{"task_id": "Mbpp/395", "completion": "def first_non_repeated_char(s):\n    \"\"\"\n    Return the first non-repeated character in string s.\n    If there is no such character, return None.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    from collections import Counter\n    counts = Counter(s)\n    for ch in s:\n        if counts[ch] == 1:\n            return ch\n    return None"}
{"task_id": "Mbpp/388", "completion": "def highest_power_of_2_leq(n):\n    \"\"\"\n    Return the largest power of 2 that is less than or equal to n.\n    If n < 1, returns 0.\n    Accepts integers or values convertible to int.\n    \"\"\"\n    try:\n        n = int(n)\n    except (TypeError, ValueError):\n        raise TypeError(\"n must be an integer or numeric value convertible to int\")\n\n    if n < 1:\n        return 0\n    return 1 << (n.bit_length() - 1)"}
{"task_id": "Mbpp/397", "completion": "def median_of_three(a, b, c):\n    \"\"\"\n    Return the median value among a, b, and c.\n    Works for integers and floats.\n    \"\"\"\n    return a + b + c - max(a, b, c) - min(a, b, c)"}
{"task_id": "Mbpp/394", "completion": "def has_no_duplicates(t: tuple) -> bool:\n    \"\"\"\n    Return True if the input tuple 't' contains no duplicate elements.\n    Handles both hashable and unhashable elements.\n    \"\"\"\n    seen_hashable = set()\n    seen_unhashable = []\n    for x in t:\n        try:\n            if x in seen_hashable:\n                return False\n            seen_hashable.add(x)\n        except TypeError:\n            for y in seen_unhashable:\n                if x == y:\n                    return False\n            seen_unhashable.append(x)\n    return True"}
{"task_id": "Mbpp/398", "completion": "def sum_of_digits_per_number(nums):\n    \"\"\"\n    Given an iterable of integers, return a list where each element is the sum of digits\n    of the corresponding number. Negative numbers are treated by using the digits of their\n    absolute value.\n    \"\"\"\n    return [sum(int(ch) for ch in str(abs(int(n)))) for n in nums]"}
{"task_id": "Mbpp/405", "completion": "def element_in_tuple(t, x):\n    \"\"\"\n    Check whether element x exists in tuple t.\n    Returns True if x is in t, else False.\n    \"\"\"\n    return x in t"}
{"task_id": "Mbpp/392", "completion": "def max_sum(n):\n    from functools import lru_cache\n\n    @lru_cache(maxsize=None)\n    def f(x):\n        if x <= 0:\n            return 0\n        s = f(x // 2) + f(x // 3) + f(x // 4) + f(x // 5)\n        return max(s, x)\n\n    return f(n)"}
{"task_id": "Mbpp/293", "completion": "import math\n\ndef third_side(a=None, b=None, c=None):\n    \"\"\"\n    Compute the missing side of a right triangle given the other two sides.\n    Exactly one of a, b, c must be None (the side to compute).\n    - If c is missing: c = sqrt(a^2 + b^2)\n    - If a is missing: a = sqrt(c^2 - b^2)\n    - If b is missing: b = sqrt(c^2 - a^2)\n    All provided sides must be non-negative numbers.\n    \"\"\"\n    missing = [name for name, val in (('a', a), ('b', b), ('c', c)) if val is None]\n    if len(missing) != 1:\n        raise ValueError(\"Exactly one of a, b, or c must be provided as None to compute the third side.\")\n    # Validate provided values\n    for name, val in (('a', a), ('b', b), ('c', c)):\n        if val is not None:\n            if not isinstance(val, (int, float)):\n                raise TypeError(f\"{name} must be numeric.\")\n            if val < 0:\n                raise ValueError(f\"{name} must be non-negative.\")\n    epsilon = 1e-12\n    if c is None:\n        return math.hypot(a, b)\n    elif a is None:\n        val = c*c - b*b\n        if val < 0:\n            if abs(val) < epsilon:\n                val = 0.0\n            else:\n                raise ValueError(\"Invalid side lengths: c^2 must be >= b^2.\")\n        return math.sqrt(val)\n    else:  # b is None\n        val = c*c - a*a\n        if val < 0:\n            if abs(val) < epsilon:\n                val = 0.0\n            else:\n                raise ValueError(\"Invalid side lengths: c^2 must be >= a^2.\")\n        return math.sqrt(val)"}
{"task_id": "Mbpp/404", "completion": "def min_of_two(a, b):\n    \"\"\"Return the smaller of two numbers a and b.\"\"\"\n    return a if a <= b else b"}
{"task_id": "Mbpp/301", "completion": "def dict_depth(d):\n    \"\"\"\n    Compute the maximum depth of a dictionary, counting nested dictionaries\n    that appear in values as well as dictionaries inside lists/tuples/sets.\n    An empty dictionary has depth 1. If the input is not a dict, returns 0.\n    \"\"\"\n    def _depth(o, seen):\n        if id(o) in seen:\n            return 0\n        if isinstance(o, dict):\n            seen.add(id(o))\n            if not o:\n                seen.remove(id(o))\n                return 1\n            max_child = 0\n            for v in o.values():\n                depth_v = _depth(v, seen)\n                if depth_v > max_child:\n                    max_child = depth_v\n            seen.remove(id(o))\n            return max_child + 1\n        elif isinstance(o, (list, tuple, set)):\n            max_child = 0\n            for item in o:\n                depth_item = _depth(item, seen)\n                if depth_item > max_child:\n                    max_child = depth_item\n            return max_child\n        else:\n            return 0\n    if not isinstance(d, dict):\n        return 0\n    return _depth(d, set())"}
{"task_id": "Mbpp/311", "completion": "def set_leftmost_unset_bit(n: int, width: int = 32) -> int:\n    \"\"\"\n    Set the leftmost (most significant) unset bit within a fixed bit width.\n\n    Parameters:\n        n: non-negative integer\n        width: number of bits to consider (default 32)\n\n    Returns:\n        Integer with the leftmost unset bit set to 1 within the given width.\n        If all bits in the width are 1, the next higher bit is set (width-th bit).\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if width <= 0:\n        raise ValueError(\"width must be a positive integer\")\n\n    for i in range(width - 1, -1, -1):\n        if ((n >> i) & 1) == 0:\n            return n | (1 << i)\n    return n | (1 << width)"}
{"task_id": "Mbpp/308", "completion": "def k_largest_pair_products(list1, list2, k):\n    \"\"\"\n    Return the k largest products obtainable by multiplying one element\n    from list1 with one element from list2.\n\n    Parameters:\n    - list1: iterable of numbers\n    - list2: iterable of numbers\n    - k: int, number of largest products to return\n\n    Returns:\n    - List of the k largest products in descending order.\n      If k > total number of products, all products are returned sorted descending.\n    \"\"\"\n    a = list(list1)\n    b = list(list2)\n    n, m = len(a), len(b)\n\n    if n == 0 or m == 0 or k <= 0:\n        return []\n\n    total = n * m\n    if k >= total:\n        products = [x * y for x in a for y in b]\n        return sorted(products, reverse=True)\n\n    import heapq\n    minheap = []\n    for x in a:\n        for y in b:\n            p = x * y\n            if len(minheap) < k:\n                heapq.heappush(minheap, p)\n            else:\n                if p > minheap[0]:\n                    heapq.heapreplace(minheap, p)\n\n    return sorted(minheap, reverse=True)"}
{"task_id": "Mbpp/406", "completion": "def is_odd_parity(n: int) -> bool:\n    \"\"\"\n    Determine if the parity of n is odd.\n    Returns True if n is odd, otherwise False.\n    \"\"\"\n    return (n & 1) != 0"}
{"task_id": "Mbpp/294", "completion": "def max_in_heterogeneous_list(lst):\n    if lst is None or len(lst) == 0:\n        raise ValueError(\"max_in_heterogeneous_list() arg is an empty sequence\")\n\n    def _type_order(x):\n        t = type(x)\n        order = {\n            bool: 0,\n            int: 1,\n            float: 2,\n            complex: 3,\n            str: 4,\n            tuple: 5,\n            list: 6,\n            set: 7,\n            dict: 8,\n        }\n        return order.get(t, 9)\n\n    def _compare(a, b):\n        try:\n            if a > b:\n                return 1\n            if a < b:\n                return -1\n            return 0\n        except Exception:\n            pass\n\n        ta, tb = type(a), type(b)\n        if ta == tb:\n            sa, sb = str(a), str(b)\n            if sa > sb:\n                return 1\n            if sa < sb:\n                return -1\n            return 0\n\n        oa, ob = _type_order(a), _type_order(b)\n        if oa != ob:\n            return 1 if oa > ob else -1\n\n        ia, ib = id(a), id(b)\n        if ia > ib:\n            return 1\n        if ia < ib:\n            return -1\n        return 0\n\n    max_val = lst[0]\n    for item in lst[1:]:\n        if _compare(item, max_val) > 0:\n            max_val = item\n    return max_val"}
{"task_id": "Mbpp/389", "completion": "def lucas(n):\n    \"\"\"Return the nth Lucas number (L0 = 2, L1 = 1, L_n = L_{n-1} + L_{n-2}).\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    def fib_pair(k):\n        if k == 0:\n            return (0, 1)\n        a, b = fib_pair(k >> 1)\n        c = a * ((b << 1) - a)  # F(2m)\n        d = a * a + b * b         # F(2m + 1)\n        if (k & 1) == 0:\n            return (c, d)\n        else:\n            return (d, c + d)\n\n    F_n, F_n_plus_1 = fib_pair(n)\n    return 2 * F_n_plus_1 - F_n"}
{"task_id": "Mbpp/306", "completion": "def max_sum_increasing_subseq_with_k(arr, i, k):\n    \"\"\"\n    Compute the maximum sum of an increasing subsequence that consists of:\n    a subsequence from indices [0..i] (possibly empty) followed by arr[k],\n    with the requirement that the subsequence is strictly increasing and k > i.\n    Returns the maximum possible sum.\n    \"\"\"\n    n = len(arr)\n    if not (0 <= i < k < n):\n        raise ValueError(\"Require 0 <= i < k < len(arr)\")\n    \n    # msis_end[j] = maximum sum of an increasing subsequence that ends at index j\n    msis_end = [0] * k\n    for j in range(k):\n        best = 0\n        for t in range(j):\n            if arr[t] < arr[j] and msis_end[t] > best:\n                best = msis_end[t]\n        msis_end[j] = arr[j] + best\n\n    # Find best sum from prefix [0..i] that can be extended by arr[k]\n    max_prefix_sum = 0\n    for j in range(min(i + 1, k)):\n        if arr[j] < arr[k] and msis_end[j] > max_prefix_sum:\n            max_prefix_sum = msis_end[j]\n\n    return max(arr[k], max_prefix_sum + arr[k])"}
{"task_id": "Mbpp/419", "completion": "def round_and_sum_times_length(nums):\n    total = sum(round(x) for x in nums)\n    result = total * len(nums)\n    print(result)"}
{"task_id": "Mbpp/414", "completion": "def any_value_in_sequences(seq_a, seq_b):\n    \"\"\"\n    Return True if there exists any value that appears in both seq_a and seq_b.\n    Works with hashable and non-hashable elements (falls back to O(n*m) if needed).\n    \"\"\"\n    a = list(seq_a)\n    b = list(seq_b)\n    if not a or not b:\n        return False\n    try:\n        if len(a) <= len(b):\n            set_b = set(b)\n            for x in a:\n                if x in set_b:\n                    return True\n            return False\n        else:\n            set_a = set(a)\n            for x in b:\n                if x in set_a:\n                    return True\n            return False\n    except TypeError:\n        # Fallback for unhashable elements\n        for x in a:\n            for y in b:\n                if x == y:\n                    return True\n        return False"}
{"task_id": "Mbpp/420", "completion": "def cube_sum_of_first_n_even_numbers(n):\n    \"\"\"\n    Return the sum of cubes of the first n even natural numbers (2, 4, ..., 2n).\n    Uses the closed-form: sum_{k=1..n} (2k)^3 = 2 * n^2 * (n+1)^2\n    \"\"\"\n    if isinstance(n, bool) or not isinstance(n, int):\n        raise TypeError(\"n must be a non-negative integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return 2 * (n ** 2) * ((n + 1) ** 2)"}
{"task_id": "Mbpp/421", "completion": "def join_tuple_elements(tup, delimiter):\n    \"\"\"\n    Concatenate each element of a tuple into a single string, separated by the given delimiter.\n    Each element is converted to string. Raises TypeError if input is not a tuple.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    delim = \"\" if delimiter is None else str(delimiter)\n    return delim.join(str(x) for x in tup)"}
{"task_id": "Mbpp/418", "completion": "def max_length_element(iterable):\n    \"\"\"\n    Return the first element in 'iterable' with the maximum length among elements\n    that support len(). If no such element exists, raise ValueError.\n    \"\"\"\n    best = None\n    best_len = -1\n    found = False\n    for item in iterable:\n        try:\n            cur_len = len(item)\n        except TypeError:\n            continue\n        if not found or cur_len > best_len:\n            best_len = cur_len\n            best = item\n            found = True\n    if not found:\n        raise ValueError(\"No element with a measurable length found.\")\n    return best"}
{"task_id": "Mbpp/413", "completion": "def extract_nth_elements(tuple_list, n):\n    \"\"\"\n    Return a list containing the nth element (0-based) from each tuple in tuple_list.\n    Raises:\n        TypeError: if inputs are not of expected types.\n        IndexError: if any tuple does not have index n.\n    \"\"\"\n    if not isinstance(tuple_list, list):\n        raise TypeError(\"tuple_list must be a list of tuples\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    result = []\n    for t in tuple_list:\n        if not isinstance(t, tuple):\n            raise TypeError(\"All items in tuple_list must be tuples\")\n        result.append(t[n])\n    return result"}
{"task_id": "Mbpp/427", "completion": "def convert_date_yyyy_mm_dd_to_dd_mm_yyyy(date_str: str) -> str:\n    from datetime import datetime\n    dt = datetime.strptime(date_str.strip(), \"%Y-%m-%d\")\n    return dt.strftime(\"%d-%m-%Y\")"}
{"task_id": "Mbpp/424", "completion": "from typing import Tuple\n\ndef extract_rear_index_elements(strings: Tuple[str, ...]) -> Tuple[str, ...]:\n    \"\"\"\n    Given a tuple of strings, return a tuple containing the last character of each string.\n    If a string is empty, place an empty string in the corresponding position.\n    \"\"\"\n    return tuple(s[-1] if s else \"\" for s in strings)"}
{"task_id": "Mbpp/428", "completion": "def shell_sort(arr):\n    \"\"\"\n    Sort the input list in place using the Shell Sort algorithm and return the sorted list.\n    \"\"\"\n    if arr is None:\n        return None\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr"}
{"task_id": "Mbpp/425", "completion": "def count_sublists_with_element(nested, element):\n    \"\"\"\n    Return the number of sublists within 'nested' that contain 'element'.\n    Each sublist is checked with 'element in sub'.\n    Non-iterable sublists are ignored.\n    \"\"\"\n    count = 0\n    for sub in nested:\n        try:\n            if element in sub:\n                count += 1\n        except TypeError:\n            continue\n    return count"}
{"task_id": "Mbpp/422", "completion": "def average_of_cubes_of_first_n(n: int) -> float:\n    \"\"\"\n    Returns the average of cubes of the first n natural numbers (1^3 + 2^3 + ... + n^3) / n.\n    Uses the closed-form formula: sum of cubes is (n(n+1)/2)^2, so average is n*(n+1)^2 / 4.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return (n * (n + 1) * (n + 1)) / 4.0"}
{"task_id": "Mbpp/426", "completion": "def filter_odds(iterable):\n    \"\"\"Return a list of odd integers from the given iterable. Non-integer values are ignored.\"\"\"\n    return [n for n in iterable if isinstance(n, int) and n % 2 != 0]"}
{"task_id": "Mbpp/441", "completion": "def cube_surface_area(side_length):\n    \"\"\"\n    Calculate the surface area of a cube given the side length.\n    Surface area = 6 * (side_length ** 2)\n    \"\"\"\n    return 6 * (side_length ** 2)"}
{"task_id": "Mbpp/412", "completion": "def remove_odd_numbers(nums):\n    \"\"\"\n    Remove odd integers from the list in place.\n    Non-integer values are left untouched.\n    Returns the mutated list for convenience.\n    \"\"\"\n    nums[:] = [x for x in nums if not (isinstance(x, int) and x % 2 != 0)]\n    return nums"}
{"task_id": "Mbpp/391", "completion": "def lists_to_nested_dict(paths):\n    \"\"\"\n    Convert a collection of paths (each path is an iterable of hashable keys)\n    into a nested dictionary where each path's keys define a nesting.\n    Example:\n    [[1, 2, 3], [1, 2, 4], [1, 5]] -> {1: {2: {3: {}, 4: {}}, 5: {}}}\n    \"\"\"\n    nested = {}\n    for path in paths:\n        if not path:\n            continue\n        node = nested\n        for key in path:\n            if key not in node or not isinstance(node[key], dict):\n                node[key] = {}\n            node = node[key]\n    return nested"}
{"task_id": "Mbpp/445", "completion": "def index_wise_multiply(tup1, tup2):\n    \"\"\"\n    Returns a tuple containing the products of corresponding elements from tup1 and tup2.\n    Both inputs must be tuples of equal length.\n    \"\"\"\n    if not isinstance(tup1, tuple) or not isinstance(tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(tup1) != len(tup2):\n        raise ValueError(\"Tuples must have the same length for index-wise multiplication.\")\n    return tuple(a * b for a, b in zip(tup1, tup2))"}
{"task_id": "Mbpp/437", "completion": "def remove_odd_characters(s: str) -> str:\n    \"\"\"\n    Remove characters at odd indices (0-based) from the string.\n    Returns a string consisting of characters at even indices.\n    \"\"\"\n    return s[::2]"}
{"task_id": "Mbpp/433", "completion": "def is_greater_than_all(num, arr):\n    \"\"\"\n    Check if the given number is greater than every element in the array.\n    Returns True if num > x for all x in arr. If arr is empty, returns True.\n    \"\"\"\n    return all(num > x for x in arr)"}
{"task_id": "Mbpp/415", "completion": "def max_product_pair(arr):\n    \"\"\"\n    Returns a tuple containing two numbers from arr whose product is maximum.\n    Works for integers (positive, negative, and zero).\n    Raises ValueError if fewer than 2 elements.\n    \"\"\"\n    if arr is None or len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    \n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n    \n    for x in arr:\n        # Update the largest two\n        if x > max1:\n            max2 = max1\n            max1 = x\n        elif x > max2:\n            max2 = x\n        \n        # Update the smallest two\n        if x < min1:\n            min2 = min1\n            min1 = x\n        elif x < min2:\n            min2 = x\n    \n    product1 = max1 * max2\n    product2 = min1 * min2\n    \n    if product1 >= product2:\n        return (max1, max2)\n    else:\n        return (min1, min2)"}
{"task_id": "Mbpp/435", "completion": "def last_digit(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return abs(n) % 10"}
{"task_id": "Mbpp/436", "completion": "def negative_numbers(lst):\n    \"\"\"Return all negative numbers from the given list.\"\"\"\n    return [x for x in lst if isinstance(x, (int, float)) and not isinstance(x, bool) and x < 0]"}
{"task_id": "Mbpp/432", "completion": "def trapezium_median_length(a, b):\n    \"\"\"\n    Returns the median (midline) length of a trapezium given the lengths of its two parallel sides (bases).\n    The median length m equals the average of the bases: m = (a + b) / 2.\n    \"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Base lengths must be numeric (int or float).\")\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Base lengths must be positive.\")\n    return (a + b) / 2"}
{"task_id": "Mbpp/286", "completion": "def max_subarray_sum_k_times(arr, k):\n    \"\"\"\n    Return the maximum subarray sum in the array formed by concatenating arr k times.\n    \"\"\"\n    if not arr or k <= 0:\n        return 0\n\n    def kadane(a):\n        cur = a[0]\n        best = a[0]\n        for x in a[1:]:\n            cur = max(x, cur + x)\n            if cur > best:\n                best = cur\n        return best\n\n    def max_prefix_sum(a):\n        s = 0\n        best = a[0]\n        for x in a:\n            s += x\n            if s > best:\n                best = s\n        return best\n\n    def max_suffix_sum(a):\n        s = 0\n        best = a[-1]\n        for x in reversed(a):\n            s += x\n            if s > best:\n                best = s\n        return best\n\n    s1 = kadane(arr)\n    s2 = kadane(arr + arr)\n\n    if k == 1:\n        return s1\n\n    total = sum(arr)\n    pref = max_prefix_sum(arr)\n    suff = max_suffix_sum(arr)\n\n    cross = suff + pref + (k - 2) * total\n    return max(s2, cross)"}
{"task_id": "Mbpp/447", "completion": "def cube_elements(lst):\n    \"\"\"\n    Return a list containing the cube of each element in the input list.\n    Each element x is transformed to x**3.\n    \"\"\"\n    return [x ** 3 for x in lst]"}
{"task_id": "Mbpp/456", "completion": "from typing import List\n\ndef reverse_strings_in_list(strings: List[str]) -> List[str]:\n    return [s[::-1] for s in strings]"}
{"task_id": "Mbpp/446", "completion": "def count_occurrences_of_list_in_tuple(elements, tup):\n    \"\"\"\n    Count occurrences of each element from the given list in the provided tuple.\n    Returns a dictionary mapping each distinct element from 'elements' (preserving first-appearance order)\n    to its count in 'tup'. Elements not present in tup will have count 0.\n    \"\"\"\n    counts = {}\n    for el in elements:\n        if el not in counts:\n            counts[el] = tup.count(el)\n    return counts"}
{"task_id": "Mbpp/439", "completion": "import math\n\ndef join_integers_to_number(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list of non-negative integers\")\n    if len(nums) == 0:\n        raise ValueError(\"nums must be a non-empty list\")\n    for n in nums:\n        if not isinstance(n, int):\n            raise TypeError(\"All elements must be integers\")\n        if n < 0:\n            raise ValueError(\"All numbers must be non-negative\")\n    result = 0\n    for n in nums:\n        digits = 1 if n == 0 else int(math.log10(n)) + 1\n        result = result * (10 ** digits) + n\n    return result"}
{"task_id": "Mbpp/455", "completion": "def has_31_days(month: int) -> bool:\n    \"\"\"\n    Return True if the given month number (1-12) has 31 days, otherwise False.\n    Invalid inputs return False.\n    \"\"\"\n    if not isinstance(month, int):\n        return False\n    if month < 1 or month > 12:\n        return False\n    return month in (1, 3, 5, 7, 8, 10, 12)"}
{"task_id": "Mbpp/429", "completion": "def extract_elementwise_and_tuples(t1, t2):\n    \"\"\"\n    Given two sequences (tuples) of equal length, return a tuple consisting of:\n      - a tuple of elementwise 'AND' results\n      - a tuple of paired elements (tuples) from both input sequences\n    \"\"\"\n    t1 = tuple(t1)\n    t2 = tuple(t2)\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length.\")\n    paired = tuple(zip(t1, t2))\n    results = []\n    for a, b in paired:\n        try:\n            if isinstance(a, bool) and isinstance(b, bool):\n                results.append(a and b)\n            elif isinstance(a, int) and isinstance(b, int):\n                results.append(a & b)\n            else:\n                results.append(a & b)\n        except Exception:\n            results.append(bool(a) and bool(b))\n    return (tuple(results), paired)"}
{"task_id": "Mbpp/458", "completion": "def rectangle_area(length, width):\n    return length * width"}
{"task_id": "Mbpp/450", "completion": "from typing import Iterable, List\n\ndef extract_strings_of_size(values: Iterable[str], size: int) -> List[str]:\n    \"\"\"\n    Extract strings from a list that have the specified length.\n\n    Parameters:\n        values: An iterable of strings.\n        size: The desired length for strings to be extracted (non-negative integer).\n\n    Returns:\n        A list of strings from values whose length equals size.\n    \"\"\"\n    if not isinstance(size, int) or size < 0:\n        raise ValueError(\"size must be a non-negative integer\")\n\n    return [v for v in values if isinstance(v, str) and len(v) == size]"}
{"task_id": "Mbpp/451", "completion": "def remove_whitespaces(s: str) -> str:\n    \"\"\"Remove all whitespace characters from the input string and return the result.\"\"\"\n    return ''.join(s.split())"}
{"task_id": "Mbpp/410", "completion": "def min_value_heterogeneous(lst):\n    \"\"\"\n    Return the minimum element in a heterogeneous list.\n    Ordering rules:\n    - Booleans and numbers (int/float) are considered numbers and ordered by their numeric value.\n    - All other types are ordered by their string representation (repr).\n    - Numbers are prioritized before non-numbers.\n    Raises ValueError if the list is empty and TypeError if input is not a list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    if not lst:\n        raise ValueError(\"min_value_heterogeneous() arg is an empty sequence\")\n\n    def key(x):\n        if isinstance(x, bool):\n            return (0, int(x))\n        if isinstance(x, (int, float)):\n            return (0, x)\n        # complex or other non-numeric types are treated as non-numeric\n        return (1, repr(x))\n\n    return min(lst, key=key)"}
{"task_id": "Mbpp/453", "completion": "def sum_even_factors(n):\n    \"\"\"\n    Return the sum of all positive even divisors of n.\n    For non-positive or odd n, returns 0.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return 0\n    if n % 2 != 0:\n        return 0\n\n    m = n // 2\n    s = 0\n    i = 1\n    while i * i <= m:\n        if m % i == 0:\n            s += i\n            j = m // i\n            if j != i:\n                s += j\n        i += 1\n    return 2 * s"}
{"task_id": "Mbpp/460", "completion": "def first_of_each_sublist(sublists):\n    \"\"\"\n    Return a list containing the first element of each sublist.\n    Assumes each sublist is non-empty.\n    \"\"\"\n    return [sub[0] for sub in sublists]"}
{"task_id": "Mbpp/463", "completion": "def max_product_subarray(nums):\n    if not nums:\n        return 0\n    max_prod = min_prod = result = nums[0]\n    for x in nums[1:]:\n        if x < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(x, max_prod * x)\n        min_prod = min(x, min_prod * x)\n        result = max(result, max_prod)\n    return result"}
{"task_id": "Mbpp/471", "completion": "def product_of_array_mod(arr, n):\n    \"\"\"\n    Returns the product of all integers in arr modulo n.\n    arr: iterable of integers\n    n: positive integer modulus\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    result = 1 % n\n    for a in arr:\n        result = (result * (a % n)) % n\n        if result == 0:\n            return 0\n    return result"}
{"task_id": "Mbpp/470", "completion": "def pairwise_addition_of_neighbors(t: tuple) -> tuple:\n    \"\"\"\n    Return a tuple containing the sums of each pair of neighboring elements in the input tuple.\n    For a tuple of length n, returns a tuple of length n-1 where result[i] = t[i] + t[i+1].\n    If input length < 2, returns an empty tuple.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if len(t) < 2:\n        return tuple()\n    return tuple(t[i] + t[i + 1] for i in range(len(t) - 1))"}
{"task_id": "Mbpp/454", "completion": "def find_words_with_z(text):\n    import re\n    pattern = re.compile(r'\\b\\w*z\\w*\\b', re.IGNORECASE)\n    return pattern.findall(text)"}
{"task_id": "Mbpp/475", "completion": "def sort_dict_by_value(d, reverse=False):\n    \"\"\"\n    Return a new dictionary sorted by its values.\n    The resulting dictionary preserves the sorted order (Python 3.7+).\n    \"\"\"\n    return dict(sorted(d.items(), key=lambda item: item[1], reverse=reverse))"}
{"task_id": "Mbpp/448", "completion": "def sum_perrin(n: int) -> int:\n    \"\"\"\n    Return the sum of Perrin numbers P(0) through P(n) inclusive.\n    Perrin numbers: P(0)=3, P(1)=0, P(2)=2, and P(k)=P(k-2)+P(k-3) for k>=3.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3\n    if n == 2:\n        return 5\n\n    # Sum up to P(2)\n    s = 3 + 0 + 2  # 3\n    # Rolling window for P(i-1), P(i-2), P(i-3) => start with P(2), P(1), P(0)\n    p0, p1, p2 = 2, 0, 3  # P(2), P(1), P(0)\n\n    for i in range(3, n + 1):\n        p = p1 + p2      # P(i) = P(i-2) + P(i-3)\n        s += p\n        p0, p1, p2 = p, p0, p1  # advance window to (P(i), P(i-1), P(i-2))\n\n    return s"}
{"task_id": "Mbpp/477", "completion": "def to_lower_case(s: str) -> str:\n    \"\"\"\n    Convert the input string to lowercase and return the result.\n    \"\"\"\n    return s.lower()"}
{"task_id": "Mbpp/474", "completion": "def replace_chars(s, mapping):\n    \"\"\"\n    Replace characters in the string 's' using a mapping dict.\n    mapping: dict where keys are single-character strings and values are replacement strings.\n    For each character in 's', if it exists as a key in 'mapping', it is replaced by mapping[char].\n    Otherwise, the character is kept unchanged.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"s must be a string\")\n    if not isinstance(mapping, dict):\n        raise TypeError(\"mapping must be a dict\")\n    for k, v in mapping.items():\n        if not isinstance(k, str) or len(k) != 1:\n            raise ValueError(\"mapping keys must be single-character strings\")\n        if not isinstance(v, str):\n            raise ValueError(\"mapping values must be strings\")\n    return ''.join(mapping.get(ch, ch) for ch in s)"}
{"task_id": "Mbpp/473", "completion": "def tuple_intersection_of_tuples(tuple_list):\n    \"\"\"\n    Returns a tuple containing elements common to all tuples in tuple_list.\n    The order of elements in the result follows their first appearance in the first tuple,\n    and duplicates are removed.\n    \"\"\"\n    if not tuple_list:\n        return tuple()\n    common = set(tuple_list[0])\n    for t in tuple_list[1:]:\n        common &= set(t)\n        if not common:\n            return tuple()\n    first = tuple_list[0]\n    seen = set()\n    res = []\n    for x in first:\n        if x in common and x not in seen:\n            seen.add(x)\n            res.append(x)\n    return tuple(res)"}
{"task_id": "Mbpp/457", "completion": "def sublist_with_min_length(lists_of_sublists):\n    \"\"\"\n    Returns the sublist with the minimum length from a list/tuple of sublists.\n    If input is empty, returns an empty list.\n    \"\"\"\n    if not isinstance(lists_of_sublists, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple of sublists.\")\n    if len(lists_of_sublists) == 0:\n        return []\n    return min(lists_of_sublists, key=len)"}
{"task_id": "Mbpp/462", "completion": "def all_combinations(lst):\n    \"\"\"\n    Return all possible combinations (the power set) of elements from the given list.\n    Each combination is represented as a list, and the empty combination is included.\n    \"\"\"\n    items = list(lst)\n    result = [[]]\n    for item in items:\n        new_combinations = [subset + [item] for subset in result]\n        result.extend(new_combinations)\n    return result"}
{"task_id": "Mbpp/476", "completion": "def sum_of_min_max(arr):\n    if arr is None:\n        raise ValueError(\"Input array is None\")\n    it = iter(arr)\n    try:\n        first = next(it)\n    except StopIteration:\n        raise ValueError(\"Input array must contain at least one element\")\n    mn = mx = first\n    for x in it:\n        if x < mn:\n            mn = x\n        if x > mx:\n            mx = x\n    return mn + mx"}
{"task_id": "Mbpp/459", "completion": "def remove_uppercase_substrings(s: str) -> str:\n    \"\"\"\n    Remove all substrings consisting of uppercase letters from the input string.\n    This implementation removes every uppercase character, which effectively\n    collapses all uppercase sequences.\n    \"\"\"\n    return ''.join(ch for ch in s if not ch.isupper())"}
{"task_id": "Mbpp/430", "completion": "def directrix_of_parabola(parabola):\n    \"\"\"\n    Compute the directrix line coefficients (A, B, C) for a parabola described in standard oriented form.\n    \n    Supported forms:\n      - {'shape': 'horizontal', 'h': ..., 'k': ..., 'a': ...}\n        Represents (y - k)^2 = 4 a (x - h). Directrix: x = h - a.\n      - {'shape': 'vertical', 'h': ..., 'k': ..., 'a': ...}\n        Represents (x - h)^2 = 4 a (y - k). Directrix: y = k - a.\n    \n    Returns:\n        A tuple (A, B, C) such that the directrix line is A*x + B*y + C = 0.\n    \"\"\"\n    shape = parabola.get('shape')\n    if shape == 'horizontal':\n        h = parabola.get('h', 0.0)\n        a = parabola.get('a')\n        if a is None:\n            raise ValueError(\"Parameter 'a' must be provided for a horizontal parabola.\")\n        A, B, C = 1.0, 0.0, -(h - a)  # x = h - a  =>  1*x + 0*y - (h - a) = 0\n    elif shape == 'vertical':\n        k = parabola.get('k', 0.0)\n        a = parabola.get('a')\n        if a is None:\n            raise ValueError(\"Parameter 'a' must be provided for a vertical parabola.\")\n        A, B, C = 0.0, 1.0, -(k - a)  # y = k - a  =>  0*x + 1*y - (k - a) = 0\n    else:\n        raise ValueError(\"Unsupported shape. Use 'horizontal' or 'vertical'.\")\n    return (A, B, C)"}
{"task_id": "Mbpp/560", "completion": "def union_of_tuples(tup1, tup2):\n    \"\"\"\n    Return a list containing the union of elements from tup1 and tup2 in sorted order.\n    Elements are assumed to be hashable and comparable.\n    \"\"\"\n    return sorted(set(tup1) | set(tup2))"}
{"task_id": "Mbpp/557", "completion": "def toggle_case(s: str) -> str:\n    return s.swapcase()"}
{"task_id": "Mbpp/555", "completion": "def difference_sum_cubes_and_sum(n: int) -> int:\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    s = n * (n + 1) // 2\n    sum_cubes = s * s\n    return sum_cubes - s"}
{"task_id": "Mbpp/554", "completion": "def filter_odds(nums):\n    return [n for n in nums if n % 2 != 0]"}
{"task_id": "Mbpp/472", "completion": "def has_consecutive_numbers(nums):\n    \"\"\"\n    Check if the given list contains consecutive numbers.\n    Returns True if the numbers form a consecutive sequence from\n    the minimum to the maximum value (duplicates allowed).\n    \"\"\"\n    if nums is None:\n        return False\n    if len(nums) <= 1:\n        return True\n    mn = min(nums)\n    mx = max(nums)\n    return (mx - mn + 1) == len(set(nums))"}
{"task_id": "Mbpp/564", "completion": "from collections import Counter\n\ndef count_unequal_pairs(nums):\n    n = len(nums)\n    if n < 2:\n        return 0\n    total_pairs = n * (n - 1) // 2\n    freq = Counter(nums)\n    equal_pairs = sum(v * (v - 1) // 2 for v in freq.values())\n    return total_pairs - equal_pairs"}
{"task_id": "Mbpp/566", "completion": "def sum_of_digits(n: int) -> int:\n    \"\"\"\n    Return the sum of the digits of a non-negative integer n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    total = 0\n    while n:\n        total += n % 10\n        n //= 10\n    return total"}
{"task_id": "Mbpp/558", "completion": "def sum_per_digit_difference(a: int, b: int) -> int:\n    \"\"\"\n    Return the sum of the absolute differences of corresponding digits of a and b.\n    Digits are aligned from least significant digit; if lengths differ, the extra\n    digits are treated as differences with 0.\n    \"\"\"\n    a = abs(int(a))\n    b = abs(int(b))\n    total = 0\n    while a > 0 or b > 0:\n        total += abs((a % 10) - (b % 10))\n        a //= 10\n        b //= 10\n    return total"}
{"task_id": "Mbpp/567", "completion": "def is_sorted(lst):\n    \"\"\"\n    Check if the given list is sorted in non-decreasing order.\n    Returns True if sorted, False otherwise.\n    An empty list or a list with one element is considered sorted.\n    \"\"\"\n    if len(lst) < 2:\n        return True\n    prev = lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] < prev:\n            return False\n        prev = lst[i]\n    return True"}
{"task_id": "Mbpp/478", "completion": "def remove_lowercase_substrings(s: str) -> str:\n    \"\"\"\n    Remove all contiguous substrings consisting of lowercase (Unicode-aware) letters from the input string.\n    \"\"\"\n    if not s:\n        return s\n    res = []\n    i = 0\n    n = len(s)\n    while i < n:\n        if s[i].islower():\n            j = i\n            while j < n and s[j].islower():\n                j += 1\n            i = j\n        else:\n            res.append(s[i])\n            i += 1\n    return ''.join(res)"}
{"task_id": "Mbpp/559", "completion": "def max_subarray_sum(nums):\n    \"\"\"\n    Returns the sum of the largest contiguous subarray within nums.\n    If nums is empty, returns 0.\n    \"\"\"\n    nums = list(nums)\n    if not nums:\n        return 0\n\n    max_ending_here = max_so_far = nums[0]\n    for x in nums[1:]:\n        max_ending_here = max(x, max_ending_here + x)\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far"}
{"task_id": "Mbpp/440", "completion": "import re\nfrom typing import List, Tuple, Optional\n\n_ADVERB_WORDS = {\n    \"not\",\"very\",\"quite\",\"too\",\"almost\",\"barely\",\"frequently\",\"often\",\"usually\",\"normally\",\"always\",\"never\",\"seldom\",\"rarely\",\n    \"early\",\"late\",\"now\",\"soon\",\"there\",\"therefore\",\"thus\",\"however\",\"anyway\",\"anyhow\",\"still\",\"already\",\"just\",\"simply\",\n    \"nearly\",\"properly\",\"straight\",\"quickly\",\"slowly\",\"hard\",\"fast\",\"well\"\n}\n\ndef _is_adverb(token: str) -> bool:\n    lower = token.lower()\n    if lower in _ADVERB_WORDS:\n        return True\n    if len(lower) > 2 and lower.endswith(\"ly\"):\n        return True\n    return False\n\ndef find_first_adverb_and_positions(sentence: str) -> Tuple[Optional[str], List[int]]:\n    \"\"\"\n    Find the first adverb in the sentence and all positions (token indices) where that adverb occurs.\n    Returns a tuple: (first_adverb_lowercased, positions_list)\n    If no adverb is found, returns (None, []).\n    Positions are 0-based indices based on tokenized words.\n    \"\"\"\n    if sentence is None:\n        return None, []\n    tokens = re.findall(r\"\\b[\\w'-]+\\b\", sentence)\n    first = None\n    for t in tokens:\n        if _is_adverb(t):\n            first = t.lower()\n            break\n    if first is None:\n        return None, []\n    positions = [i for i, t in enumerate(tokens) if t.lower() == first]\n    return first, positions"}
{"task_id": "Mbpp/563", "completion": "def extract_quoted_values(s):\n    \"\"\"\n    Extract all substrings that are enclosed in matching quotation marks\n    (single ' or double \"). Supports escaping with a backslash.\n    Returns a list of strings without the surrounding quotes.\n    \"\"\"\n    values = []\n    i = 0\n    n = len(s)\n    while i < n:\n        c = s[i]\n        if c == '\"' or c == \"'\":\n            quote = c\n            i += 1\n            current = []\n            while i < n:\n                ch = s[i]\n                if ch == '\\\\':\n                    if i + 1 < n:\n                        current.append(s[i + 1])\n                        i += 2\n                        continue\n                    else:\n                        i += 1\n                        continue\n                if ch == quote:\n                    values.append(''.join(current))\n                    i += 1\n                    break\n                else:\n                    current.append(ch)\n                    i += 1\n            # If no closing quote is found, skip\n        else:\n            i += 1\n    return values"}
{"task_id": "Mbpp/565", "completion": "def split_string_into_characters(s):\n    \"\"\"Split a string into its characters and return as a list.\"\"\"\n    return list(s)"}
{"task_id": "Mbpp/562", "completion": "def longest_sublist_length(list_of_sublists):\n    \"\"\"\n    Returns the length of the longest sublist (list or tuple) in list_of_sublists.\n    If there are no sublists, returns 0.\n    \"\"\"\n    max_len = 0\n    for sub in list_of_sublists:\n        if isinstance(sub, (list, tuple)):\n            l = len(sub)\n            if l > max_len:\n                max_len = l\n    return max_len"}
{"task_id": "Mbpp/568", "completion": "def create_list_of_empty_dicts(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return [{} for _ in range(n)]"}
{"task_id": "Mbpp/556", "completion": "def count_pairs_with_odd_xor(nums):\n    \"\"\"\n    Count number of pairs (i, j) with i < j and nums[i] ^ nums[j] is odd.\n    XOR is odd iff one number is even and the other is odd.\n    Therefore, answer = (#even) * (#odd).\n    \"\"\"\n    nums = list(nums)\n    even = sum(1 for x in nums if (x & 1) == 0)\n    odd = len(nums) - even\n    return even * odd"}
{"task_id": "Mbpp/569", "completion": "def sort_sublists_of_strings(data):\n    return [sorted(sub) for sub in data]"}
{"task_id": "Mbpp/468", "completion": "def max_product_increasing_subsequence(arr):\n    \"\"\"\n    Returns the maximum product obtainable by multiplying numbers of an increasing subsequence\n    (strictly increasing) of the given array. Subsequence length can be 1.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n    max_end = [0] * n\n    min_end = [0] * n\n    best = float('-inf')\n    for i in range(n):\n        max_end[i] = arr[i]\n        min_end[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                a = max_end[j] * arr[i]\n                b = min_end[j] * arr[i]\n                max_end[i] = max(max_end[i], a, b)\n                min_end[i] = min(min_end[i], a, b)\n        if max_end[i] > best:\n            best = max_end[i]\n    return best"}
{"task_id": "Mbpp/576", "completion": "def is_sublist(sub, lst):\n    \"\"\"\n    Return True if 'sub' appears as a contiguous subsequence (sublist) of 'lst'.\n    An empty list is considered a sublist of any list.\n    \"\"\"\n    if not isinstance(sub, list) or not isinstance(lst, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if not sub:\n        return True\n    m, n = len(sub), len(lst)\n    if m > n:\n        return False\n    for i in range(n - m + 1):\n        if lst[i:i + m] == sub:\n            return True\n    return False"}
{"task_id": "Mbpp/581", "completion": "import math\n\ndef square_pyramid_surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid given the base edge and height.\n    Surface area = base_area + lateral_area\n    base_area = base_edge^2\n    lateral_area = 4 * (1/2 * base_edge * slant_height) = 2 * base_edge * slant_height\n    slant_height l = sqrt((base_edge/2)^2 + height^2)\n    \"\"\"\n    if base_edge < 0 or height < 0:\n        raise ValueError(\"base_edge and height must be non-negative\")\n    slant_height = math.hypot(base_edge / 2.0, height)\n    return base_edge * base_edge + 2.0 * base_edge * slant_height"}
{"task_id": "Mbpp/479", "completion": "def first_digit(n):\n    \"\"\"\n    Return the most significant digit of the given number (based on its absolute value).\n    For zero, returns 0. Works with int and float types.\n    \"\"\"\n    if isinstance(n, bool) or not isinstance(n, (int, float)):\n        raise TypeError(\"n must be an int or float\")\n    n = abs(n)\n    if n == 0:\n        return 0\n    n_int = int(n)\n    while n_int >= 10:\n        n_int //= 10\n    return n_int"}
{"task_id": "Mbpp/587", "completion": "def list_to_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/572", "completion": "from typing import Iterable, List, Any\n\ndef remove_duplicates_from_lists(*lists: Iterable[Any]) -> List[List[Any]]:\n    \"\"\"\n    Remove duplicates within each provided iterable, preserving order.\n    Each input iterable is treated as a separate list.\n    Returns a list of lists with duplicates removed per input, keeping first occurrences.\n    \"\"\"\n    result: List[List[Any]] = []\n    for lst in lists:\n        seen = set()\n        uniq = []\n        for item in lst:\n            if item not in seen:\n                seen.add(item)\n                uniq.append(item)\n        result.append(uniq)\n    return result"}
{"task_id": "Mbpp/409", "completion": "def min_product_of_two_numbers(nums):\n    \"\"\"\n    Return the minimum product obtainable by multiplying any two distinct numbers from nums.\n    Handles integers and floats, including negatives and zeros.\n    Raises ValueError if len(nums) < 2.\n    \"\"\"\n    if nums is None or len(nums) < 2:\n        raise ValueError(\"Need at least two numbers to form a product.\")\n\n    INF = float('inf')\n    NINF = -float('inf')\n\n    # Track two smallest and two largest numbers\n    min1, min2 = INF, INF\n    max1, max2 = NINF, NINF\n\n    # Helpers for negatives/positives\n    neg_min = None   # most negative\n    neg_max = None   # least negative (closest to zero, i.e., max negative)\n    pos_min = None   # smallest positive\n    pos_max = None   # largest positive\n    has_zero = False\n\n    for x in nums:\n        # two smallest\n        if x <= min1:\n            min2 = min1\n            min1 = x\n        elif x < min2:\n            min2 = x\n\n        # two largest\n        if x >= max1:\n            max2 = max1\n            max1 = x\n        elif x > max2:\n            max2 = x\n\n        # classify\n        if x < 0:\n            if neg_min is None or x < neg_min:\n                neg_min = x\n            if neg_max is None or x > neg_max:\n                neg_max = x\n        elif x > 0:\n            if pos_min is None or x < pos_min:\n                pos_min = x\n            if pos_max is None or x > pos_max:\n                pos_max = x\n        else:\n            has_zero = True\n\n    candidates = []\n    if min2 != INF:\n        candidates.append(min1 * min2)\n    if max2 != NINF:\n        candidates.append(max1 * max2)\n    if neg_min is not None and pos_max is not None:\n        candidates.append(neg_min * pos_max)\n    if neg_max is not None and pos_min is not None:\n        candidates.append(neg_max * pos_min)\n    if has_zero:\n        candidates.append(0)\n\n    if not candidates:\n        raise ValueError(\"Unable to determine minimum product.\")\n\n    return min(candidates)"}
{"task_id": "Mbpp/465", "completion": "def drop_empty_items(d: dict, recursive: bool = False) -> dict:\n    \"\"\"\n    Drop entries with empty values from a dictionary.\n    Empty is defined as None, '', [], {}, (), or set().\n    If recursive is True, this is applied recursively to nested dicts and lists.\n    \"\"\"\n    def is_empty(val):\n        if val is None:\n            return True\n        if isinstance(val, (str, bytes)) and len(val) == 0:\n            return True\n        if isinstance(val, (list, tuple, set, dict)) and len(val) == 0:\n            return True\n        return False\n\n    def process_item(val):\n        if isinstance(val, dict) and recursive:\n            return drop(val)\n        if isinstance(val, list) and recursive:\n            new_list = []\n            for item in val:\n                if isinstance(item, dict):\n                    item2 = drop(item)\n                    if not is_empty(item2):\n                        new_list.append(item2)\n                else:\n                    if not is_empty(item):\n                        new_list.append(item)\n            return new_list\n        return val\n\n    def drop(cur):\n        res = {}\n        for k, v in cur.items():\n            if isinstance(v, dict) and recursive:\n                v2 = drop(v)\n                if not is_empty(v2):\n                    res[k] = v2\n            else:\n                v2 = process_item(v)\n                if not is_empty(v2):\n                    res[k] = v2\n        return res\n\n    if not isinstance(d, dict):\n        raise TypeError(\"drop_empty_items expects a dict\")\n    return drop(dict(d))"}
{"task_id": "Mbpp/578", "completion": "def interleave_three_lists(l1, l2, l3):\n    \"\"\"\n    Interleave three lists of identical length into a single flat list.\n    Example: [1, 2], [3, 4], [5, 6] -> [1, 3, 5, 2, 4, 6]\n    \"\"\"\n    if not (isinstance(l1, list) and isinstance(l2, list) and isinstance(l3, list)):\n        raise TypeError(\"All arguments must be lists.\")\n    if len(l1) != len(l2) or len(l2) != len(l3):\n        raise ValueError(\"All lists must have the same length.\")\n    return [item for triple in zip(l1, l2, l3) for item in triple]"}
{"task_id": "Mbpp/577", "completion": "def last_digit_of_factorial(n):\n    \"\"\"\n    Return the last digit of n! for a non-negative integer n.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n >= 5:\n        return 0\n    result = 1\n    for i in range(2, n + 1):\n        result = (result * i) % 10\n    return result"}
{"task_id": "Mbpp/579", "completion": "def find_dissimilar_elements(t1, t2):\n    \"\"\"\n    Return elements that are present in one of the tuples but not in both.\n    The result contains unique elements (order not guaranteed).\n    \"\"\"\n    return list(set(t1) ^ set(t2))"}
{"task_id": "Mbpp/590", "completion": "import math\n\ndef polar_to_rectangular(r, theta, degrees=False):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n    If degrees is True, theta is interpreted in degrees; otherwise radians.\n    Returns a tuple (x, y).\n    \"\"\"\n    if degrees:\n        theta = math.radians(theta)\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)"}
{"task_id": "Mbpp/573", "completion": "def product_of_unique_numbers(nums):\n    unique_vals = set(nums)\n    prod = 1\n    for v in unique_vals:\n        prod *= v\n    return prod"}
{"task_id": "Mbpp/588", "completion": "def max_min_difference(nums):\n    \"\"\"\n    Return the difference between the largest and smallest values in nums.\n    Raises ValueError if nums is empty.\n    \"\"\"\n    if nums is None:\n        raise TypeError(\"nums must not be None\")\n    if len(nums) == 0:\n        raise ValueError(\"Cannot compute difference of empty list\")\n    \n    min_val = max_val = nums[0]\n    for n in nums[1:]:\n        if n < min_val:\n            min_val = n\n        if n > max_val:\n            max_val = n\n    return max_val - min_val"}
{"task_id": "Mbpp/593", "completion": "def remove_ip_leading_zeros(ip: str) -> str:\n    ip = ip.strip()\n    parts = ip.split('.')\n    if len(parts) != 4:\n        return ip\n    cleaned = []\n    for part in parts:\n        if part == '':\n            cleaned.append('0')\n            continue\n        if not part.isdigit():\n            raise ValueError(\"Invalid IP address segment: {!r}\".format(part))\n        cleaned.append(str(int(part)))\n    return '.'.join(cleaned)"}
{"task_id": "Mbpp/591", "completion": "def interchange_first_last(lst):\n    \"\"\"\n    Interchange the first and last elements of the given list in place.\n    If the list has fewer than 2 elements, it is returned unchanged.\n    \"\"\"\n    if len(lst) >= 2:\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"}
{"task_id": "Mbpp/589", "completion": "import math\n\ndef perfect_squares_in_range(a, b):\n    \"\"\"\n    Return a sorted list of perfect squares within the inclusive range [min(a,b), max(a,b)].\n    \"\"\"\n    lo, hi = (a, b) if a <= b else (b, a)\n    if hi < 0:\n        return []\n    if lo < 0:\n        lo = 0\n    m = math.isqrt(lo)\n    if m * m < lo:\n        m += 1\n    n = math.isqrt(hi)\n    if m > n:\n        return []\n    return [i * i for i in range(m, n + 1)]"}
{"task_id": "Mbpp/598", "completion": "def is_armstrong(number: int) -> bool:\n    \"\"\"\n    Check if a non-negative integer is an Armstrong (narcissistic) number.\n    An Armstrong number is equal to the sum of its digits each raised to the power\n    of the number of digits.\n    \"\"\"\n    if number < 0:\n        return False\n    digits = [int(d) for d in str(number)]\n    power = len(digits)\n    total = sum(d ** power for d in digits)\n    return total == number"}
{"task_id": "Mbpp/605", "completion": "def is_prime(n: int) -> bool:\n    \"\"\"\n    Return True if n is a prime number, otherwise False.\n    Handles integers less than 2 as non-prime.\n    Uses 6k +/- 1 optimization for efficiency.\n    \"\"\"\n    if n < 2:\n        return False\n    if n in (2, 3):\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    w = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += w\n        w = 6 - w\n    return True"}
{"task_id": "Mbpp/583", "completion": "def catalan(n):\n    \"\"\"\n    Return the nth Catalan number (0-indexed).\n    C_0 = 1, and C_n = binom(2n, n) / (n + 1).\n    This implementation uses the multiplicative formula to compute binom(2n, n).\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be a non-negative integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    res = 1\n    for k in range(1, n + 1):\n        res = res * (n + k) // k  # binom(2n, n)\n    return res // (n + 1)"}
{"task_id": "Mbpp/602", "completion": "from typing import Optional\n\ndef first_repeated_character(s: str) -> Optional[str]:\n    \"\"\"\n    Returns the first character that repeats in the string when scanned from left to right.\n    If no character repeats, returns None.\n    \"\"\"\n    if s is None:\n        return None\n    seen = set()\n    for ch in s:\n        if ch in seen:\n            return ch\n        seen.add(ch)\n    return None"}
{"task_id": "Mbpp/606", "completion": "def degrees_to_radians(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \"\"\"\n    from math import pi\n    return degrees * pi / 180.0"}
{"task_id": "Mbpp/594", "completion": "def diff_first_even_odd(nums):\n    if nums is None or len(nums) == 0:\n        raise ValueError(\"Input must be a non-empty iterable of integers\")\n    \n    first_even = None\n    first_odd = None\n\n    for n in nums:\n        if isinstance(n, int) and not isinstance(n, bool):\n            if first_even is None and n % 2 == 0:\n                first_even = n\n            if first_odd is None and n % 2 != 0:\n                first_odd = n\n            if first_even is not None and first_odd is not None:\n                break\n\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd integer\")\n\n    return first_even - first_odd"}
{"task_id": "Mbpp/607", "completion": "import re\n\ndef search_regex_in_string(s, pattern, flags=0):\n    \"\"\"\n    Search for the first occurrence of the regex pattern in s.\n    Returns a tuple: (matched_substring, start_index, end_index)\n    If no match is found, returns (None, -1, -1).\n    \"\"\"\n    if s is None or pattern is None:\n        return (None, -1, -1)\n\n    try:\n        # Allow passing either a string pattern or a compiled regex object\n        if hasattr(pattern, \"search\") and callable(pattern.search):\n            regex = pattern\n        else:\n            regex = re.compile(pattern, flags)\n    except re.error:\n        return (None, -1, -1)\n\n    m = regex.search(s)\n    if m:\n        return (m.group(0), m.start(), m.end())\n    else:\n        return (None, -1, -1)"}
{"task_id": "Mbpp/599", "completion": "def sum_and_average(n):\n    \"\"\"\n    Compute the sum and average of the first n natural numbers (1..n).\n    Returns a tuple (total_sum, average).\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    total = n * (n + 1) // 2\n    average = total / n\n    return total, average"}
{"task_id": "Mbpp/604", "completion": "def reverse_words(s: str) -> str:\n    \"\"\"\n    Reverse the order of words in a string. Words are considered sequences\n    separated by whitespace. Consecutive whitespace is treated as a single separator.\n    \"\"\"\n    return ' '.join(s.split()[::-1])"}
{"task_id": "Mbpp/596", "completion": "def tuple_size_in_bytes(t):\n    \"\"\"\n    Return the memory size in bytes of the given tuple object using sys.getsizeof.\n    This size accounts for the tuple object itself, not recursively the sizes of contained objects.\n    \"\"\"\n    import sys\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/586", "completion": "def split_at_n_and_append_first(lst, n):\n    \"\"\"\n    Split lst at the nth element and append the first part to the end.\n    Returns a new list.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    m = len(lst)\n    if m == 0:\n        return []\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    k = n % m\n    return lst[k:] + lst[:k]"}
{"task_id": "Mbpp/610", "completion": "def remove_kth(lst, k):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    if k < 1 or k > len(lst):\n        raise IndexError(\"k out of range\")\n    return lst[:k-1] + lst[k:]"}
{"task_id": "Mbpp/592", "completion": "import math\n\ndef sum_consecutive_binomial_products(n: int) -> int:\n    \"\"\"\n    Returns the sum of products of consecutive binomial coefficients in the nth row:\n    sum_{k=0}^{n-1} C(n, k) * C(n, k+1)\n    For n >= 1, this equals C(2n, n-1). For n <= 0, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    return math.comb(2 * n, n - 1)"}
{"task_id": "Mbpp/612", "completion": "def unzip_pairs(pairs):\n    first = []\n    second = []\n    for pair in pairs:\n        a, b = pair\n        first.append(a)\n        second.append(b)\n    return [first, second]"}
{"task_id": "Mbpp/600", "completion": "def is_even(n):\n    return n % 2 == 0"}
{"task_id": "Mbpp/614", "completion": "def cumulative_sum_of_values_in_tuples(tuple_list):\n    \"\"\"\n    Return the sum of all numeric values contained in a list of tuples.\n    Each element in each tuple is assumed to be a number.\n    \"\"\"\n    return sum(sum(t) for t in tuple_list)"}
{"task_id": "Mbpp/619", "completion": "def move_numbers_to_end(s: str) -> str:\n    non_digits = []\n    digits = []\n    for ch in s:\n        if ch.isdigit():\n            digits.append(ch)\n        else:\n            non_digits.append(ch)\n    return ''.join(non_digits + digits)"}
{"task_id": "Mbpp/624", "completion": "def to_uppercase(s: str) -> str:\n    \"\"\"\n    Convert the input string to uppercase.\n    \"\"\"\n    return s.upper()"}
{"task_id": "Mbpp/615", "completion": "def averages_of_tuples(data):\n    \"\"\"\n    Given a tuple of tuples of numbers, returns a list containing the average of each inner tuple.\n    If an inner tuple is empty, its average is 0.0.\n    \"\"\"\n    return [sum(inner) / len(inner) if inner else 0.0 for inner in data]"}
{"task_id": "Mbpp/628", "completion": "def replace_spaces(s: str) -> str:\n    return s.replace(' ', '%20')"}
{"task_id": "Mbpp/616", "completion": "def elementwise_modulo(a: tuple, b: tuple) -> tuple:\n    if len(a) != len(b):\n        raise ValueError(\"Tuples must have the same length\")\n    return tuple(x % y for x, y in zip(a, b))"}
{"task_id": "Mbpp/608", "completion": "def bell_number(n):\n    \"\"\"\n    Return the nth Bell number B(n) (0-indexed), i.e., the number of partitions of a set of size n.\n    Uses Bell's triangle (Aitken's array) with O(n^2) time and O(n) space.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    prev = [1]  # row 0\n    for i in range(1, n + 1):\n        cur = [0] * (i + 1)\n        cur[0] = prev[-1]  # B[i][0] = B[i-1][i-1]\n        for j in range(1, i + 1):\n            cur[j] = cur[j - 1] + prev[j - 1]\n        prev = cur\n    return prev[0]"}
{"task_id": "Mbpp/597", "completion": "def find_kth_sorted_arrays(A, B, k):\n    \"\"\"\n    Return the k-th smallest element (1-based) from the union of two sorted arrays A and B.\n    Arrays are assumed to be sorted in non-decreasing order.\n    Raises ValueError if k is out of bounds.\n    \"\"\"\n    m, n = len(A), len(B)\n    if k < 1 or k > m + n:\n        raise ValueError(\"k is out of bounds\")\n\n    i = 0  # pointer into A\n    j = 0  # pointer into B\n\n    while True:\n        if i == m:\n            return B[j + k - 1]\n        if j == n:\n            return A[i + k - 1]\n        if k == 1:\n            return A[i] if A[i] <= B[j] else B[j]\n\n        half = k // 2\n        new_i = min(i + half, m) - 1\n        new_j = min(j + half, n) - 1\n\n        if A[new_i] <= B[new_j]:\n            k -= (new_i - i + 1)\n            i = new_i + 1\n        else:\n            k -= (new_j - j + 1)\n            j = new_j + 1"}
{"task_id": "Mbpp/611", "completion": "def max_in_column(matrix, n):\n    \"\"\"\n    Returns the maximum value in the nth column (0-based index) of a matrix\n    represented as a list of lists.\n    All rows must have at least n+1 elements and contain numeric values.\n    \"\"\"\n    if not isinstance(matrix, list) or len(matrix) == 0:\n        raise ValueError(\"matrix must be a non-empty list of lists\")\n    if not isinstance(n, int):\n        raise ValueError(\"column index must be an integer\")\n    values = []\n    for i, row in enumerate(matrix):\n        if not isinstance(row, list):\n            raise ValueError(\"matrix must be a list of lists\")\n        if n < 0 or n >= len(row):\n            raise ValueError(\"column index out of range in row {}\".format(i))\n        val = row[n]\n        if not isinstance(val, (int, float)):\n            raise ValueError(\"matrix elements must be numeric\")\n        values.append(val)\n    if not values:\n        raise ValueError(\"no values found in specified column\")\n    return max(values)"}
{"task_id": "Mbpp/618", "completion": "def elementwise_divide(a, b):\n    \"\"\"\n    Divide two lists element-wise: return a new list where result[i] = a[i] / b[i].\n    Raises:\n      ValueError if lengths differ\n      TypeError if inputs are not lists or elements are non-numeric\n      ZeroDivisionError if any division by zero occurs\n    \"\"\"\n    if not isinstance(a, list) or not isinstance(b, list):\n        raise TypeError(\"Both inputs must be lists.\")\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length.\")\n    result = []\n    for i, (x, y) in enumerate(zip(a, b)):\n        if not isinstance(x, (int, float)) or not isinstance(y, (int, float)):\n            raise TypeError(f\"Non-numeric values at index {i}: {type(x)} and {type(y)}\")\n        if y == 0:\n            raise ZeroDivisionError(f\"Division by zero at index {i}.\")\n        result.append(x / y)\n    return result"}
{"task_id": "Mbpp/585", "completion": "def top_n_expensive(items, n, price_key='price'):\n    \"\"\"\n    Return the n items with the highest price from a dataset.\n\n    The dataset can be:\n      - a list of dictionaries with a price field (price_key or common keys),\n      - objects with an attribute named price_key,\n      - sequences like (id, price) where price is the second element.\n\n    Parameters:\n      items: iterable of items\n      n: number of top items to return\n      price_key: key/name used to fetch price from dict or attribute (optional)\n\n    Returns:\n      List of top-n items by price. Items without a retrievable price are ignored.\n    \"\"\"\n    if n is None or not isinstance(n, int) or n <= 0:\n        return []\n\n    def extract_price(item):\n        # dict\n        if isinstance(item, dict):\n            if price_key is not None and price_key in item:\n                return item[price_key]\n            for k in ('price', 'cost', 'amount', 'value'):\n                if k in item:\n                    return item[k]\n            raise KeyError(\"Price not found in dict item.\")\n        # attribute\n        if price_key is not None and hasattr(item, price_key):\n            return getattr(item, price_key)\n        for k in ('price', 'cost', 'amount', 'value'):\n            if hasattr(item, k):\n                return getattr(item, k)\n        # sequence-like: assume (id, price)\n        if isinstance(item, (list, tuple)) and len(item) >= 2:\n            p = item[1]\n            if isinstance(p, (int, float)):\n                return p\n        raise TypeError(\"Cannot extract price from item: {}\".format(item))\n\n    priced = []\n    for it in items:\n        try:\n            pr = extract_price(it)\n            priced.append((pr, it))\n        except Exception:\n            continue\n\n    if not priced:\n        return []\n\n    priced.sort(key=lambda x: x[0], reverse=True)\n    top = priced[:n]\n    return [item for _, item in top]"}
{"task_id": "Mbpp/580", "completion": "def remove_uneven_elements(nested):\n    \"\"\"\n    Recursively remove odd integers from a nested structure of lists/tuples.\n    Preserves the original nesting. Empty containers resulting from removals are dropped.\n    \"\"\"\n    def _process(obj):\n        if isinstance(obj, int):\n            return obj if obj % 2 == 0 else None\n        if isinstance(obj, tuple):\n            processed = [_process(item) for item in obj]\n            processed = [p for p in processed if p is not None]\n            cleaned = []\n            for p in processed:\n                if isinstance(p, (list, tuple)) and len(p) == 0:\n                    continue\n                cleaned.append(p)\n            return tuple(cleaned)\n        if isinstance(obj, list):\n            processed = [_process(item) for item in obj]\n            processed = [p for p in processed if p is not None]\n            cleaned = []\n            for p in processed:\n                if isinstance(p, (list, tuple)) and len(p) == 0:\n                    continue\n                cleaned.append(p)\n            return cleaned\n        return obj\n\n    return _process(nested)"}
{"task_id": "Mbpp/635", "completion": "def sort_list(lst, key=None, reverse=False):\n    \"\"\"\n    Sorts the given list in-place and returns it.\n    - lst: list to sort\n    - key: optional callable to extract comparison key\n    - reverse: if True, sorts in descending order\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    lst.sort(key=key, reverse=reverse)\n    return lst"}
{"task_id": "Mbpp/632", "completion": "def move_zeroes_to_end(nums):\n    \"\"\"\n    Move all zeros to the end of the list in-place, preserving the order of non-zero elements.\n    Returns the modified list.\n    \"\"\"\n    insert_pos = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[insert_pos] = nums[i]\n            insert_pos += 1\n    for i in range(insert_pos, len(nums)):\n        nums[i] = 0\n    return nums"}
{"task_id": "Mbpp/630", "completion": "def adjacent_coords(coord, diagonals=False):\n    \"\"\"\n    Return adjacent coordinates for a 2D point.\n    By default returns 4-neighborhood (up, down, left, right).\n    If diagonals is True, include diagonal neighbors.\n    \"\"\"\n    x, y = coord\n    if diagonals:\n        deltas = [(-1, 0), (1, 0), (0, -1), (0, 1),\n                  (-1, -1), (-1, 1), (1, -1), (1, 1)]\n    else:\n        deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    return [(x + dx, y + dy) for dx, dy in deltas]"}
{"task_id": "Mbpp/629", "completion": "def find_even_numbers(nums):\n    \"\"\"Return a list of even integers from the input list.\"\"\"\n    return [n for n in nums if isinstance(n, int) and not isinstance(n, bool) and n % 2 == 0]"}
{"task_id": "Mbpp/626", "completion": "def largest_triangle_area_semicircle(radius):\n    \"\"\"\n    Area of the largest triangle inscribed in a semicircle of radius 'radius'.\n    The maximum area is R^2, achieved by using the diameter as the base\n    and the apex at the top of the semicircle.\n    \"\"\"\n    try:\n        R = float(radius)\n    except (TypeError, ValueError):\n        raise ValueError(\"radius must be a real number\")\n    if R <= 0:\n        return 0.0\n    return R * R"}
{"task_id": "Mbpp/643", "completion": "def contains_z_not_at_ends(s: str) -> bool:\n    \"\"\"\n    Returns True if the string s contains the character 'z'\n    somewhere other than the first or last position.\n    \"\"\"\n    return 'z' in s[1:-1]"}
{"task_id": "Mbpp/623", "completion": "def nth_powers(nums, n):\n    \"\"\"\n    Return a list with each element of nums raised to the n-th power.\n    n must be an integer.\n    \"\"\"\n    try:\n        exp = int(n)\n    except Exception:\n        raise TypeError(\"Exponent must be an integer.\")\n    if exp != n:\n        raise TypeError(\"Exponent must be an integer.\")\n    return [x ** exp for x in nums]"}
{"task_id": "Mbpp/637", "completion": "def is_break_even(cost_price, selling_price):\n    \"\"\"\n    Check if there is no profit and no loss (break-even).\n    Returns True if selling_price equals cost_price, otherwise False.\n    \"\"\"\n    return selling_price == cost_price"}
{"task_id": "Mbpp/631", "completion": "def swap_spaces_and_underscores(s: str) -> str:\n    \"\"\"\n    Swap spaces and underscores in the input string.\n    Spaces become underscores and underscores become spaces.\n    \"\"\"\n    return s.translate(str.maketrans({' ': '_', '_': ' '}))"}
{"task_id": "Mbpp/641", "completion": "def nth_nonagonal(n):\n    \"\"\"\n    Return the nth nonagonal (9-gonal) number.\n    N(n) = n*(7n - 5)/2\n    n must be a positive integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/724", "completion": "def sum_digits_of_power(base, power):\n    \"\"\"\n    Compute the sum of digits of (base ** power).\n    Both base and power should be integers, with power >= 0.\n    Returns the sum of digits as an integer.\n    \"\"\"\n    if not isinstance(base, int) or not isinstance(power, int):\n        raise TypeError(\"base and power must be integers\")\n    if power < 0:\n        raise ValueError(\"power must be non-negative\")\n\n    value = pow(base, power)\n    return sum(int(ch) for ch in str(abs(value)))"}
{"task_id": "Mbpp/728", "completion": "def add_vectors(a: list, b: list) -> list:\n    if len(a) != len(b):\n        raise ValueError(\"Input lists must have the same length.\")\n    return [x + y for x, y in zip(a, b)]"}
{"task_id": "Mbpp/723", "completion": "def count_matching_indices(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Input sequences must have the same length.\")\n    return sum(1 for x, y in zip(a, b) if x == y)"}
{"task_id": "Mbpp/720", "completion": "def add_dict_to_tuple(tup, dct):\n    \"\"\"\n    Return a new tuple with the given dictionary appended to the end.\n    Validates inputs: tup must be a tuple, dct must be a dict.\n    \"\"\"\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    if not isinstance(dct, dict):\n        raise TypeError(\"dct must be a dict\")\n    return tup + (dct,)"}
{"task_id": "Mbpp/638", "completion": "def wind_chill_index(temperature_c, wind_speed_kmh):\n    \"\"\"\n    Calculate wind chill index (Celsius) for a given temperature and wind speed in km/h.\n    The result is rounded up to the next integer.\n    If wind speed <= 0, the wind chill is the ambient temperature.\n    \"\"\"\n    import math\n\n    t = float(temperature_c)\n    v = float(wind_speed_kmh)\n\n    if v <= 0:\n        return int(math.ceil(t))\n\n    wci = 13.12 + 0.6215 * t - 11.37 * (v ** 0.16) + 0.3965 * t * (v ** 0.16)\n    return int(math.ceil(wci))"}
{"task_id": "Mbpp/722", "completion": "def filter_students_by_minimum(students, min_height, min_weight):\n    \"\"\"\n    Filter students whose height and weight are strictly greater than the given minimums.\n    - students: dict with student name as key and (height, weight) as value\n    - min_height: minimum height threshold\n    - min_weight: minimum weight threshold\n    Returns a dict with the filtered students.\n    \"\"\"\n    return {name: (height, weight) for name, (height, weight) in students.items() if height > min_height and weight > min_weight}"}
{"task_id": "Mbpp/726", "completion": "def pairwise_product(t: tuple) -> tuple:\n    \"\"\"\n    Given a tuple t of numbers (t_1, ..., t_{N+1}),\n    return a tuple of length N where each element is t_i * t_{i+1}.\n    \"\"\"\n    return tuple(a * b for a, b in zip(t, t[1:]))"}
{"task_id": "Mbpp/730", "completion": "def remove_consecutive_duplicates(lst):\n    \"\"\"\n    Return a new list with consecutive duplicates removed from the input list.\n    Consecutive duplicates are collapsed to a single occurrence.\n    \"\"\"\n    if not lst:\n        return []\n    result = [lst[0]]\n    for item in lst[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result"}
{"task_id": "Mbpp/639", "completion": "def sum_lengths_of_names(names):\n    total = 0\n    for n in names:\n        if isinstance(n, str) and n and n[0].islower():\n            continue\n        if isinstance(n, str):\n            total += len(n)\n    return total"}
{"task_id": "Mbpp/733", "completion": "def first_occurrence_index(arr, target):\n    \"\"\"\n    Return the index of the first occurrence of target in a sorted array.\n    If target is not present, return -1.\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    index = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] >= target:\n            if arr[mid] == target:\n                index = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    return index"}
{"task_id": "Mbpp/644", "completion": "def reverse_upto(arr, pos):\n    if arr is None:\n        return arr\n    n = len(arr)\n    if n == 0:\n        return arr\n    end = min(int(pos), n - 1)\n    if end < 0:\n        return arr\n    i, j = 0, end\n    while i < j:\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n        j -= 1\n    return arr"}
{"task_id": "Mbpp/622", "completion": "def median_of_two_sorted_lists_same_size(a, b):\n    if a is None or b is None:\n        raise ValueError(\"Inputs cannot be None\")\n    n = len(a)\n    if n != len(b):\n        raise ValueError(\"Lists must have the same length\")\n    if n == 0:\n        raise ValueError(\"Lists must be non-empty\")\n\n    low, high = 0, n\n    while low <= high:\n        i = (low + high) // 2\n        j = n - i\n\n        A_left = a[i - 1] if i > 0 else float('-inf')\n        A_right = a[i] if i < n else float('inf')\n        B_left = b[j - 1] if j > 0 else float('-inf')\n        B_right = b[j] if j < n else float('inf')\n\n        if A_left <= B_right and B_left <= A_right:\n            left_max = A_left if A_left > B_left else B_left\n            right_min = A_right if A_right < B_right else B_right\n            return (left_max + right_min) / 2.0\n        elif A_left > B_right:\n            high = i - 1\n        else:\n            low = i + 1\n\n    # Fallback: merge and compute median\n    merged = []\n    i = j = 0\n    while i < n and j < n:\n        if a[i] <= b[j]:\n            merged.append(a[i]); i += 1\n        else:\n            merged.append(b[j]); j += 1\n    while i < n:\n        merged.append(a[i]); i += 1\n    while j < n:\n        merged.append(b[j]); j += 1\n\n    return (merged[n - 1] + merged[n]) / 2.0"}
{"task_id": "Mbpp/603", "completion": "def get_lucid_numbers(limit):\n    if limit < 0:\n        return []\n    result = set()\n    max_len = len(str(limit))\n    # Include all single-digit palindromes (0-9)\n    for d in range(0, 10):\n        if d <= limit:\n            result.add(d)\n    # Generate palindromes of length 2..max_len\n    for length in range(2, max_len + 1):\n        half_len = (length + 1) // 2\n        start = 10 ** (half_len - 1)\n        end = 10 ** half_len\n        for left in range(start, end):\n            left_str = str(left)\n            if length % 2 == 0:\n                pal = int(left_str + left_str[::-1])\n                if pal <= limit:\n                    result.add(pal)\n            else:\n                for mid in range(10):\n                    pal = int(left_str + str(mid) + left_str[::-1])\n                    if pal <= limit:\n                        result.add(pal)\n    return sorted(result)"}
{"task_id": "Mbpp/731", "completion": "import math\n\ndef cone_lateral_surface_area(r, h):\n    return math.pi * r * math.sqrt(r * r + h * h)"}
{"task_id": "Mbpp/740", "completion": "def tuple_to_adjacent_dict(t: tuple) -> dict:\n    \"\"\"\n    Convert a tuple to a dictionary by pairing adjacent elements as key and value.\n    The input tuple must have even length: (k1, v1, k2, v2, ...)\n    \"\"\"\n    if len(t) % 2 != 0:\n        raise ValueError(\"Tuple length must be even to form key-value pairs.\")\n    return {t[i]: t[i + 1] for i in range(0, len(t), 2)}"}
{"task_id": "Mbpp/736", "completion": "def left_insertion_point(arr, x):\n    \"\"\"\n    Return the index where x should be inserted in arr to maintain non-decreasing order.\n    This is the left insertion point (bisect_left).\n    \"\"\"\n    lo, hi = 0, len(arr)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo"}
{"task_id": "Mbpp/737", "completion": "import re\n\ndef starts_with_vowel(s: str) -> bool:\n    \"\"\"\n    Check if the input string starts with a vowel using a regular expression.\n    Returns True if it starts with A, E, I, O, or U (case-insensitive), else False.\n    \"\"\"\n    return bool(re.match(r'^[aeiou]', s, re.IGNORECASE))"}
{"task_id": "Mbpp/743", "completion": "from typing import List, TypeVar\n\nT = TypeVar('T')\n\ndef rotate_right(lst: List[T], k: int) -> List[T]:\n    \"\"\"\n    Rotate a list to the right by k positions and return a new list.\n    The original list remains unmodified.\n    \"\"\"\n    n = len(lst)\n    if n == 0:\n        return []\n    k %= n\n    if k == 0:\n        return lst[:]\n    return lst[-k:] + lst[:-k]"}
{"task_id": "Mbpp/741", "completion": "def are_all_chars_same(s: str) -> bool:\n    return len(set(s)) <= 1"}
{"task_id": "Mbpp/633", "completion": "def sum_pairwise_xor(nums):\n    \"\"\"\n    Compute sum_{i<j} (nums[i] ^ nums[j]).\n    Assumes non-negative integers.\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        return 0\n    max_bit = max((x.bit_length() for x in nums), default=0)\n    total = 0\n    for b in range(max_bit + 1):\n        c1 = sum((x >> b) & 1 for x in nums)\n        total += c1 * (n - c1) * (1 << b)\n    return total"}
{"task_id": "Mbpp/734", "completion": "def sum_of_subarray_products(arr: list) -> int:\n    \"\"\"\n    Returns the sum of products of all contiguous subarrays of the input list `arr`.\n    \"\"\"\n    total = 0\n    end = 0  # sum of products of subarrays ending at the current position\n    for x in arr:\n        end = x * (end + 1)\n        total += end\n    return total"}
{"task_id": "Mbpp/620", "completion": "def largest_divisible_subset_size(nums):\n    \"\"\"\n    Returns the size of the largest subset of nums such that for every pair (a, b)\n    in the subset, either a divides b or b divides a (i.e., a % b == 0 or b % a == 0).\n    Uses a dynamic programming approach after sorting (Largest Divisible Subset).\n    At most one zero can be included, since 0 divides only 0 and 0%0 is undefined.\n    \"\"\"\n    if not nums:\n        return 0\n    nums = sorted(nums)\n    n = len(nums)\n    dp = [1] * n\n    max_len = 1\n    for i in range(n):\n        for j in range(i):\n            if nums[j] != 0 and nums[i] % nums[j] == 0:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n        if dp[i] > max_len:\n            max_len = dp[i]\n    return max_len"}
{"task_id": "Mbpp/732", "completion": "def replace_with_colon(text: str) -> str:\n    \"\"\"Replace spaces, commas, and dots with a colon.\"\"\"\n    return text.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))"}
{"task_id": "Mbpp/725", "completion": "def extract_values_between_quotes(s):\n    \"\"\"\n    Extract substrings between double quotes in the input string, handling escaped quotes.\n    Returns a list of substrings (without surrounding quotes).\n    \"\"\"\n    results = []\n    current = []\n    in_quotes = False\n    escaping = False\n\n    for ch in s:\n        if escaping:\n            current.append(ch)\n            escaping = False\n        elif ch == '\\\\':\n            if in_quotes:\n                escaping = True\n            else:\n                # Backslash outside quotes has no effect\n                pass\n        elif ch == '\"':\n            if in_quotes:\n                results.append(''.join(current))\n                current = []\n                in_quotes = False\n            else:\n                in_quotes = True\n        else:\n            if in_quotes:\n                current.append(ch)\n\n    return results"}
{"task_id": "Mbpp/750", "completion": "def add_tuple_to_list(lst, tup):\n    lst.append(tup)\n    return lst"}
{"task_id": "Mbpp/744", "completion": "def has_none_in_tuple(t: tuple) -> bool:\n    \"\"\"\n    Check whether the given tuple (and nested tuples inside it) contains a None value.\n    Returns True if at least one element is None, otherwise False.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    for item in t:\n        if item is None:\n            return True\n        if isinstance(item, tuple):\n            if has_none_in_tuple(item):\n                return True\n    return False"}
{"task_id": "Mbpp/735", "completion": "def toggle_bits_except_first_last(n: int) -> int:\n    \"\"\"\n    Toggle all bits of n except the most significant (first) and least significant (last) bits.\n    If n has less than 3 bits (bit length <= 2), the number remains unchanged.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    bl = n.bit_length()\n    if bl <= 2:\n        return n\n    mask = ((1 << (bl - 2)) - 1) << 1\n    return n ^ mask"}
{"task_id": "Mbpp/751", "completion": "def is_min_heap(arr):\n    \"\"\"\n    Check if the given list represents a min-heap (0-indexed array representation).\n    Returns True if every node is <= its children.\n    \"\"\"\n    n = len(arr)\n    for i in range(n // 2):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    return True"}
{"task_id": "Mbpp/754", "completion": "def common_by_index(l1, l2, l3):\n    n = min(len(l1), len(l2), len(l3))\n    return [l1[i] for i in range(n) if l1[i] == l2[i] == l3[i]]"}
{"task_id": "Mbpp/745", "completion": "def find_self_dividing_numbers(startnum, endnum):\n    lo, hi = (startnum, endnum)\n    if lo > hi:\n        lo, hi = hi, lo\n    result = []\n    for n in range(lo, hi + 1):\n        m = abs(n)\n        if m == 0:\n            continue\n        s = str(m)\n        if '0' in s:\n            continue\n        if all(m % int(ch) == 0 for ch in s):\n            result.append(n)\n    return result"}
{"task_id": "Mbpp/721", "completion": "def max_average_path(grid):\n    if not grid or not grid[0]:\n        return 0.0, []\n    rows = len(grid)\n    cols = len(grid[0])\n\n    dp = [[0] * cols for _ in range(rows)]\n    parent = [[None] * cols for _ in range(rows)]\n\n    dp[0][0] = grid[0][0]\n\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                continue\n            if i == 0:\n                dp[i][j] = dp[i][j - 1] + grid[i][j]\n                parent[i][j] = (i, j - 1)\n            elif j == 0:\n                dp[i][j] = dp[i - 1][j] + grid[i][j]\n                parent[i][j] = (i - 1, j)\n            else:\n                if dp[i - 1][j] >= dp[i][j - 1]:\n                    dp[i][j] = dp[i - 1][j] + grid[i][j]\n                    parent[i][j] = (i - 1, j)\n                else:\n                    dp[i][j] = dp[i][j - 1] + grid[i][j]\n                    parent[i][j] = (i, j - 1)\n\n    max_sum = dp[rows - 1][cols - 1]\n    path = []\n    i, j = rows - 1, cols - 1\n    while True:\n        path.append((i, j))\n        if i == 0 and j == 0:\n            break\n        pi, pj = parent[i][j]\n        i, j = pi, pj\n    path.reverse()\n\n    length = rows + cols - 1\n    average = max_sum / length\n    return average, path"}
{"task_id": "Mbpp/742", "completion": "def tetrahedron_surface_area(vertices):\n    \"\"\"\n    Compute the total surface area of a tetrahedron given its four 3D vertices.\n    vertices: iterable of four points, each a sequence of 3 numbers (x, y, z).\n    Returns a float representing the surface area.\n    \"\"\"\n    verts = list(vertices)\n    if len(verts) != 4:\n        raise ValueError(\"Exactly four vertices are required.\")\n    pts = []\n    for p in verts:\n        if len(p) != 3:\n            raise ValueError(\"Each vertex must be a 3D point with 3 coordinates.\")\n        pts.append(tuple(float(coord) for coord in p))\n\n    def vec(a, b):\n        return (b[0]-a[0], b[1]-a[1], b[2]-a[2])\n\n    def cross(u, v):\n        return (u[1]*v[2]-u[2]*v[1],\n                u[2]*v[0]-u[0]*v[2],\n                u[0]*v[1]-u[1]*v[0])\n\n    def norm(u):\n        return (u[0]**2 + u[1]**2 + u[2]**2) ** 0.5\n\n    def tri_area(a, b, c):\n        ab = vec(a, b)\n        ac = vec(a, c)\n        return norm(cross(ab, ac)) * 0.5\n\n    a, b, c, d = pts\n    area = tri_area(a, b, c) + tri_area(a, b, d) + tri_area(a, c, d) + tri_area(b, c, d)\n    return area"}
{"task_id": "Mbpp/757", "completion": "from collections import Counter\n\ndef count_reverse_pairs(strings):\n    \"\"\"\n    Count pairs of strings where one is the reverse of the other.\n    Palindromic strings contribute C(n, 2) pairs for their occurrences.\n    \"\"\"\n    freq = Counter(strings)\n    count = 0\n    for s in freq:\n        rev = s[::-1]\n        if rev in freq:\n            if s == rev:\n                n = freq[s]\n                count += n * (n - 1) // 2\n            elif s < rev:\n                count += freq[s] * freq[rev]\n    return count"}
{"task_id": "Mbpp/762", "completion": "def has_30_days(month):\n    \"\"\"\n    Returns True if the given month (1-12) has 30 days, otherwise False.\n    Months with 30 days: April(4), June(6), September(9), November(11)\n    \"\"\"\n    return month in (4, 6, 9, 11)"}
{"task_id": "Mbpp/749", "completion": "from typing import List\n\ndef sort_numeric_strings(nums: List[str]) -> List[str]:\n    \"\"\"\n    Sort a list of numeric strings by their numeric value in ascending order.\n    \"\"\"\n    return sorted(nums, key=lambda s: int(s))"}
{"task_id": "Mbpp/764", "completion": "def count_digits(s: str) -> int:\n    \"\"\"\n    Return the number of digit characters (0-9) in the input string.\n    \"\"\"\n    return sum(1 for ch in s if '0' <= ch <= '9')"}
{"task_id": "Mbpp/753", "completion": "def min_k_records(tuple_list, k):\n    \"\"\"\n    Return the k smallest tuples from tuple_list using lexicographic order.\n    If k <= 0, return an empty list.\n    If k >= len(tuple_list), return the entire list sorted.\n    \"\"\"\n    if k <= 0:\n        return []\n    import heapq\n    return heapq.nsmallest(k, tuple_list)"}
{"task_id": "Mbpp/766", "completion": "from typing import List, Tuple, Any\n\ndef consecutive_pairs(items: List[Any]) -> List[Tuple[Any, Any]]:\n    return [(items[i], items[i + 1]) for i in range(len(items) - 1)]"}
{"task_id": "Mbpp/760", "completion": "def has_only_one_distinct_element(nums):\n    return len(set(nums)) == 1"}
{"task_id": "Mbpp/763", "completion": "def minimum_difference(arr):\n    \"\"\"\n    Returns the minimum absolute difference between any two elements in arr.\n    If fewer than 2 elements, raises ValueError.\n    \"\"\"\n    if arr is None:\n        raise ValueError(\"Input array must not be None\")\n    n = len(arr)\n    if n < 2:\n        raise ValueError(\"At least two elements are required to compute a difference.\")\n    a = sorted(arr)\n    min_diff = a[1] - a[0]\n    if min_diff == 0:\n        return 0\n    for i in range(1, n - 1):\n        diff = a[i + 1] - a[i]\n        if diff < min_diff:\n            min_diff = diff\n            if min_diff == 0:\n                break\n    return min_diff"}
{"task_id": "Mbpp/752", "completion": "def jacobsthal(n):\n    \"\"\"\n    Return the nth Jacobsthal number.\n    J(0) = 0, J(1) = 1, J(n) = J(n-1) + 2*J(n-2) for n >= 2\n    Uses closed-form: J(n) = (2^n - (-1)^n) / 3\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return ((1 << n) - ((-1) ** n)) // 3"}
{"task_id": "Mbpp/748", "completion": "def split_camel_case(s: str) -> str:\n    \"\"\"\n    Insert spaces before words that start with a capital letter in a camel-cased string.\n    Example: \"ThisIsATest\" -> \"This Is A Test\"\n    Avoids inserting extra spaces if words are already separated by spaces.\n    \"\"\"\n    import re\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    # Insert a space before a capital letter that starts a new word, but only if not at the start\n    # and not already preceded by whitespace\n    pattern = r'(?<!^)(?<!\\s)(?=[A-Z][a-z])'\n    return re.sub(pattern, ' ', s)"}
{"task_id": "Mbpp/771", "completion": "def is_balanced(expression: str) -> bool:\n    if not expression:\n        return True\n\n    stack = []\n    opening = {'(', '[', '{'}\n    matching = {')': '(', ']': '[', '}': '{'}\n\n    for ch in expression:\n        if ch in opening:\n            stack.append(ch)\n        elif ch in matching:\n            if not stack or stack[-1] != matching[ch]:\n                return False\n            stack.pop()\n\n    return not stack"}
{"task_id": "Mbpp/775", "completion": "def all_odd_indices_are_odd(nums):\n    \"\"\"\n    Return True if every element at odd indices (1, 3, 5, ...) in nums is odd.\n    \"\"\"\n    return all(isinstance(x, int) and x % 2 != 0 for x in (nums[i] for i in range(1, len(nums), 2)))"}
{"task_id": "Mbpp/769", "completion": "from typing import Iterable, List, TypeVar\n\nT = TypeVar('T')\n\ndef list_difference(a: List[T], b: Iterable[T]) -> List[T]:\n    \"\"\"\n    Return elements in list a that are not in list b.\n    Preserves the order of a and keeps duplicates from a.\n    If elements in b are unhashable, falls back to a linear search.\n    \"\"\"\n    try:\n        b_set = set(b)\n        return [x for x in a if x not in b_set]\n    except TypeError:\n        b_list = list(b)\n        return [x for x in a if x not in b_list]"}
{"task_id": "Mbpp/759", "completion": "def is_decimal_with_precision_two(s: str) -> bool:\n    if not isinstance(s, str):\n        return False\n    s = s.strip()\n    if not s:\n        return False\n    import re\n    return bool(re.fullmatch(r'[+-]?\\d+\\.\\d{2}', s))"}
{"task_id": "Mbpp/755", "completion": "def second_smallest(nums):\n    \"\"\"\n    Return the second smallest distinct number from the input list.\n    Raises ValueError if there are fewer than two distinct numbers.\n    \"\"\"\n    if nums is None:\n        raise ValueError(\"Input must be a non-empty list of numbers\")\n\n    min1 = None\n    min2 = None\n\n    for x in nums:\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be numbers\")\n\n        if min1 is None or x < min1:\n            min2 = min1\n            min1 = x\n        elif x != min1 and (min2 is None or x < min2):\n            min2 = x\n\n    if min2 is None:\n        raise ValueError(\"List must contain at least two distinct numbers\")\n\n    return min2"}
{"task_id": "Mbpp/777", "completion": "def sum_of_non_repeated_elements(lst):\n    \"\"\"\n    Return the sum of elements that appear exactly once in the input list.\n    Assumes elements are hashable.\n    \"\"\"\n    from collections import Counter\n    counts = Counter(lst)\n    return sum(x for x, c in counts.items() if c == 1)"}
{"task_id": "Mbpp/767", "completion": "def count_pairs_with_sum(nums, target):\n    counts = {}\n    total = 0\n    for x in nums:\n        total += counts.get(target - x, 0)\n        counts[x] = counts.get(x, 0) + 1\n    return total"}
{"task_id": "Mbpp/778", "completion": "def pack(iterable):\n    \"\"\"\n    Pack consecutive duplicates of the elements of 'iterable' into sublists.\n    Example: pack([1,1,2,3,3,3]) -> [[1, 1], [2], [3, 3, 3]]\n    \"\"\"\n    from itertools import groupby\n    return [list(group) for _, group in groupby(iterable)]"}
{"task_id": "Mbpp/787", "completion": "def matches_a_followed_by_three_b(s: str) -> bool:\n    return 'abbb' in s"}
{"task_id": "Mbpp/786", "completion": "def find_right_insertion_point(sorted_list, value):\n    \"\"\"\n    Return the index where 'value' should be inserted to maintain non-decreasing order.\n    This is equivalent to the right-side insertion point (like bisect_right).\n    \"\"\"\n    left, right = 0, len(sorted_list)\n    while left < right:\n        mid = (left + right) // 2\n        if sorted_list[mid] <= value:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/790", "completion": "def are_even_indices_even(lst):\n    return all(isinstance(lst[i], int) and lst[i] % 2 == 0 for i in range(0, len(lst), 2))"}
{"task_id": "Mbpp/780", "completion": "def sums_by_combination(tuple_list):\n    \"\"\"\n    Return all possible sums by selecting one element from each tuple/list in tuple_list.\n    Example: [(1,2), (3,4)] -> [4, 5, 5, 6]\n    \"\"\"\n    if not tuple_list:\n        return []\n    for t in tuple_list:\n        if not isinstance(t, (tuple, list)):\n            raise TypeError(\"All elements must be tuples or lists.\")\n        if len(t) == 0:\n            return []\n    from itertools import product\n    return [sum(comb) for comb in product(*tuple_list)]"}
{"task_id": "Mbpp/781", "completion": "import math\n\ndef is_divisor_count_even(n: int) -> bool:\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    r = math.isqrt(n)\n    return r * r != n"}
{"task_id": "Mbpp/773", "completion": "def find_substring_occurrences(text, substrings):\n    \"\"\"\n    Find all overlapping occurrences of substrings within text.\n    Returns a dict mapping each substring to a list of starting indices where it occurs.\n    If none of the substrings occur, returns None.\n    \"\"\"\n    if text is None:\n        return None\n    if isinstance(substrings, str):\n        substrings = [substrings]\n    try:\n        iter(substrings)\n    except TypeError:\n        return None\n    results = {}\n    seen = set()\n    text_str = str(text)\n    for sub in substrings:\n        if not isinstance(sub, str) or sub == \"\":\n            continue\n        if sub in seen:\n            continue\n        seen.add(sub)\n        positions = []\n        start = 0\n        while True:\n            idx = text_str.find(sub, start)\n            if idx == -1:\n                break\n            positions.append(idx)\n            start = idx + 1  # allow overlapping occurrences\n        if positions:\n            results[sub] = positions\n    return results if results else None"}
{"task_id": "Mbpp/784", "completion": "def product_of_first_even_and_odd(nums):\n    \"\"\"\n    Returns the product of the first even and first odd integers found in the list `nums`.\n    Non-integer elements are ignored. If the list does not contain at least one even and one odd integer,\n    a ValueError is raised.\n    \"\"\"\n    first_even = None\n    first_odd = None\n    for x in nums:\n        if isinstance(x, bool):\n            continue  # Ignore booleans\n        if isinstance(x, int):\n            if first_even is None and x % 2 == 0:\n                first_even = x\n            elif first_odd is None and x % 2 != 0:\n                first_odd = x\n            if first_even is not None and first_odd is not None:\n                break\n    if first_even is None or first_odd is None:\n        raise ValueError(\"List must contain at least one even and one odd integer.\")\n    return first_even * first_odd"}
{"task_id": "Mbpp/791", "completion": "def remove_tuples_from_tuple(t: tuple) -> tuple:\n    \"\"\"\n    Return a new tuple containing only non-tuple elements from the input tuple.\n    Top-level elements that are tuples are removed.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return tuple(item for item in t if not isinstance(item, tuple))"}
{"task_id": "Mbpp/772", "completion": "def remove_words_with_k_length(text, k):\n    \"\"\"\n    Remove all words of length k from the input string.\n    A word is defined as a sequence of non-whitespace characters separated by whitespace.\n    The function returns a new string with remaining words joined by a single space.\n    \"\"\"\n    if k <= 0:\n        return text\n    words = text.split()\n    return ' '.join(w for w in words if len(w) != k)"}
{"task_id": "Mbpp/793", "completion": "def last_position(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] <= target:\n            if arr[mid] == target:\n                result = mid\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result"}
{"task_id": "Mbpp/758", "completion": "def count_lists_in_list(lst):\n    \"\"\"\n    Recursively count all lists found in lst (including lst itself).\n    Each list is converted to a tuple (with nested lists converted similarly),\n    and the dictionary maps that tuple to the number of times that list content occurs\n    in the input structure.\n    \"\"\"\n    from collections import defaultdict\n\n    def freeze(item):\n        if isinstance(item, list):\n            return tuple(freeze(e) for e in item)\n        return item\n\n    counts = defaultdict(int)\n\n    def dfs(x):\n        if not isinstance(x, list):\n            return\n        frozen = freeze(x)\n        counts[frozen] += 1\n        for y in x:\n            if isinstance(y, list):\n                dfs(y)\n\n    if isinstance(lst, list):\n        dfs(lst)\n\n    return dict(counts)"}
{"task_id": "Mbpp/792", "completion": "def count_lists_in_list(lst):\n    \"\"\"\n    Count how many elements of the input list are themselves lists.\n\n    Parameters:\n        lst (list): A list containing elements, some of which may be lists.\n\n    Returns:\n        int: The number of elements that are lists.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list.\")\n    return sum(1 for item in lst if isinstance(item, list))"}
{"task_id": "Mbpp/798", "completion": "def sum_array(arr):\n    \"\"\"Return the sum of numeric values in the given array-like iterable.\"\"\"\n    total = 0\n    for x in arr:\n        total += x\n    return total"}
{"task_id": "Mbpp/797", "completion": "def sum_odd_naturals_in_range(l: int, r: int) -> int:\n    \"\"\"\n    Return sum of all odd natural numbers in the inclusive range [l, r].\n    If the range contains no natural odd numbers, returns 0.\n    \"\"\"\n    if l > r:\n        return 0\n    L = max(l, 1)\n    if L > r:\n        return 0\n    sum_up_to_r = ((r + 1) // 2) ** 2\n    sum_up_to_before_L = (L // 2) ** 2\n    return sum_up_to_r - sum_up_to_before_L"}
{"task_id": "Mbpp/801", "completion": "def count_equal_numbers(a: int, b: int, c: int) -> int:\n    if a == b == c:\n        return 3\n    if a == b or b == c or a == c:\n        return 2\n    return 0"}
{"task_id": "Mbpp/804", "completion": "def is_product_even(nums):\n    \"\"\"\n    Return True if the product of the numbers in 'nums' is even, otherwise False.\n    If the list is empty, returns False (the product of an empty set is 1, which is odd).\n    \"\"\"\n    if not nums:\n        return False\n    for n in nums:\n        if n % 2 == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/796", "completion": "def sum_dict_items(d):\n    \"\"\"\n    Recursively sums all numeric values contained in the dictionary 'd'.\n    Numeric values can be int or float. If nested dictionaries or sequences\n    (list, tuple, set) are encountered, their numeric contents are included.\n    Non-numeric values are ignored.\n    \"\"\"\n    total = 0\n    if isinstance(d, dict):\n        for v in d.values():\n            total += sum_dict_items(v)\n    elif isinstance(d, (list, tuple, set)):\n        for item in d:\n            total += sum_dict_items(item)\n    elif isinstance(d, (int, float)):\n        total += d\n    return total"}
{"task_id": "Mbpp/800", "completion": "def remove_whitespace(s: str) -> str:\n    \"\"\"Remove all whitespace characters from the input string.\"\"\"\n    return ''.join(ch for ch in s if not ch.isspace())"}
{"task_id": "Mbpp/799", "completion": "def rotl32(n: int, d: int) -> int:\n    \"\"\"\n    Rotate left a 32-bit unsigned integer n by d bits.\n    Returns a value in the range [0, 0xFFFFFFFF].\n    \"\"\"\n    n &= 0xFFFFFFFF\n    d %= 32\n    return ((n << d) | (n >> (32 - d))) & 0xFFFFFFFF"}
{"task_id": "Mbpp/806", "completion": "def max_upper_run(s: str) -> int:\n    \"\"\"\n    Returns the length of the longest consecutive run of uppercase characters in the string s.\n    Non-uppercase characters break the run.\n    \"\"\"\n    max_run = 0\n    current = 0\n    for ch in s:\n        if ch.isupper():\n            current += 1\n            if current > max_run:\n                max_run = current\n        else:\n            current = 0\n    return max_run"}
{"task_id": "Mbpp/809", "completion": "def are_elements_of_second_smaller(first: tuple, second: tuple) -> bool:\n    if len(first) != len(second):\n        raise ValueError(\"Both tuples must have the same length.\")\n    return all(s < f for f, s in zip(first, second))"}
{"task_id": "Mbpp/788", "completion": "def create_tuple_from_string_and_list(string: str, lst: list) -> tuple:\n    return (string, lst)"}
{"task_id": "Mbpp/803", "completion": "def is_perfect_square(n):\n    \"\"\"\n    Check if a non-negative integer n is a perfect square.\n    Returns True if n is a perfect square, otherwise False.\n    \"\"\"\n    if n < 0:\n        return False\n    left, right = 0, n\n    while left <= right:\n        mid = (left + right) // 2\n        sq = mid * mid\n        if sq == n:\n            return True\n        elif sq < n:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return False"}
{"task_id": "Mbpp/770", "completion": "def sum_fourth_powers_of_first_n_odds(n: int) -> int:\n    \"\"\"\n    Return the sum of the fourth powers of the first n odd natural numbers.\n    For non-positive n, returns 0.\n    \"\"\"\n    if n <= 0:\n        return 0\n    nn = int(n)\n    term1 = (8 * nn * (nn + 1) * (2 * nn + 1) * (3 * nn * nn + 3 * nn - 1)) // 15\n    term2 = 8 * nn * nn * (nn + 1) * (nn + 1)\n    term3 = 4 * nn * (nn + 1) * (2 * nn + 1)\n    term4 = 4 * nn * (nn + 1)\n    return term1 - term2 + term3 - term4 + nn"}
{"task_id": "Mbpp/805", "completion": "def max_sum_sublist(list_of_lists):\n    \"\"\"\n    Returns the sublist with the maximum sum of its elements.\n    If multiple sublists have the same maximum sum, the first encountered is returned.\n    If input is empty or contains no valid sublists, returns [].\n    \"\"\"\n    if not list_of_lists:\n        return []\n    best_sub = []\n    best_sum = None\n    for sub in list_of_lists:\n        try:\n            s = sum(sub)\n        except TypeError:\n            # skip invalid sublists\n            continue\n        if best_sum is None or s > best_sum:\n            best_sum = s\n            best_sub = list(sub)\n    return best_sub"}
{"task_id": "Mbpp/807", "completion": "def first_odd_number(nums):\n    \"\"\"\n    Return the first odd integer in nums (including numbers that are floats but integral),\n    or None if no such number exists.\n    Booleans are ignored.\n    \"\"\"\n    for n in nums:\n        if isinstance(n, bool):\n            continue\n        if isinstance(n, int):\n            if n % 2 != 0:\n                return n\n        elif isinstance(n, float):\n            if n.is_integer():\n                m = int(n)\n                if m % 2 != 0:\n                    return m\n    return None"}
{"task_id": "Mbpp/808", "completion": "def contains_k_in_tuples(tuples_collection, k):\n    \"\"\"\n    Check whether the given collection of tuples contains the value k.\n    - If a single tuple is provided, it checks whether k is in that tuple.\n    - If an iterable of tuples is provided, it returns True if k is in any of the inner tuples.\n    Returns True if found, otherwise False.\n    \"\"\"\n    # If a single tuple (not a collection of tuples)\n    if isinstance(tuples_collection, tuple) and not any(isinstance(x, tuple) for x in tuples_collection):\n        return k in tuples_collection\n    try:\n        for t in tuples_collection:\n            if isinstance(t, tuple):\n                if k in t:\n                    return True\n            else:\n                # Treat non-tuple elements as a scalar; match directly\n                if t == k:\n                    return True\n        return False\n    except TypeError:\n        # Not iterable\n        return False"}
{"task_id": "Mbpp/739", "completion": "def index_of_smallest_triangular_with_n_digits(n):\n    \"\"\"\n    Return the index k of the smallest triangular number T_k = k*(k+1)/2\n    that has exactly n digits.\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    threshold = 10**(n - 1)\n    D = 1 + 8 * threshold\n    s = __import__(\"math\").isqrt(D)\n    if s * s == D:\n        k = (s - 1) // 2\n    else:\n        k = (s - 1) // 2 + 1\n    t = k * (k + 1) // 2\n\n    # Ensure t has less than 10^n digits\n    while t >= 10**n:\n        k -= 1\n        if k <= 0:\n            break\n        t = k * (k + 1) // 2\n\n    # Ensure t has at least n digits\n    while t < threshold:\n        k += 1\n        t = k * (k + 1) // 2\n\n    return k"}
{"task_id": "Mbpp/785", "completion": "def tuple_string_to_int_tuple(s: str) -> tuple:\n    \"\"\"\n    Convert a string representation of a tuple into a tuple of integers.\n    Accepts inputs like \"(1, 2, -3)\", \"1,2,3\", \"(1, '2', 3)\", etc.\n    Returns an empty tuple for empty input.\n    Raises ValueError if any element cannot be converted to int.\n    \"\"\"\n    import ast\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    s = s.strip()\n    if not s:\n        return ()\n    if not (s.startswith(\"(\") and s.endswith(\")\")):\n        s = \"(\" + s + \")\"\n    try:\n        parsed = ast.literal_eval(s)\n    except Exception as e:\n        raise ValueError(\"Input string is not a valid tuple literal\") from e\n    if isinstance(parsed, tuple):\n        items = parsed\n    elif isinstance(parsed, list):\n        items = tuple(parsed)\n    else:\n        raise ValueError(\"Parsed value is not a tuple or list\")\n    result = []\n    for item in items:\n        try:\n            result.append(int(item))\n        except Exception as e:\n            raise ValueError(f\"Element {item!r} cannot be converted to int\") from e\n    return tuple(result)"}
{"task_id": "Mbpp/794", "completion": "def matches_a_followed_by_any_ending_b(s: str) -> bool:\n    return 'a' in s and s.endswith('b')"}
{"task_id": "Mbpp/765", "completion": "def nth_polite(n):\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n    limit = max(100, n * 12)\n    while True:\n        # Sieve of Eratosthenes to find primes up to limit using a memory-efficient bytearray\n        is_prime = bytearray(b'\\x01') * (limit + 1)\n        is_prime[0] = 0\n        is_prime[1] = 0\n        m = int(limit ** 0.5)\n        for i in range(2, m + 1):\n            if is_prime[i]:\n                step = i\n                start = i * i\n                is_prime[start:limit + 1:step] = b'\\x00' * (((limit - start) // step) + 1)\n        primes = [i for i in range(2, limit + 1) if is_prime[i]]\n\n        # Mark prime powers\n        is_pp = bytearray(limit + 1)\n        for p in primes:\n            val = p\n            while val <= limit:\n                is_pp[val] = 1\n                if val > limit // p:\n                    break\n                val *= p\n\n        # Count polite numbers (numbers >= 2 that are not prime powers)\n        count = 0\n        for x in range(2, limit + 1):\n            if not is_pp[x]:\n                count += 1\n                if count == n:\n                    return x\n        limit *= 2"}
{"task_id": "Mbpp/782", "completion": "def sum_odd_length_subarrays(arr):\n    n = len(arr)\n    total = 0\n    for i, val in enumerate(arr):\n        left = i + 1\n        right = n - i\n        count = (left * right + 1) // 2\n        total += val * count\n    return total"}
