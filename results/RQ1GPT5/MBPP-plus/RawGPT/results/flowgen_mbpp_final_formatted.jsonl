{"task_id": "Mbpp/58", "completion": "Here's a simple Python function that returns True if two integers have opposite signs (one positive, one negative). Zeros are not considered opposite to any number.\n\n```python\ndef opposite_sign(a: int, b: int) -> bool:\n    \"\"\"\n    Return True if a and b have opposite signs (one positive, one negative).\n    Zeros are not considered opposite to any number.\n    \"\"\"\n    return a * b < 0\n\n# Example usage\nprint(opposite_sign(5, -3))   # True\nprint(opposite_sign(-2, 4))   # True\nprint(opposite_sign(0, 5))    # False\nprint(opposite_sign(0, -5))   # False\n```"}
{"task_id": "Mbpp/17", "completion": "Here are simple implementations in a few common languages. The perimeter is 4 times the side length (with optional basic validation for non-negative input).\n\nPython\ndef square_perimeter(side_length):\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative\")\n    return 4 * side_length\n\n# Example:\n# perimeter = square_perimeter(5)  # 20\n\nJavaScript\nfunction squarePerimeter(side) {\n  if (side < 0) throw new Error(\"side must be non-negative\");\n  return 4 * side;\n}\n\n# Example:\n# squarePerimeter(5); // 20\n\nJava\npublic static double squarePerimeter(double side) {\n    if (side < 0) throw new IllegalArgumentException(\"side must be non-negative\");\n    return 4 * side;\n}\n\nC++\n#include <stdexcept>\n\ndouble squarePerimeter(double side) {\n    if (side < 0) throw std::invalid_argument(\"side must be non-negative\");\n    return 4 * side;\n}\n\n# Example:\n# squarePerimeter(5) // 20\n\nIf you tell me your preferred language, I can tailor the function exactly to that."}
{"task_id": "Mbpp/59", "completion": "Here's a simple Python function. The nth octagonal number is given by O(n) = n*(3n - 2), for n >= 1.\n\ndef octagonal(n):\n    \"\"\"\n    Return the nth octagonal number, where n >= 1.\n    O(n) = n * (3n - 2)\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return n * (3 * n - 2)\n\n# Examples\nprint(octagonal(1))  # 1\nprint(octagonal(2))  # 8\nprint(octagonal(5))  # 65\n\nIf you prefer JavaScript, a equivalent function is:\nfunction octagonal(n) {\n  if (!Number.isInteger(n)) throw new TypeError(\"n must be an integer\");\n  if (n < 1) throw new RangeError(\"n must be >= 1\");\n  return n * (3 * n - 2);\n}"}
{"task_id": "Mbpp/20", "completion": "I\u2019m not sure what you mean by a \u201cwoodball\u201d number. Could you define what makes a number woodball (and maybe give a few examples of woodball vs non-woodball numbers)? Also let me know which programming language you want.\n\nIf you just want a generic template to fill in once you provide the definition, here are common language templates:\n\n- Python\n  def is_woodball(n: int) -> bool:\n      # TODO: implement the woodball criterion here\n      return False\n\n  # Example usage\n  for x in range(1, 101):\n      if is_woodball(x):\n          print(x)\n\n- JavaScript\n  function isWoodball(n) {\n      // TODO: implement the woodball criterion here\n      return false;\n  }\n\n  // Example usage\n  for (let x = 1; x <= 100; x++) {\n      if (isWoodball(x)) console.log(x);\n  }\n\n- Java\n  public class WoodballChecker {\n      public static boolean isWoodball(int n) {\n          // TODO: implement the woodball criterion here\n          return false;\n      }\n\n      public static void main(String[] args) {\n          for (int i = 1; i <= 100; i++) {\n              if (isWoodball(i)) System.out.println(i);\n          }\n      }\n  }\n\nIf you can share the exact rule for a woodball number (for example: a number whose digits sum to a multiple of 3, or a number whose prime factorization has a certain property, or a number that equals some function of its digits, etc.), I\u2019ll provide a concrete implementation right away in your preferred language."}
{"task_id": "Mbpp/4", "completion": "Here's a concise Python function using a heap for efficiency. It returns the n largest integers from the list in descending order (duplicates counted).\n\n```python\nimport heapq\n\ndef n_largest(nums, n):\n    \"\"\"\n    Return the n largest integers from nums in descending order.\n    Duplicates are counted (e.g., [5,5,4] with n=2 -> [5,5]).\n    If n <= 0 or nums is empty, returns [].\n    \"\"\"\n    if not nums or n <= 0:\n        return []\n    return heapq.nlargest(n, nums)\n\n# Example\nprint(n_largest([3, 1, 5, 2, 5, 4], 3))  # [5, 5, 4]\n```\n\nNotes:\n- If n > len(nums), it returns all elements sorted in descending order.\n- Time complexity: O(m log n) where m = len(nums). Memory: O(n).\n\nIf you prefer a simpler approach (less efficient for large lists), you can sort once and slice:\n\n```python\ndef n_largest_sorted(nums, n):\n    if not nums or n <= 0:\n        return []\n    return sorted(nums, reverse=True)[:n]\n```"}
{"task_id": "Mbpp/19", "completion": "Here are straightforward solutions in a few common languages. All return True if there is any duplicate, otherwise False.\n\nPython (using a set)\n- Simple and efficient O(n) time, O(n) space\ndef contains_duplicate(nums):\n    if nums is None:\n        raise ValueError(\"nums must not be None\")\n    return len(nums) != len(set(nums))\n\n# Optional explicit approach (no extra conversion)\ndef contains_duplicate_iter(nums):\n    if nums is None:\n        raise ValueError(\"nums must not be None\")\n    seen = set()\n    for x in nums:\n        if x in seen:\n            return True\n        seen.add(x)\n    return False\n\nPython one-liner (minimal)\ndef contains_duplicate(nums):\n    return len(nums) != len(set(nums))\n\nJavaScript\nfunction hasDuplicate(arr) {\n  const seen = new Set();\n  for (const x of arr) {\n    if (seen.has(x)) return true;\n    seen.add(x);\n  }\n  return false;\n}\n\nJava\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public static boolean hasDuplicate(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        for (int x : nums) {\n            if (seen.contains(x)) return true;\n            seen.add(x);\n        }\n        return false;\n    }\n}\n\nC++\n#include <vector>\n#include <unordered_set>\n\nbool hasDuplicate(const std::vector<int>& nums) {\n    std::unordered_set<int> seen;\n    for (int x : nums) {\n        if (seen.find(x) != seen.end()) return true;\n        seen.insert(x);\n    }\n    return false;\n}\n\nNotes\n- Time complexity: O(n) on average with a hash-based approach; O(n log n) if you sort first.\n- Space complexity: O(n) extra space for the hash set; can be reduced to O(1) extra space if you\u2019re allowed to sort in place and you don\u2019t need to preserve the original order (but sorting may alter the input). \n- Edge cases: empty or single-element arrays return False. If input may be None, handle/validate accordingly."}
{"task_id": "Mbpp/8", "completion": "Here\u2019s a simple Python function that returns a new list with the square of each element.\n\n- Basic version (works for numbers):\n  def squares_of_elements(lst):\n      \"\"\"Return a new list with each element squared.\"\"\"\n      return [x * x for x in lst]\n\n  # Example\n  print(squares_of_elements([1, -2, 3, 0]))  # [1, 4, 9, 0]\n\n- Variant that validates numeric inputs (optional):\n  def squares_of_elements_strict(lst):\n      \"\"\"Square only numeric elements; raise TypeError for non-numeric.\"\"\"\n      for i, x in enumerate(lst):\n          if not isinstance(x, (int, float, complex)):\n              raise TypeError(f\"Element at index {i} is not numeric: {x!r}\")\n      return [x * x for x in lst]\n\nNotes:\n- Time complexity: O(n) for n elements.\n- If you\u2019re using JavaScript, a similar approach would be: lst.map(x => x * x). If you want versions in another language, tell me which one."}
{"task_id": "Mbpp/11", "completion": "Here's a simple Python function that removes the first and last occurrence of a given single character from a string. If there are fewer than two occurrences, it handles that case gracefully (removing the single occurrence if only one exists, or leaving the string unchanged if there are none).\n\n```python\ndef remove_first_last_occurrence(s: str, ch: str) -> str:\n    if not isinstance(ch, str) or len(ch) != 1:\n        raise ValueError(\"ch must be a single character.\")\n\n    first = s.find(ch)\n    if first == -1:\n        # no occurrence\n        return s\n\n    last = s.rfind(ch)\n    if first == last:\n        # only one occurrence -> remove that one\n        return s[:first] + s[first+1:]\n\n    # remove both first and last occurrence\n    return s[:first] + s[first+1:last] + s[last+1:]\n\n# Examples\nprint(remove_first_last_occurrence(\"hello world\", \"l\"))  # \"heo word\"\nprint(remove_first_last_occurrence(\"abca\", \"a\"))         # \"bc\"\nprint(remove_first_last_occurrence(\"abc\", \"d\"))          # \"abc\" (no change)\n```\n\nNotes:\n- If the character appears at least twice, both the first and last occurrences are removed.\n- If it appears only once, that single occurrence is removed.\n- If it doesn\u2019t appear at all, the string is returned unchanged."}
{"task_id": "Mbpp/14", "completion": "Here are two simple Python functions to compute the volume of a triangular prism.\n\n1) Using the base triangle's base and height (V = 1/2 * base * height * length):\n\n```python\ndef volume_triangular_prism_base_height(base, tri_height, length):\n    \"\"\"\n    base: length of the triangle base\n    tri_height: height of the triangle (perpendicular to the base)\n    length: distance between the triangular faces (prism length)\n    Returns the volume.\n    \"\"\"\n    if base <= 0 or tri_height <= 0 or length <= 0:\n        raise ValueError(\"base, tri_height, and length must be positive\")\n    return 0.5 * base * tri_height * length\n```\n\n2) Using the triangle\u2019s side lengths (Heron's formula for the base area):\n\n```python\nimport math\n\ndef _triangle_area_sides(a, b, c):\n    s = (a + b + c) / 2.0\n    area_sq = s * (s - a) * (s - b) * (s - c)\n    if area_sq < 0:\n        area_sq = 0.0  # guard against floating-point minor negatives\n    return math.sqrt(area_sq)\n\ndef volume_triangular_prism_sides(a, b, c, length):\n    \"\"\"\n    a, b, c: side lengths of the triangular base\n    length: distance between the triangular faces (prism length)\n    Returns the volume.\n    \"\"\"\n    if length <= 0:\n        raise ValueError(\"length must be positive\")\n    area = _triangle_area_sides(a, b, c)\n    if area <= 0:\n        raise ValueError(\"invalid triangle sides\")\n    return area * length\n```\n\nUsage examples:\n- volume_triangular_prism_base_height(3, 4, 10) -> 60.0\n- volume_triangular_prism_sides(3, 4, 5, 10) -> 60.0\n\nIf you\u2019d like, I can tailor a single function that accepts flexible inputs (e.g., keyword flags) and handles both cases."}
{"task_id": "Mbpp/3", "completion": "Here's a simple, robust function that identifies non-prime numbers (i.e., numbers that are not prime). It treats any integer <= 1 as non-prime and uses a quick trial division up to sqrt(n).\n\nCode:\n\ndef is_non_prime(n: int) -> bool:\n    \"\"\"\n    Return True if n is non-prime (not a prime).\n    - Numbers <= 1 are non-prime\n    - Primes return False\n    - Raises TypeError if n is not an int\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n\n    if n <= 1:\n        return True\n    if n <= 3:\n        return False  # 2 and 3 are prime\n    if n % 2 == 0 or n % 3 == 0:\n        return True\n\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return True\n        i += 6\n    return False\n\n# Examples\nprint(is_non_prime(-5))  # True\nprint(is_non_prime(1))   # True\nprint(is_non_prime(2))   # False\nprint(is_non_prime(15))  # True\nprint(is_non_prime(17))  # False\n\nIf you want to get all non-primes in a range, you can add:\n\ndef non_primes_in_range(start: int, end: int):\n    if end < start:\n        raise ValueError(\"end must be >= start\")\n    return [n for n in range(start, end + 1) if is_non_prime(n)]\n\n# Example\nprint(non_primes_in_range(1, 20))\n"}
{"task_id": "Mbpp/6", "completion": "Here's a simple Python function. It uses the fact that numbers differ in exactly one bit position iff their XOR has exactly one bit set (i.e., XOR is a power of two).\n\n```python\ndef differ_by_one_bit(a: int, b: int) -> bool:\n    \"\"\"\n    Return True if integers a and b differ in exactly one bit position.\n    Only non-negative integers are supported (leading zeros are assumed).\n    \"\"\"\n    if a < 0 or b < 0:\n        raise ValueError(\"Only non-negative integers are supported.\")\n    x = a ^ b\n    return x != 0 and (x & (x - 1)) == 0\n```\n\nUsage examples:\n- differ_by_one_bit(5, 4) -> True  (0101 vs 0100 differs in one bit)\n- differ_by_one_bit(5, 1) -> True  (0101 vs 0001 differs in one bit)\n- differ_by_one_bit(5, 2) -> False (0101 vs 0010 differs in multiple bits)"}
{"task_id": "Mbpp/57", "completion": "Here\u2019s a straightforward Python function: sort the digits in descending order and concatenate them to form the largest possible number.\n\n```python\ndef largest_number_from_digits(digits):\n    \"\"\"\n    Given a list of digits (each 0-9), return the largest number that can be formed\n    by arranging them.\n    Returns an int.\n    \"\"\"\n    if not digits:\n        return 0\n\n    # Validate input: all elements must be integers in [0, 9]\n    for d in digits:\n        if not isinstance(d, int) or d < 0 or d > 9:\n            raise ValueError(\"All elements must be digits (0-9).\")\n\n    # Convert to strings for easy concatenation, sort in descending order\n    digits_str = [str(d) for d in digits]\n    digits_str.sort(key=int, reverse=True)\n\n    # Join to form the largest number\n    largest_str = ''.join(digits_str)\n\n    return int(largest_str)\n```\n\nUsage examples:\n- largest_number_from_digits([3, 1, 4, 4, 9]) -> 94431\n- largest_number_from_digits([0, 0, 1]) -> 100\n\nComplexity:\n- Time: O(n log n) due to sorting\n- Space: O(n) for the string list and result\n\nIf you prefer returning a string instead of an int (to preserve very large numbers), you can return largest_str instead of converting to int."}
{"task_id": "Mbpp/61", "completion": "Here is a concise O(n) solution using prefix sums.\n\n- Idea: For substring s[l..r], sum(digits) = length implies sum(digits) - length = 0.\n  Let pref[i] = sum(digits[0..i-1]) - i. A substring with sum equal to its length corresponds to two equal pref values. Count equal prefix values.\n\nPython function:\n\ndef count_substrings_sum_digits_equal_length(s: str) -> int:\n    \"\"\"\n    Count substrings of a numeric string s where the sum of digits\n    equals the substring length.\n    \"\"\"\n    from collections import defaultdict\n\n    pref = 0  # cumulative (sum of digits) - length\n    freq = defaultdict(int)\n    freq[0] = 1  # empty prefix\n    ans = 0\n\n    for ch in s:\n        d = ord(ch) - ord('0')\n        pref += d - 1\n        ans += freq[pref]\n        freq[pref] += 1\n\n    return ans\n\nExamples:\n- count_substrings_sum_digits_equal_length(\"123\") -> 3\n  Substrings: \"1\", \"2\", \"3\"\n- count_substrings_sum_digits_equal_length(\"121\") -> 2\n  Substrings: \"1\" (pos1), \"1\" (pos3)\n\nNotes:\n- Works for any non-empty string of digits; returns 0 for empty string.\n- Time: O(n), Space: O(n) for the frequency map."}
{"task_id": "Mbpp/18", "completion": "Here are simple implementations in a few common languages. All remove any character from s1 that appears in s2. By default this is case-sensitive; you can adjust to be case-insensitive if needed.\n\nPython\ndef remove_chars(s1, s2):\n    to_remove = set(s2)\n    return ''.join(ch for ch in s1 if ch not in to_remove)\n\n# Example\n# remove_chars(\"battle\", \"lt\") -> \"bae\"\n\nJavaScript\nfunction removeChars(str1, str2) {\n  const toRemove = new Set(str2);\n  let res = '';\n  for (const ch of str1) {\n    if (!toRemove.has(ch)) res += ch;\n  }\n  return res;\n}\n\n# Example\n# removeChars(\"battle\", \"lt\") -> \"bae\"\n\nJava\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class Main {\n    public static String removeChars(String s1, String s2) {\n        Set<Character> toRemove = new HashSet<>();\n        for (char c : s2.toCharArray()) toRemove.add(c);\n        StringBuilder sb = new StringBuilder();\n        for (char c : s1.toCharArray()) {\n            if (!toRemove.contains(c)) sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    // Example usage:\n    // removeChars(\"battle\", \"lt\") -> \"bae\"\n}\n\nC++\n#include <string>\n#include <unordered_set>\n\nstd::string removeChars(const std::string& s1, const std::string& s2) {\n    std::unordered_set<char> rem(s2.begin(), s2.end());\n    std::string res;\n    res.reserve(s1.size());\n    for (char c : s1) {\n        if (!rem.count(c)) res.push_back(c);\n    }\n    return res;\n}\n\nIf you prefer a single-language solution or want to handle case-insensitive removal, tell me and I can tailor accordingly."}
{"task_id": "Mbpp/2", "completion": "Here are a few Python options depending on what you mean by \u201cshared elements.\u201d\n\nOption 1: Unique shared elements (unordered)\n- Returns each element that appears in both lists, once each (order not guaranteed).\n\ndef shared_unique(a: list, b: list) -> list:\n    return list(set(a) & set(b))\n\nOption 2: Shared elements preserving order from the first list (no duplicates)\n- Keeps the order as they appear in the first list and removes duplicates.\n\ndef shared_ordered_unique(a: list, b: list) -> list:\n    s = set(b)\n    seen = set()\n    res = []\n    for x in a:\n        if x in s and x not in seen:\n            res.append(x)\n            seen.add(x)\n    return res\n\nOption 3: Shared elements including duplicates (multiset intersection)\n- If an element appears k times in both lists, it appears min(k1, k2) times in the result, preserving the order from the first list.\n\nfrom collections import Counter\n\ndef shared_with_counts(a: list, b: list) -> list:\n    ca = Counter(a)\n    cb = Counter(b)\n    common = ca & cb  # min counts for each element\n    res = []\n    for x in a:\n        if common[x] > 0:\n            res.append(x)\n            common[x] -= 1\n    return res\n\nUsage examples:\n- a = [1, 2, 2, 3]\n  b = [2, 3, 4]\n\n  shared_unique(a, b)            -> [2, 3]  (order not guaranteed)\n  shared_ordered_unique(a, b)    -> [2, 3]\n  shared_with_counts(a, b)       -> [2, 3]\n\nIf you tell me your preferred language or whether you want to preserve order, include duplicates, or handle unhashable elements, I can tailor the function."}
{"task_id": "Mbpp/12", "completion": "Here\u2019s a simple way to reorder the rows of a matrix so that their sums are in ascending order. I\u2019m giving both a pure Python version (no dependencies) and a NumPy version.\n\nPython (pure, no numpy)\n- Sorts rows by the sum of each row.\n- Returns a new matrix; the input is not modified.\n- Stable: rows with equal sums keep their original relative order.\n\ndef sort_matrix_by_row_sum(matrix):\n    \"\"\"\n    Sorts the rows of a 2D list 'matrix' in ascending order of the sum of each row.\n    Returns a new matrix (input is not modified).\n    \"\"\"\n    return sorted(matrix, key=lambda row: sum(row))\n\n# Example:\n# m = [[3, 1, 2], [1, 2, 3], [4, 5], [0, 1]]\n# print(sort_matrix_by_row_sum(m))\n# -> [[0, 1], [3, 1, 2], [1, 2, 3], [4, 5]]  (ordered by row sums: 1, 6, 6, 9)\n\nIn-place variant (modifies the original matrix)\ndef sort_inplace_by_row_sum(matrix):\n    matrix.sort(key=lambda row: sum(row))\n\nNumPy version\n- Works with a 2D NumPy array.\n- Returns a new array with rows reordered by their sums.\n\nimport numpy as np\n\ndef sort_matrix_by_row_sum_np(matrix):\n    a = np.asarray(matrix)\n    idx = np.argsort(a.sum(axis=1))\n    return a[idx]\n\nExample:\n# m = np.array([[3,1,2], [1,2,3], [4,5], [0,1]])\n# print(sort_matrix_by_row_sum_np(m))\n# Rows reordered by their sums.\n\nIf you want a different interpretation (e.g., sort by the sums of columns or sort in descending order), tell me and I\u2019ll adjust."}
{"task_id": "Mbpp/16", "completion": "Here\u2019s a simple interpretation: the string should be entirely made of one or more lowercase letter sequences separated by single underscores (no leading/trailing underscores, no other characters).\n\nPython (regex, full string match)\n- Matches \"abc\", \"abc_def\", \"foo_bar_baz\"; rejects \"Abc\", \"abc__\", \"abc_def1\"\n- If you want at least one underscore, use the second version\n\ndef contains_lowercase_sequences_joined_by_underscore(s: str) -> bool:\n    import re\n    return bool(re.fullmatch(r'[a-z]+(?:_[a-z]+)*', s))\n\n# Variant: require at least one underscore\ndef contains_lowercase_sequences_joined_by_underscore_with_at_least_one(s: str) -> bool:\n    import re\n    return bool(re.fullmatch(r'[a-z]+(?:_[a-z]+)+', s))\n\n# Non-regex alternative (no regex)\ndef contains_lowercase_sequences_joined_by_underscore_no_regex(s: str) -> bool:\n    if not s:\n        return False\n    parts = s.split('_')\n    if len(parts) < 2:  # at least one underscore required\n        return False\n    for p in parts:\n        if not p.isalpha() or not p.islower():\n            return False\n    return True\n\nJavaScript (regex)\n- Basic version (allows even a single group, no leading/trailing underscores)\n\nfunction containsLowercaseSequencesJoinedWithUnderscore(s) {\n  return /^[a-z]+(?:_[a-z]+)*$/.test(s);\n}\n\n// Require at least one underscore\nfunction containsLowercaseSequencesJoinedWithUnderscoreRequired(s) {\n  return /^[a-z]+(?:_[a-z]+)+$/.test(s);\n}\n\nExamples\n- \"abc\" -> true (single group)\n- \"abc_def\" -> true\n- \"abc_DEF\" -> false (uppercase)\n- \"abc__def\" -> false (double underscore)\n- \"\" -> false\n\nIf you\u2019d like a different interpretation (e.g., the string merely contains at least one occurrence of a lowercase sequence followed by an underscore and another sequence anywhere in the string), let me know and I\u2019ll adjust the regex accordingly."}
{"task_id": "Mbpp/66", "completion": "Here's a simple Python function that counts how many elements in a list are positive (> 0):\n\n```python\ndef count_positive(numbers):\n    \"\"\"Return the number of positive numbers in the input list.\"\"\"\n    return sum(1 for x in numbers if x > 0)\n\n# Example usage:\nlst = [-1, 0, 2, 3.5, -4]\nprint(count_positive(lst))  # Output: 2\n```"}
{"task_id": "Mbpp/62", "completion": "Here are two simple ways to find the smallest number in a list.\n\n1) Manual loop (no built-ins)\n\n```python\ndef find_min(nums):\n    if nums is None or len(nums) == 0:\n        raise ValueError(\"nums must be a non-empty sequence\")\n    min_val = nums[0]\n    for x in nums[1:]:\n        if x < min_val:\n            min_val = x\n    return min_val\n```\n\n2) Using the built-in min (shorter)\n\n```python\ndef find_min_builtin(nums):\n    if not nums:\n        raise ValueError(\"empty sequence\")\n    return min(nums)\n```\n\nNotes:\n- Both run in O(n) time and use O(1) extra space.\n- They raise an error on empty input; you can change the behavior (e.g., return None) if you prefer."}
{"task_id": "Mbpp/7", "completion": "Here are simple implementations in a few common languages. The idea is to return all words with length at least 4. A \u201cword\u201d is treated as a sequence of word characters; you can adjust the definition if you want.\n\nPython\n- Uses a regex to find word tokens and filters out tokens that are not at least 4 characters or are digits-only.\n\nimport re\n\ndef words_at_least(text, min_len=4):\n    # Find word-like tokens (letters, digits, underscore). Unicode-aware.\n    tokens = re.findall(r\"\\b\\w{%d,}\\b\" % min_len, text, flags=re.UNICODE)\n    # Exclude tokens that are purely digits (optional)\n    return [t for t in tokens if any(ch.isalpha() for ch in t)]\n\n# Example\ns = \"Hello, world! This is 4-letter words: test, code, AI.\"\nprint(words_at_least(s))\n# ['Hello', 'world', 'This', 'letter', 'words', 'test', 'code']\n\n\nJavaScript (ECMAScript 2020+)\n- Uses a regex to collect words of length >= minLen.\n\nfunction wordsAtLeast(text, minLen = 4) {\n  const re = new RegExp(\"\\\\b\\\\w{\" + minLen + \",}\\\\b\", \"gu\");\n  const tokens = text.match(re) || [];\n  // Optional: filter out purely digits\n  return tokens.filter(w => /[A-Za-z]/.test(w));\n}\n\n// Example\nconsole.log(wordsAtLeast(\"Hello, world! This is 4-letter words: test, code, AI.\"));\n// [\"Hello\", \"world\", \"This\", \"letter\", \"words\", \"test\", \"code\"]\n\n\nJava\n- Uses a similar approach with Pattern and Matcher.\n\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class Words {\n    public static List<String> wordsAtLeast(String text, int minLen) {\n        List<String> result = new ArrayList<>();\n        Pattern p = Pattern.compile(\"\\\\b\\\\w{\" + minLen + \",}\\\\b\");\n        Matcher m = p.matcher(text);\n        while (m.find()) {\n            String w = m.group();\n            // Optional: skip tokens that are all digits\n            if (w.chars().anyMatch(Character::isLetter)) {\n                result.add(w);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        String s = \"Hello, world! This is 4-letter words: test, code, AI.\";\n        System.out.println(wordsAtLeast(s, 4));\n    }\n}\n\nNotes and tips\n- Define \u201cword\u201d as you need. The examples treat a word as a sequence of word characters (\\w), which includes letters, digits, and underscore. If you want strictly letters, replace the regex with something like \\b[A-Za-z]{min,}\\b (or use Unicode-aware classes if available).\n- If you want to include hyphenated words or contractions (e.g., \"well-being\", \"don't\"), adjust the regex to allow internal apostrophes or hyphens.\n- If you want to preserve original casing or duplicates, these implementations do that; you can add normalization (e.g., lowercasing) if desired.\n\nIf you tell me your preferred language and how you\u2019d like to define a word, I can tailor the function precisely."}
{"task_id": "Mbpp/56", "completion": "Here\u2019s a simple Python function that checks whether a non-negative integer n is one less than twice its decimal reverse (i.e., n == 2 * reverse(n) - 1). It uses arithmetic reversal (no string operations).\n\n```python\ndef is_one_less_than_twice_reverse(n: int) -> bool:\n    \"\"\"\n    Return True if n is one less than twice its decimal reverse.\n    i.e., n == 2 * reverse(n) - 1.\n    Negative inputs are treated as False.\n    \"\"\"\n    if n < 0:\n        return False\n\n    # compute reverse of n\n    m, rev = n, 0\n    while m > 0:\n        rev = rev * 10 + (m % 10)\n        m //= 10\n\n    return n == 2 * rev - 1\n```\n\nUsage example:\n- is_one_less_than_twice_reverse(1) -> True\n- is_one_less_than_twice_reverse(12) -> False"}
{"task_id": "Mbpp/79", "completion": "Here\u2019s a simple Python function that returns True if the length of the input word is odd, and False otherwise.\n\n```python\ndef is_odd_length(word: str) -> bool:\n    \"\"\"Return True if the length of 'word' is odd, else False.\"\"\"\n    if not isinstance(word, str):\n        raise TypeError(\"word must be a string\")\n    return len(word) % 2 == 1\n\n# Examples\nprint(is_odd_length(\"cat\"))   # True  (length 3)\nprint(is_odd_length(\"doge\"))  # False (length 4)\n```"}
{"task_id": "Mbpp/70", "completion": "Here is a simple Python function that checks whether all input tuples have the same length.\n\n```python\ndef all_tuples_same_length(tuples):\n    \"\"\"\n    Return True if all tuples in the input iterable have the same length.\n    - tuples: an iterable of tuples\n    \"\"\"\n    tlist = list(tuples)\n    if not tlist:\n        return True  # vacuously true for empty input\n\n    # Optional: enforce that all elements are tuples\n    # if not all(isinstance(t, tuple) for t in tlist):\n    #     raise TypeError(\"All elements must be tuples\")\n\n    first_len = len(tlist[0])\n    return all(len(t) == first_len for t in tlist)\n\n# Examples\nprint(all_tuples_same_length([(1, 2), (3, 4)]))        # True\nprint(all_tuples_same_length([(1, 2, 3), (4, 5)]))     # False\nprint(all_tuples_same_length([]))                      # True\n```\n\nNotes:\n- Vacuously true for an empty list of tuples.\n- Runs in O(n) time where n is the number of tuples, and uses O(1) extra space beyond input storage.\n- If you want to enforce that every element is a tuple, uncomment the type check."}
{"task_id": "Mbpp/68", "completion": "Here is a simple Python function that checks if an array is monotonic (either non-decreasing or non-increasing). It runs in O(n) time and uses O(1) extra space.\n\n```python\ndef is_monotonic(arr):\n    # Empty or single element arrays are monotonic\n    if len(arr) < 3:\n        return True\n\n    increasing = True  # no decrease seen yet\n    decreasing = True  # no increase seen yet\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            decreasing = False\n        elif arr[i] < arr[i-1]:\n            increasing = False\n        # If both possibilities are ruled out, it's not monotonic\n        if not increasing and not decreasing:\n            return False\n\n    return True\n\n\n# Examples\nprint(is_monotonic([1, 2, 2, 3]))  # True (non-decreasing)\nprint(is_monotonic([6, 5, 4, 4]))  # True (non-increasing)\nprint(is_monotonic([1, 3, 2]))     # False\nprint(is_monotonic([1]))           # True\nprint(is_monotonic([]))            # True\n```\n\nIf you prefer strictly monotonic (no equal consecutive elements), you can modify the checks accordingly (e.g., treat equality as a violation by using > and < only, and handle True/False flags differently)."}
{"task_id": "Mbpp/64", "completion": "Here\u2019s a simple Python function that sorts a list of tuples by their second element. It assumes every tuple has at least two elements.\n\n```python\nfrom typing import List, Tuple, Any\n\ndef sort_by_second(items: List[Tuple[Any, Any]], reverse: bool = False) -> List[Tuple[Any, Any]]:\n    \"\"\"\n    Return a new list sorted by the second element of each tuple.\n    \"\"\"\n    return sorted(items, key=lambda t: t[1], reverse=reverse)\n```\n\nUsage:\n```python\npairs = [(1, 3), (2, 1), (4, 2)]\nprint(sort_by_second(pairs))            # [(2, 1), (4, 2), (1, 3)]\nprint(sort_by_second(pairs, reverse=True))  # [(1, 3), (4, 2), (2, 1)]\n```\n\nNotes:\n- You can use operator.itemgetter(1) as the key instead of a lambda if you prefer.\n- If any tuple might have fewer than two elements, consider validating input or handling exceptions."}
{"task_id": "Mbpp/9", "completion": "Here's a simple function that returns the smallest positive number of left-rotations needed to bring the string back to itself. If no smaller period exists, it returns the length of the string (i.e., you need to rotate by n positions).\n\n```python\ndef min_rotations_to_same(s: str) -> int:\n    \"\"\"\n    Return the smallest positive k (1 <= k <= len(s)) such that\n    rotating s left by k positions yields the original string.\n    If no smaller period exists, returns len(s).\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    n = len(s)\n    if n == 0:\n        raise ValueError(\"empty string has no positive rotation period\")\n\n    # Check k = 1..n-1. If none work, k = n is the answer.\n    for k in range(1, n):\n        if s == s[k:] + s[:k]:\n            return k\n    return n\n```\n\nExamples:\n- min_rotations_to_same(\"ababab\") -> 2\n- min_rotations_to_same(\"abcabc\") -> 3\n- min_rotations_to_same(\"abcdef\") -> 6\n\nNote: This is a straightforward O(n^2) approach. If you need it for very large strings, you can use a KMP-based approach to find the smallest period in O(n). Here\u2019s a quick alternative using the prefix-function:\n\n```python\ndef min_rotations_kmp(s: str) -> int:\n    if not s:\n        raise ValueError(\"empty string has no positive rotation period\")\n    n = len(s)\n\n    # Build longest proper prefix-suffix (lps) array\n    lps = [0] * n\n    length = 0\n    i = 1\n    while i < n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    period = n - lps[-1]\n    return period if n % period == 0 else n\n```"}
{"task_id": "Mbpp/63", "completion": "Here are two common interpretations and Python implementations. Pick the one that matches your intent.\n\n1) Maximum absolute difference inside any given pair\n- Given a list of 2-element tuples, compute max(|a - b|) across all pairs.\n\nCode:\ndef max_abs_diff_within_pairs(pairs):\n    \"\"\"\n    Returns the maximum absolute difference between elements of the pairs.\n    If the input is empty, returns None.\n    \"\"\"\n    if not pairs:\n        return None\n    max_diff = None\n    for a, b in pairs:\n        d = abs(a - b)\n        if max_diff is None or d > max_diff:\n            max_diff = d\n    return max_diff\n\n2) Maximum difference across all numbers in all pairs\n- Treat all numbers in all pairs as a single set; return max_value - min_value.\n\nCode:\ndef max_diff_across_all_numbers(pairs):\n    \"\"\"\n    Returns the maximum difference between any two numbers across all pairs.\n    If the input is empty, returns None.\n    \"\"\"\n    if not pairs:\n        return None\n    min_val = float('inf')\n    max_val = float('-inf')\n    for a, b in pairs:\n        if a < min_val: min_val = a\n        if a > max_val: max_val = a\n        if b < min_val: min_val = b\n        if b > max_val: max_val = b\n    return max_val - min_val\n\nExamples:\npairs = [(1, 9), (3, 5), (10, 2)]\n\nprint(max_abs_diff_within_pairs(pairs))  # 8  (max |a-b| among pairs: |1-9|=8, |3-5|=2, |10-2|=8)\nprint(max_diff_across_all_numbers(pairs))  # 9  (max 10 - min 1)\n\nIf you had a different interpretation in mind, tell me the exact structure and goal of \u201cmaximum difference\u201d and I\u2019ll tailor the function."}
{"task_id": "Mbpp/80", "completion": "The nth tetrahedral number can be computed with the closed form:\nT(n) = n(n+1)(n+2) / 6\nThis gives T(0) = 0, T(1) = 1, T(2) = 4, T(3) = 10, ...\n\nPython example (0-based n; T0 = 0):\n```python\ndef tetrahedral(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return n * (n + 1) * (n + 2) // 6\n\n# Examples\nprint([tetrahedral(i) for i in range(6)])  # [0, 1, 4, 10, 20, 35]\n```\n\nNotes:\n- Uses O(1) time and O(1) extra space.\n- Python integers have arbitrary precision, so it handles large n without overflow.\n- For 1-based indexing (where T(1) = 1), you can still use the same formula with n \u2265 1."}
{"task_id": "Mbpp/85", "completion": "Here\u2019s a simple Python function that computes the surface area of a sphere given its radius. It validates that the radius is non-negative.\n\n```python\nfrom math import pi\nfrom typing import Union\n\ndef surface_area_sphere(radius: Union[int, float]) -> float:\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n    Formula: A = 4 * pi * r^2\n    Raises:\n        ValueError: if radius is negative\n    \"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    return 4 * pi * (radius ** 2)\n\n# Example usage\nif __name__ == \"__main__\":\n    for r in [0, 1, 5.5]:\n        print(f\"r={r} -> surface area={surface_area_sphere(r)}\")\n```\n\nIf you\u2019d like this in another language (JavaScript, C++, etc.), tell me which one and I\u2019ll adapt it."}
{"task_id": "Mbpp/65", "completion": "Here\u2019s a Python function that recursively flattens a nested list and sums all numeric elements. It raises a TypeError if a leaf item isn\u2019t numeric.\n\n```python\ndef flatten_and_sum(nested):\n    total = 0\n    for item in nested:\n        if isinstance(item, list):\n            total += flatten_and_sum(item)\n        elif isinstance(item, (int, float)):\n            total += item\n        else:\n            raise TypeError(f\"Unsupported element type: {type(item).__name__}\")\n    return total\n\n# Example usage:\ndata = [1, [2, 3], [4, [5, 6]], 7]\nprint(flatten_and_sum(data))  # Output: 28\n```\n\nIf you prefer a version that doesn\u2019t raise errors for non-numeric leaves (e.g., skips them), you can modify the else clause to skip or handle differently."}
{"task_id": "Mbpp/75", "completion": "Here is a simple Python function that filters a list of tuples to keep only those tuples where every element is divisible by k.\n\n```python\ndef filter_tuples_by_divisible_elements(tuples_list, k):\n    \"\"\"\n    Return a list containing only those tuples where every element is divisible by k.\n\n    - k must be non-zero (division by zero is undefined).\n    - An empty tuple will be included (vacuous truth). If you want to exclude empty tuples,\n      use: [t for t in tuples_list if t and all(x % k == 0 for x in t)]\n    \"\"\"\n    if k == 0:\n        raise ValueError(\"k must be non-zero\")\n\n    return [t for t in tuples_list if all(x % k == 0 for x in t)]\n```\n\nUsage example:\n\n```python\ntuples_list = [(2, 4, 6), (3, 9, 12), (4, 5, 8), (0, 6, 8)]\nk = 2\nprint(filter_tuples_by_divisible_elements(tuples_list, k))\n# Output: [(2, 4, 6), (0, 6, 8)]\n```\n\nNotes:\n- If you want to exclude empty tuples, use the version hint in the docstring or modify the condition to require non-empty tuples (e.g., [t for t in tuples_list if t and all(x % k == 0 for x in t)])."}
{"task_id": "Mbpp/82", "completion": "Here are simple implementations in several languages. All compute V = 4/3 \u00b7 \u03c0 \u00b7 r^3, where r is the radius. If you have a diameter d instead, use r = d/2.\n\nPython\ndef volume_of_sphere(radius):\n    \"\"\"Return the volume of a sphere with the given radius.\"\"\"\n    if radius < 0:\n        raise ValueError(\"radius must be non-negative\")\n    import math\n    return 4.0/3.0 * math.pi * radius**3\n\nJavaScript\nfunction volumeOfSphere(radius) {\n    if (radius < 0) throw new Error(\"radius must be non-negative\");\n    return (4/3) * Math.PI * Math.pow(radius, 3);\n}\n\nJava\npublic static double volumeOfSphere(double radius) {\n    if (radius < 0) throw new IllegalArgumentException(\"radius must be non-negative\");\n    return (4.0/3.0) * Math.PI * Math.pow(radius, 3);\n}\n\nC++\n#include <cmath>\n#include <stdexcept>\n\ndouble volumeOfSphere(double radius) {\n    if (radius < 0) throw std::invalid_argument(\"radius must be non-negative\");\n    return (4.0/3.0) * M_PI * std::pow(radius, 3);\n}\n\nC#\nusing System;\n\ndouble VolumeOfSphere(double radius) {\n    if (radius < 0) throw new ArgumentOutOfRangeException(\"radius\");\n    return (4.0/3.0) * Math.PI * Math.Pow(radius, 3);\n}"}
{"task_id": "Mbpp/84", "completion": "Here's a Python function that computes the nth term of the Newman\u2013Conway sequence, defined by:\n- a(1) = 1\n- a(2) = 1\n- for n > 2: a(n) = a(a(n-1)) + a(n - a(n-1))\n\nThe implementation uses dynamic programming (iterative, O(n) time and O(n) space).\n\n```python\ndef newman_conway(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    a = [0] * (n + 1)  # 1-based indexing\n    a[1] = 1\n    if n >= 2:\n        a[2] = 1\n\n    for i in range(3, n + 1):\n        k = a[i - 1]        # k = a(i-1)\n        a[i] = a[k] + a[i - k]\n\n    return a[n]\n\n# Example usage:\n# print([newman_conway(i) for i in range(1, 21)])\n```\n\nIf you prefer a recursive version with memoization, you can also use:\n\n```python\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef nc(n: int) -> int:\n    if n <= 2:\n        return 1\n    return nc(n - nc(n - 1)) + nc(nc(n - 1))\n\ndef newman_conway(n: int) -> int:\n    if n < 1:\n        raise ValueError(\"n must be >= 1\")\n    return nc(n)\n```"}
{"task_id": "Mbpp/72", "completion": "Here's a concise Python function. It uses the fact that n = a^2 - b^2 = (a-b)(a+b). For integers a,b, the factors (a-b) and (a+b) must have the same parity, so n must be odd or a multiple of 4. Equivalently, n % 4 != 2.\n\n```python\ndef can_be_difference_of_squares(n: int) -> bool:\n    \"\"\"\n    Check if integer n can be expressed as a^2 - b^2 for integers a, b.\n    Returns True if possible, otherwise False.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer.\")\n    return n % 4 != 2\n\n\n# Examples:\nprint(can_be_difference_of_squares(15))  # True  (e.g., 8^2 - 7^2)\nprint(can_be_difference_of_squares(2))   # False\nprint(can_be_difference_of_squares(4))   # True  (e.g., 2^2 - 0^2)\nprint(can_be_difference_of_squares(0))   # True  (0^2 - 0^2)\nprint(can_be_difference_of_squares(-2))  # False\n```"}
{"task_id": "Mbpp/69", "completion": "Here are simple implementations for checking if a list contains a given sublist (contiguous sequence). I provide examples in several common languages.\n\nPython\n- Assumes sub is a list; empty sublist is considered contained.\ndef contains_sublist(lst, sub):\n    if not sub:\n        return True\n    if len(sub) > len(lst):\n        return False\n    for i in range(len(lst) - len(sub) + 1):\n        if lst[i:i+len(sub)] == sub:\n            return True\n    return False\n\n# examples\n# contains_sublist([1,2,3,4], [2,3]) -> True\n# contains_sublist([1,2,3], [3,2]) -> False\n\nJavaScript\nfunction containsSublist(arr, sub) {\n  if (sub.length === 0) return true;\n  if (sub.length > arr.length) return false;\n  for (let i = 0; i <= arr.length - sub.length; i++) {\n    let ok = true;\n    for (let j = 0; j < sub.length; j++) {\n      if (arr[i + j] !== sub[j]) { ok = false; break; }\n    }\n    if (ok) return true;\n  }\n  return false;\n}\n\nJava\npublic static <T> boolean containsSublist(List<T> list, List<T> sub) {\n    if (sub.isEmpty()) return true;\n    if (sub.size() > list.size()) return false;\n    for (int i = 0; i <= list.size() - sub.size(); i++) {\n        boolean match = true;\n        for (int j = 0; j < sub.size(); j++) {\n            if (!list.get(i + j).equals(sub.get(j))) {\n                match = false;\n                break;\n            }\n        }\n        if (match) return true;\n    }\n    return false;\n}\n\nC++\ntemplate <class T>\nbool contains_sublist(const std::vector<T>& vec, const std::vector<T>& sub) {\n    if (sub.empty()) return true;\n    if (sub.size() > vec.size()) return false;\n    for (size_t i = 0; i + sub.size() <= vec.size(); ++i) {\n        bool ok = true;\n        for (size_t j = 0; j < sub.size(); ++j) {\n            if (vec[i + j] != sub[j]) { ok = false; break; }\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nNotes\n- These implementations check for a contiguous sublist (not just a subsequence with gaps).\n- Time complexity is O(n*m) in general (n = length of the list, m = length of the sublist). For large data, you could implement a more advanced search (e.g., KMP) to improve to O(n + m). \n- If sub is empty, many definitions consider it contained; adjust if you want a different behavior. If you want non-contiguous matching (a subsequence), the approach would differ. \n\nIf you tell me your preferred language or any edge-case behavior you want (e.g., non-empty sublist, handling of None, etc.), I can tailor the function."}
{"task_id": "Mbpp/90", "completion": "Here are two common approaches. Use the one that fits your needs.\n\n1) Simple version (splits on whitespace, keeps punctuation as part of words)\n```python\ndef longest_word_length(text):\n    if not text:\n        return 0\n    words = text.split()\n    return max((len(w) for w in words), default=0)\n\n# Example:\n# longest_word_length(\"The quick brown fox\") -> 5\n```\n\n2) Robust version (ignores punctuation, counts only alphabetic words)\n```python\nimport re\n\ndef longest_word_length_alpha(text):\n    if not text:\n        return 0\n    words = re.findall(r\"[A-Za-z]+\", text)\n    return max((len(w) for w in words), default=0)\n\n# Example:\n# longest_word_length_alpha(\"Hello, world!\") -> 5\n```\n\nOptional: you can add type hints\n```python\ndef longest_word_length(text: str) -> int:\n    ...\n```\nIf you share how you want to treat punctuation or numbers, I can tailor the function further."}
{"task_id": "Mbpp/88", "completion": "Here\u2019s a simple Python function that returns a dictionary of frequencies for all elements in a list. It uses a single pass (O(n)) and requires hashable elements.\n\nOption 1: manual dictionary update\n```\ndef freq_dict(lst):\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    return freq\n\n# Example\nprint(freq_dict([1, 2, 1, 3, 2, 1]))  # {1: 3, 2: 2, 3: 1}\n```\n\nOption 2: using Counter from collections (simpler)\n```\nfrom collections import Counter\n\ndef freq_dict(lst):\n    return dict(Counter(lst))\n\n# Example\nprint(freq_dict([1, 2, 1, 3, 2, 1]))  # {1: 3, 2: 2, 3: 1}\n```\n\nNotes:\n- Elements must be hashable to be used as dictionary keys (e.g., lists cannot be keys unless you convert them to tuples or strings).\n- The result dictionary\u2019s keys are the unique elements, and values are their counts. If you need to preserve the order of first appearance, you can post-process or use an OrderedDict with a similar approach."}
{"task_id": "Mbpp/74", "completion": "I\u2019m not sure which language or exact meaning you have for \u201cpatterns array.\u201d Here\u2019s a flexible solution in Python for the common interpretation: the pattern specifies which positions should be equal/different. Each unique token in the pattern maps to a value in the sequence, and the same token must map to the same value everywhere, with a bijection (different tokens map to different values).\n\nPython version\n\n```python\ndef follows_pattern(patterns, seq):\n    \"\"\"\n    patterns: a list (or sequence) of hashable tokens, e.g. ['A','B','B','A'] \n    seq: a list of values to test against the pattern\n    Returns True if there is a bijection between pattern tokens and sequence values\n    such that equal tokens correspond to equal values and different tokens to different values.\n    \"\"\"\n    if len(patterns) != len(seq):\n        return False\n\n    pat_to_val = {}\n    val_to_pat = {}\n\n    for p, v in zip(patterns, seq):\n        if p in pat_to_val:\n            if pat_to_val[p] != v:\n                return False\n        else:\n            pat_to_val[p] = v\n\n        if v in val_to_pat:\n            if val_to_pat[v] != p:\n                return False\n        else:\n            val_to_pat[v] = p\n\n    return True\n```\n\nUsage examples\n\n- True case\n  - patterns = ['A','B','B','A']\n  - seq = ['dog','cat','cat','dog']\n  - follows_pattern(patterns, seq) -> True\n\n- True case with numbers\n  - patterns = ['A','B','C','A']\n  - seq = [1, 2, 3, 1]\n  - follows_pattern(patterns, seq) -> True\n\n- False case (different tokens map to same value)\n  - patterns = ['A','B','C','A']\n  - seq = [1, 2, 2, 1]\n  - follows_pattern(patterns, seq) -> False\n\nIf you want a looser version (no requirement that different pattern tokens map to different values, i.e., non-bijective), remove the val_to_pat checks.\n\nJavaScript version (equivalent)\n\n```javascript\nfunction followsPattern(patterns, seq) {\n  if (patterns.length !== seq.length) return false;\n\n  const patToVal = new Map();\n  const valToPat = new Map();\n\n  for (let i = 0; i < patterns.length; i++) {\n    const p = patterns[i];\n    const v = seq[i];\n\n    if (patToVal.has(p)) {\n      if (patToVal.get(p) !== v) return false;\n    } else {\n      patToVal.set(p, v);\n    }\n\n    if (valToPat.has(v)) {\n      if (valToPat.get(v) !== p) return false;\n    } else {\n      valToPat.set(v, p);\n    }\n  }\n\n  return true;\n}\n```\n\nIf you can share:\n- your preferred language,\n- what exactly constitutes \u201cfollows the sequence\u201d (bijective mapping vs. just matching equalities),\n- an example pattern and sequence,\n\nI can tailor the function precisely to your needs."}
{"task_id": "Mbpp/86", "completion": "The nth centered hexagonal number is given by C(n) = 3n(n\u22121) + 1, with n \u2265 1.\nExamples: n=1 \u2192 1, n=2 \u2192 7, n=3 \u2192 19, ...\n\nPython function (1-based n):\n\ndef centered_hexagonal(n):\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 3 * n * (n - 1) + 1\n\nNotes:\n- This runs in O(1) time and uses O(1) extra space.\n- If you prefer a 0-based index (where f(0) = 1), use f(k) = 3k(k+1) + 1."}
{"task_id": "Mbpp/67", "completion": "There are two common interpretations. The standard one is:\n- The number of ways to partition a set of size n is the Bell number B_n.\n\nIf you literally meant \u201ca set whose size is a Bell number (B_n)\u201d, then the answer is B_{B_n} (the Bell number for the size B_n).\n\nHere are Python functions for the standard case (computing Bell numbers) and a quick note on the other interpretation.\n\n1) Compute Bell numbers B_0, B_1, ..., B_n (using Bell triangle)\n\ndef bell_numbers_upto(n):\n    # Returns [B_0, B_1, ..., B_n]\n    if n < 0:\n        return []\n    # Bell triangle: Bell[i][j] with Bell[i][0] = B_i\n    Bell = [[0]*(n+1) for _ in range(n+1)]\n    Bell[0][0] = 1\n    for i in range(1, n+1):\n        Bell[i][0] = Bell[i-1][i-1]\n        for j in range(1, i+1):\n            Bell[i][j] = Bell[i-1][j-1] + Bell[i][j-1]\n    return [Bell[i][0] for i in range(n+1)]\n\n# Example\nprint(bell_numbers_upto(6))  # [1, 1, 2, 5, 15, 52, 203]\n\n2) Compute a single Bell number B_n (memory-efficient)\n\ndef bell_number(n):\n    if n < 0:\n        raise ValueError(\"n must be >= 0\")\n    prev = [0]*(n+1)  # previous row\n    curr = [0]*(n+1)  # current row\n    prev[0] = 1  # B_0\n    for i in range(1, n+1):\n        curr[0] = prev[i-1]\n        for j in range(1, i+1):\n            curr[j] = prev[j-1] + curr[j-1]\n        prev, curr = curr, prev  # swap\n    return prev[0]\n\n# Example\nprint(bell_number(6))  # 203\n\n3) Quick clarifications\n- If you meant the number of partitions of a set of size n, use B_n from above.\n- If you literally want the number of partitions of a set of size B_n, that is B_{B_n}. You can compute B_n first and then pass that into bell_number:\n# number of partitions of a set of size B_n\ndef partitions_of_size_B_n(n):\n    B_n = bell_number(n)\n    return bell_number(B_n)\n\nExample:\n# partitions of size B_6 (which is 203)\nprint(partitions_of_size_B_n(6))  # yields B_203 (a very large number)\n\nIf you tell me your target language or any constraints (speed, memory, n max), I can tailor the function and provide a single-file snippet accordingly."}
{"task_id": "Mbpp/91", "completion": "Here are simple implementations in a few common languages. They return true if the given substring appears in any string within the list.\n\nPython\ndef contains_substring(values, substring, case_sensitive=True):\n    if not case_sensitive:\n        substring = substring.lower()\n        values = [v.lower() for v in values]\n    return any(substring in v for v in values)\n\n# Example:\n# contains_substring([\"apple pie\", \"banana\", \"cherry\"], \"pie\") -> True\n\nJavaScript\nfunction containsSubstring(list, substring) {\n  return list.some(s => s.includes(substring));\n}\n\n// Case-insensitive variant:\nfunction containsSubstringCI(list, substring) {\n  const t = substring.toLowerCase();\n  return list.some(s => s.toLowerCase().includes(t));\n}\n\nJava\nimport java.util.List;\n\npublic static boolean containsSubstring(List<String> values, String substring) {\n  if (values == null || substring == null) return false;\n  for (String s : values) {\n    if (s != null && s.contains(substring)) return true;\n  }\n  return false;\n}\n\nC#\nusing System.Collections.Generic;\n\npublic static bool ContainsSubstring(IEnumerable<string> values, string substring)\n{\n    if (values == null || substring == null) return false;\n    foreach (var s in values)\n    {\n        if (s != null && s.Contains(substring)) return true;\n    }\n    return false;\n}"}
{"task_id": "Mbpp/71", "completion": "Here are simple examples in Python. If you\u2019d like another language, tell me which one.\n\n1) Simple function using the built-in sort (returns a new list)\n- Works with comparable elements; supports key and reverse.\n\ndef sort_list(lst, key=None, reverse=False):\n    \"\"\"\n    Return a new list with elements of lst sorted.\n    - key: function to extract a comparison key from each element (optional)\n    - reverse: whether to sort in descending order (optional)\n    \"\"\"\n    return sorted(lst, key=key, reverse=reverse)\n\n# Examples\nprint(sort_list([3, 1, 4, 1, 5]))                 # [1, 1, 3, 4, 5]\nprint(sort_list([\"apple\", \"banana\", \"pear\"], reverse=True))  # ['pear', 'banana', 'apple']\n\n2) In-place sort (sorts the original list)\ndef sort_in_place(lst, key=None, reverse=False):\n    \"\"\"\n    Sort lst in place.\n    \"\"\"\n    lst.sort(key=key, reverse=reverse)\n\n# Example\na = [5, 2, 9, 1]\nsort_in_place(a)\nprint(a)  # [1, 2, 5, 9]\n\n3) Simple educational in-Python algorithm (insertion sort, supports key and reverse)\ndef insertion_sort(lst, key=None, reverse=False):\n    \"\"\"\n    Return a new list sorted using insertion sort (educational; O(n^2)).\n    \"\"\"\n    arr = lst[:]\n    for i in range(1, len(arr)):\n        cur = arr[i]\n        j = i - 1\n        while j >= 0:\n            aj = key(arr[j]) if key else arr[j]\n            cur_key = key(cur) if key else cur\n            # decide order based on reverse\n            if (aj > cur_key and not reverse) or (aj < cur_key and reverse):\n                arr[j + 1] = arr[j]\n                j -= 1\n            else:\n                break\n        arr[j + 1] = cur\n    return arr\n\n# Example\nprint(insertion_sort([3, 1, 4, 1, 5]))  # [1, 1, 3, 4, 5]\n\nWant this in a different language (JavaScript, Java, C++, etc.) or a specific sorting algorithm (merge sort, quicksort) instead? Let me know your language and any constraints (in-place, stability, custom comparator), and I\u2019ll tailor the function."}
{"task_id": "Mbpp/77", "completion": "Here are two simple options.\n\n1) For integers (using modulo):\n```python\ndef is_divisible_by_11(n: int) -> bool:\n    \"\"\"Return True if n is divisible by 11, else False.\"\"\"\n    return n % 11 == 0\n```\n\n2) For numbers given as strings (useful for very large numbers):\n```python\ndef is_divisible_by_11_string(s: str) -> bool:\n    \"\"\"\n    Return True if the numeric value represented by s is divisible by 11.\n    Accepts optional leading sign (+/-) and ignores whitespace.\n    \"\"\"\n    s = s.strip()\n    if not s:\n        raise ValueError(\"Empty string\")\n    if s[0] in \"+-\":\n        s = s[1:]\n    if not s.isdigit():\n        raise ValueError(\"Invalid numeric string\")\n\n    rem = 0\n    for ch in s:\n        rem = (rem * 10 + (ord(ch) - 48)) % 11\n    return rem == 0\n```\n\nUsage examples:\n- is_divisible_by_11(121) -> True\n- is_divisible_by_11(123) -> False\n- is_divisible_by_11_string(\"121\") -> True\n- is_divisible_by_11_string(\"-11\") -> True"}
{"task_id": "Mbpp/87", "completion": "Here\u2019s a simple Python function that merges three dictionaries into a new one. If keys overlap, values from the last dictionary take precedence.\n\nCode:\ndef merge_three_dicts(d1, d2, d3):\n    \"\"\"\n    Merge three dictionaries into a new dictionary.\n    If the same key exists in more than one dict, the value from d3 prevails.\n    \"\"\"\n    d1 = d1 or {}\n    d2 = d2 or {}\n    d3 = d3 or {}\n    return {**d1, **d2, **d3}\n\n# Example\na = {'x': 1, 'y': 2}\nb = {'y': 3, 'z': 4}\nc = {'z': 5, 'w': 6}\nprint(merge_three_dicts(a, b, c))\n# Output: {'x': 1, 'y': 3, 'z': 5, 'w': 6}\n\nIf you want to merge nested dictionaries recursively, use a deep-merge variant:\n\nCode:\ndef deep_merge_three(d1, d2, d3):\n    def deep_merge(*maps):\n        result = {}\n        for m in maps:\n            if not isinstance(m, dict):\n                continue\n            for k, v in m.items():\n                if k in result and isinstance(result[k], dict) and isinstance(v, dict):\n                    result[k] = deep_merge(result[k], v)\n                else:\n                    result[k] = v\n        return result\n    return deep_merge(d1 or {}, d2 or {}, d3 or {})\n\n# Example\na = {'a': {'x': 1}, 'b': 2}\nb = {'a': {'y': 3}, 'b': 4}\nc = {'a': {'x': 10}, 'c': 5}\nprint(deep_merge_three(a, b, c))\n# Output: {'a': {'x': 10, 'y': 3}, 'b': 4, 'c': 5}"}
{"task_id": "Mbpp/93", "completion": "Here\u2019s a simple, efficient implementation in Python using exponentiation by squaring. It expects an integer exponent (b). It handles negative exponents by returning a float.\n\ndef power(a, b):\n    \"\"\"Compute a^b using exponentiation by squaring.\n       b must be an integer (positive, zero, or negative).\n    \"\"\"\n    if not isinstance(b, int):\n        raise TypeError(\"Exponent must be an integer for this implementation.\")\n    if b == 0:\n        return 1\n    if b < 0:\n        if a == 0:\n            raise ZeroDivisionError(\"0 cannot be raised to a negative power\")\n        return 1.0 / power(a, -b)\n\n    result = 1\n    base = a\n    exp = b\n    while exp > 0:\n        if exp & 1:\n            result *= base\n        base *= base\n        exp >>= 1\n    return result\n\nUsage examples:\n- power(2, 10) -> 1024\n- power(2, -3) -> 0.125\n\nIf you want this in another language (JavaScript, Java, C++, etc.), tell me which one and I\u2019ll provide a version tailored to it."}
{"task_id": "Mbpp/94", "completion": "Here are two Python options. Both return the first element of the tuple that has the smallest second value (and in case of ties, the first such tuple in the list).\n\nOption 1: Using min with a key (concise)\ndef first_of_min_second(pairs):\n    if not pairs:\n        raise ValueError(\"pairs must not be empty\")\n    return min(pairs, key=lambda t: t[1])[0]\n\nOption 2: Explicit loop (more verbose, but clear)\ndef first_of_min_second_loop(pairs):\n    if not pairs:\n        raise ValueError(\"pairs must not be empty\")\n    best_first, best_second = pairs[0]\n    for a, b in pairs[1:]:\n        if b < best_second:\n            best_first, best_second = a, b\n    return best_first\n\nExample:\npairs = [(5, 3), (2, 4), (7, 3), (1, 5)]\nprint(first_of_min_second(pairs))  # Output: 5\n\nNotes:\n- If pairs is empty, the function raises ValueError (you can change this to return None if you prefer).\n- In case of ties for the smallest second value, the first tuple in the input order is chosen."}
{"task_id": "Mbpp/92", "completion": "An undulating (zigzag) number is one whose digits alternate up and down: d1 < d2 > d3 < d4 > d5 ... or d1 > d2 < d3 > d4 < d5 ..., with no two consecutive digits equal.\n\nHere\u2019s a Python function that checks this:\n\ndef is_undulating(n):\n    s = str(abs(n))  # work with absolute value, digits only\n    if len(s) < 2:\n        return True  # 0-9 are trivially undulating\n\n    prev_diff = None\n    for i in range(1, len(s)):\n        diff = int(s[i]) - int(s[i-1])\n        if diff == 0:\n            return False  # equal consecutive digits break the pattern\n        if prev_diff is not None and diff * prev_diff >= 0:\n            return False  # same sign as previous diff -> not alternating\n        prev_diff = diff\n    return True\n\n# Examples:\nprint(is_undulating(121))  # True (1<2>1)\nprint(is_undulating(1324)) # True (1<3>2<4)\nprint(is_undulating(1234)) # False (1<2<3\u2026)\n\nIf you\u2019d like this in another language (C++, JavaScript, Java, etc.), tell me which one and I\u2019ll provide a version."}
{"task_id": "Mbpp/98", "completion": "Here\u2019s a simple Python function that multiplies all numbers in a list and divides by the list length.\n\n```python\ndef multiply_and_divide(nums):\n    \"\"\"\n    Multiply all numbers in the list 'nums' and divide by its length.\n    Returns a float. Raises ValueError if the list is empty.\n    \"\"\"\n    if nums is None or len(nums) == 0:\n        raise ValueError(\"Input list must not be empty.\")\n    \n    prod = 1\n    for x in nums:\n        prod *= x\n    return prod / len(nums)\n\n# Example\nprint(multiply_and_divide([2, 5, 3]))  # (2*5*3) / 3 = 10.0\n```\n\nNotes:\n- The result is a float due to the division.\n- It raises an error for empty input to avoid division by zero.\n- You can adapt it to other languages if you\u2019d like."}
{"task_id": "Mbpp/95", "completion": "Here's a simple, robust function to find the length of the smallest inner list in a list of lists. It returns 0 if the outer list is empty, and it validates input to ensure you actually pass a list of lists.\n\n```python\ndef length_of_smallest_list(lists_of_lists):\n    \"\"\"\n    Return the length of the smallest inner list within a list of lists.\n\n    Args:\n        lists_of_lists (list[list]): A list whose elements are lists.\n\n    Returns:\n        int: Length of the smallest inner list. Returns 0 if the outer list is empty.\n\n    Raises:\n        TypeError: If input is not a list of lists.\n    \"\"\"\n    if not isinstance(lists_of_lists, list):\n        raise TypeError(\"Input must be a list of lists.\")\n    if len(lists_of_lists) == 0:\n        return 0\n    for i, sub in enumerate(lists_of_lists):\n        if not isinstance(sub, list):\n            raise TypeError(f\"Element at index {i} is not a list.\")\n    return min(len(sub) for sub in lists_of_lists)\n```\n\nExamples:\n- length_of_smallest_list([[1, 2, 3], [4, 5], [], [9]]) -> 0\n- length_of_smallest_list([[1], [2, 3, 4]]) -> 1\n\nIf you prefer to raise an error when the outer list is empty, replace the early return 0 with a raise ValueError(\"Outer list must contain at least one inner list\")."}
{"task_id": "Mbpp/96", "completion": "Here\u2019s a simple, efficient Python function to count the number of positive divisors of a given integer (handling negative inputs by using their absolute value). For zero, it raises an error since 0 has infinitely many divisors.\n\n```python\ndef count_divisors(n: int) -> int:\n    \"\"\"\n    Return the number of positive divisors of n.\n    For n == 0, raises ValueError.\n    Works for negative numbers by taking abs(n).\n    \"\"\"\n    if n == 0:\n        raise ValueError(\"Divisors of 0 are not finite.\")\n    \n    n = abs(n)\n    total = 1\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            exp = 0\n            while n % i == 0:\n                n //= i\n                exp += 1\n            total *= (exp + 1)\n        i += 1\n    if n > 1:\n        total *= 2  # remaining prime factor\n    return total\n```\n\nExamples:\n- count_divisors(36) -> 9\n- count_divisors(1)  -> 1\n- count_divisors(-12) -> 6\n\nComplexity: O(sqrt(n)) time, O(1) extra space."}
{"task_id": "Mbpp/97", "completion": "Here's a simple Python function that flattens a list of lists and returns a dictionary with the frequency of each element.\n\ndef frequency_of_elements(list_of_lists):\n    \"\"\"\n    Flatten a list of lists and count the frequency of each element.\n    Returns a dict: element -> count.\n    Elements must be hashable.\n    \"\"\"\n    from collections import Counter\n    return dict(Counter(item for sub in list_of_lists for item in sub))\n\n# Example usage\ndata = [[1, 2, 2], [3], [2, 4, 4, 4]]\nprint(frequency_of_elements(data))\n# Output: {1: 1, 2: 3, 3: 1, 4: 3}"}
{"task_id": "Mbpp/99", "completion": "Here is a straightforward Python implementation that converts a non-negative integer to its binary representation as a string with no leading zeros. It also handles zero and negative numbers (as a sign).\n\n- Python:\n\ndef decimal_to_binary(n: int) -> str:\n    if n == 0:\n        return \"0\"\n    neg = n < 0\n    n = abs(n)\n    bits = []\n    while n:\n        bits.append('1' if (n & 1) else '0')\n        n >>= 1\n    result = ''.join(reversed(bits))\n    return ('-' + result) if neg else result\n\nNotes:\n- This produces \"0\" for 0, no leading zeros for positive numbers.\n- If you want a version that uses Python\u2019s built-in conversion (and handles sign), you can use:\n  def decimal_to_binary_builtin(n):\n      if n == 0:\n          return \"0\"\n      return ('-' if n < 0 else '') + bin(abs(n))[2:]\n\nWould you like this in another language (JavaScript, Java, C++, etc.)?"}
{"task_id": "Mbpp/101", "completion": "Here is a simple function that returns the kth element of an array using 1-based indexing. It checks bounds (k must be between 1 and len(arr)) and returns arr[k-1] since most languages use 0-based indexing internally.\n\nPython\ndef kth_element(arr, k):\n    \"\"\"\n    Return the kth element of arr using 1-based indexing.\n    Raises IndexError if k is out of bounds.\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k must be between 1 and len(arr)\")\n    return arr[k - 1]\n\nUsage: kth_element([10, 20, 30, 40], 3) -> 30\n\nJavaScript\nfunction kthElement(arr, k) {\n  if (k < 1 || k > arr.length) {\n    throw new RangeError(\"k out of bounds\");\n  }\n  return arr[k - 1];\n}\n\nJava\npublic static <T> T kthElement(T[] arr, int k) {\n    if (k < 1 || k > arr.length) {\n        throw new IndexOutOfBoundsException(\"k out of bounds\");\n    }\n    return arr[k - 1];\n}\n\n// If using List<T> instead of array:\npublic static <T> T kthElement(List<T> list, int k) {\n    if (k < 1 || k > list.size()) {\n        throw new IndexOutOfBoundsException(\"k out of bounds\");\n    }\n    return list.get(k - 1);\n}\n\nC++\n#include <vector>\n#include <stdexcept>\n\ntemplate <typename T>\nT kthElement(const std::vector<T>& arr, int k) {\n    if (k < 1 || k > (int)arr.size()) {\n        throw std::out_of_range(\"k out of bounds\");\n    }\n    return arr[k - 1];\n}\n\nNotes\n- The function uses 1-based indexing for the input k, but converts to 0-based indexing internally (k - 1).\n- It runs in O(1) time and O(1) extra space (besides the input data).\n- If k is out of bounds, it raises/throws an error.\n\nIf you tell me your preferred language, I can tailor a version exactly for that language with proper error handling."}
{"task_id": "Mbpp/118", "completion": "Here\u2019s a simple Python function that splits a string on the space character:\n\ndef split_on_space(s: str) -> list[str]:\n    return s.split(' ')\n\nNotes:\n- This uses the literal space character as the delimiter.\n- If the string has consecutive spaces, you'll get empty strings in the result. If you want to ignore empties:\n\ndef split_on_space_no_empty(s: str) -> list[str]:\n    return [tok for tok in s.split(' ') if tok]"}
{"task_id": "Mbpp/105", "completion": "Here's a concise function that counts only True values of the bool type (it ignores integers like 1 or other truthy values):\n\ndef count_true_booleans(lst):\n    return sum(1 for x in lst if isinstance(x, bool) and x)\n\n# Example\nlst = [True, False, True, 1, \"True\", None]\nprint(count_true_booleans(lst))  # Output: 2\n\nIf you want to ensure only strict bool type is counted (and exclude any subclass of bool), you can use type(x) is bool instead of isinstance."}
{"task_id": "Mbpp/119", "completion": "Here's an efficient O(log n) solution using binary search. It relies on the fact that all elements appear twice except one, and the array is sorted.\n\n```python\ndef single_non_duplicate(nums):\n    \"\"\"\n    Find the element that appears only once in a sorted array\n    where every other element appears exactly twice.\n\n    Returns the single element.\n    \"\"\"\n    if not nums:\n        raise ValueError(\"Input array must not be empty.\")\n    n = len(nums)\n    if n == 1:\n        return nums[0]\n\n    low, high = 0, n - 1\n    while low < high:\n        mid = (low + high) // 2\n        # Ensure mid is even so that the pair is (mid, mid+1)\n        if mid % 2 == 1:\n            mid -= 1\n\n        if nums[mid] == nums[mid + 1]:\n            # Pair is intact on the left; single element is on the right\n            low = mid + 2\n        else:\n            # Pair is broken here; single element is at mid or to the left\n            high = mid\n\n    return nums[low]\n\n# Example usage:\n# print(single_non_duplicate([1,1,2,3,3,4,4,5,5]))  # Output: 2\n# print(single_non_duplicate([7]))  # Output: 7\n```\n\nIf you prefer a simple O(n) approach (no binary search), you can scan by pairs:\n```python\ndef single_non_duplicate_linear(nums):\n    for i in range(0, len(nums), 2):\n        if i + 1 >= len(nums) or nums[i] != nums[i + 1]:\n            return nums[i]\n    return None\n```\nThe linear version is easier to understand but runs in linear time."}
{"task_id": "Mbpp/113", "completion": "Here are simple implementations in a couple of popular languages. They return true if the string represents an integer (optionally with a sign), and false otherwise.\n\nPython (regex)\n- Uses a strict match for optional sign followed by digits\ndef is_integer_string(s):\n    import re\n    return bool(re.fullmatch(r'[+-]?\\d+', s.strip()))\n\nPython (no regex)\ndef is_integer_string_no_regex(s):\n    s = s.strip()\n    if not s:\n        return False\n    if s[0] in '+-':\n        return len(s) > 1 and s[1:].isdigit()\n    return s.isdigit()\n\nJavaScript\nfunction isIntegerString(s) {\n  return typeof s === 'string' && /^[+-]?\\d+$/.test(s.trim());\n}\n\nIf you want a solution in a different language, tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/89", "completion": "Could you clarify what you mean by \u201cclosest smaller number than n\u201d? There are a couple of common interpretations:\n\n- The immediate predecessor: the closest smaller integer to n, i.e., n - 1.\n- The largest number smaller than n that can be formed by permuting the digits of n (previous permutation).\n\nBelow are simple implementations for both interpretations.\n\n1) Immediate predecessor (the simplest interpretation)\nPython:\ndef closest_smaller(n: int) -> int:\n    return n - 1\n\nJavaScript:\nfunction closestSmaller(n) {\n  return n - 1;\n}\n\n2) Largest number smaller than n formed by permuting n\u2019s digits (previous permutation)\nPython:\ndef closest_smaller_by_digits(n: int) -> int:\n    s = list(str(n))\n    i = len(s) - 2\n    # Find the first position from the right where s[i] > s[i+1]\n    while i >= 0 and s[i] <= s[i + 1]:\n        i -= 1\n    if i < 0:\n        return -1  # no smaller permutation with the same digits\n\n    # Find the largest digit to the right of i that is < s[i]\n    max_digit = None\n    j = -1\n    for k in range(i + 1, len(s)):\n        if s[k] < s[i]:\n            if max_digit is None or s[k] > max_digit:\n                max_digit = s[k]\n                j = k\n\n    if j == -1:\n        return -1\n\n    # If swapping would put '0' at the front, try to pick a non-zero candidate (when i == 0)\n    if i == 0 and max_digit == '0':\n        found = False\n        for k in range(i + 1, len(s)):\n            if s[k] < s[i] and s[k] != '0':\n                max_digit = s[k]\n                j = k\n                found = True\n                break\n        if not found:\n            return -1\n\n    s[i], s[j] = s[j], s[i]\n    # Put the suffix in descending order to get the largest possible number below n\n    s[i + 1:] = sorted(s[i + 1:], reverse=True)\n\n    if s[0] == '0':\n        return -1  # leading zero would reduce digit count\n    return int(''.join(s))\n\nExamples:\n- closest_smaller_by_digits(31524) might yield 31245 (the exact result depends on digits).\n\nJavaScript (previous-permutation version):\nfunction closestSmallerByDigits(n) {\n  const s = String(n).split('');\n  let i = s.length - 2;\n  while (i >= 0 && s[i] <= s[i + 1]) i--;\n  if (i < 0) return -1;\n\n  // find largest digit to the right of i that is < s[i]\n  let maxDigit = null;\n  let j = -1;\n  for (let k = i + 1; k < s.length; k++) {\n    if (s[k] < s[i]) {\n      if (maxDigit === null || s[k] > maxDigit) {\n        maxDigit = s[k];\n        j = k;\n      }\n    }\n  }\n\n  if (j === -1) return -1;\n  if (i === 0 && maxDigit === '0') {\n    // try another candidate not '0'\n    let found = false;\n    for (let k = i + 1; k < s.length; k++) {\n      if (s[k] < s[i] && s[k] !== '0') {\n        maxDigit = s[k];\n        j = k;\n        found = true;\n        break;\n      }\n    }\n    if (!found) return -1;\n  }\n\n  [s[i], s[j]] = [s[j], s[i]];\n  s.splice(i + 1, s.length - (i + 1), ...s.slice(i + 1).sort((a, b) => b.localeCompare(a)));\n  if (s[0] === '0') return -1;\n  return parseInt(s.join(''), 10);\n}\n\nIf you can tell me which interpretation you want (and your preferred language), I can tailor the solution and tests accordingly."}
{"task_id": "Mbpp/125", "completion": "Here's a Python function that computes the maximum difference between the number of 0s and number of 1s in any substring of a binary string.\n\nIdea:\n- Map 0 -> +1 and 1 -> -1.\n- The problem becomes finding the maximum subarray sum (Kadane's algorithm) on this mapped array.\n- The maximum subarray sum equals the maximum value of (#0s - #1s) for some substring.\n\nCode:\n\n```python\ndef max_diff_zeros_minus_ones(s: str) -> int:\n    \"\"\"\n    Returns the maximum value of (count(0) - count(1)) over all substrings of s.\n    If s is empty, returns 0.\n    \"\"\"\n    if not s:\n        return 0\n\n    # Map: '0' -> +1, '1' -> -1\n    first_val = 1 if s[0] == '0' else -1\n    max_ending_here = first_val\n    max_so_far = first_val\n\n    for ch in s[1:]:\n        val = 1 if ch == '0' else -1\n        max_ending_here = max(val, max_ending_here + val)\n        max_so_far = max(max_so_far, max_ending_here)\n\n    return max_so_far\n```\n\nExamples:\n- max_diff_zeros_minus_ones(\"000\") -> 3\n- max_diff_zeros_minus_ones(\"111\") -> -1\n- max_diff_zeros_minus_ones(\"010101\") -> 1\n\nComplexity:\n- Time: O(n), where n is the length of the string\n- Space: O(1) extra space"}
{"task_id": "Mbpp/108", "completion": "Here are two common approaches in Python.\n\n1) General solution (works for any lists; sorts the combined result)\n- Simple and concise.\n\ndef merge_three_lists(a, b, c):\n    \"\"\"\n    Merge three lists into a single sorted list.\n    Works with any comparable elements (unsorted inputs allowed).\n    \"\"\"\n    return sorted(a + b + c)\n\n2) If the three input lists are already sorted (more efficient)\n- Uses a three-pointer merge (O(n1 + n2 + n3)).\n\ndef merge_three_sorted(a, b, c):\n    i = j = k = 0\n    res = []\n    while i < len(a) or j < len(b) or k < len(c):\n        va = a[i] if i < len(a) else float('inf')\n        vb = b[j] if j < len(b) else float('inf')\n        vc = c[k] if k < len(c) else float('inf')\n\n        if va <= vb and va <= vc:\n            res.append(va)\n            i += 1\n        elif vb <= va and vb <= vc:\n            res.append(vb)\n            j += 1\n        else:\n            res.append(vc)\n            k += 1\n    return res\n\nExamples:\n- General: merge_three_lists([3,1], [4,2], [5]) -> [1, 2, 3, 4, 5]\n- Sorted inputs: merge_three_sorted([1,4,7], [2,3,9], [0,5,6]) -> [0, 1, 2, 3, 4, 5, 6, 7, 9]"}
{"task_id": "Mbpp/102", "completion": "Here are common implementations that convert snake_case to camelCase (lowerCamelCase). They skip empty parts and lowercase input parts before capitalizing subsequent words.\n\nPython\ndef snake_to_camel(s: str) -> str:\n    parts = [p for p in s.split('_') if p]\n    if not parts:\n        return ''\n    first = parts[0].lower()\n    rest = [p.capitalize() for p in parts[1:]]\n    return first + ''.join(rest)\n\n# Example\n# print(snake_to_camel(\"snake_case_string\"))  # \"snakeCaseString\"\n\nJavaScript\nfunction snakeToCamel(s) {\n  return s\n    .split('_')\n    .filter(Boolean)\n    .map((w, i) =>\n      i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()\n    )\n    .join('');\n}\n\nTypeScript (with types)\nfunction snakeToCamel(s: string): string {\n  return s\n    .split('_')\n    .filter(Boolean)\n    .map((w, i) => (i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()))\n    .join('');\n}\n\nJava\npublic static String toCamelCase(String s) {\n    if (s == null || s.isEmpty()) return \"\";\n    String[] parts = s.split(\"_+\");\n    StringBuilder result = new StringBuilder();\n    for (String p : parts) {\n        if (p.isEmpty()) continue;\n        String word = p.toLowerCase();\n        if (result.length() == 0) {\n            result.append(word);\n        } else {\n            result.append(Character.toUpperCase(word.charAt(0)))\n                  .append(word.substring(1));\n        }\n    }\n    return result.toString();\n}\n\nC#\nusing System;\n\npublic static string SnakeToCamel(string s) {\n    if (string.IsNullOrEmpty(s)) return string.Empty;\n    var parts = s.Split(new[] { '_' }, StringSplitOptions.RemoveEmptyEntries);\n    for (int i = 0; i < parts.Length; i++) parts[i] = parts[i].ToLower();\n    var result = parts.Length > 0 ? parts[0] : \"\";\n    for (int i = 1; i < parts.Length; i++) {\n        result += char.ToUpper(parts[i][0]) + parts[i].Substring(1);\n    }\n    return result;\n}\n\nNotes and variations\n- If you want PascalCase (UpperCamelCase) instead, capitalize the first word as well.\n- If you want to preserve some original casing (instead of lowercasing everything), remove the toLowerCase calls.\n- If the input may contain hyphens or other separators, you can split on a regex like /[_-]+/ and adjust accordingly.\n\nWould you like a version in a specific language or with additional features (e.g., handling hyphens, preserving digits, or producing PascalCase)?"}
{"task_id": "Mbpp/106", "completion": "Here are two common ways, depending on whether you\u2019re dealing with a single tuple or a collection of tuples.\n\n1) Append a list to a single tuple:\ndef append_list_to_tuple(t, lst):\n    \"\"\"\n    Return a new tuple formed by appending the elements of lst to the end of tuple t.\n    \"\"\"\n    return t + tuple(lst)\n\n2) Append the same list to each tuple in a collection (list of tuples):\ndef append_list_to_each_tuple(tuples, lst):\n    \"\"\"\n    Given an iterable of tuples, append the elements of lst to each tuple.\n    Returns a list of new tuples.\n    \"\"\"\n    lst_t = tuple(lst)\n    return [t + lst_t for t in tuples]\n\nExamples:\n- append_list_to_tuple((1, 2, 3), [4, 5]) -> (1, 2, 3, 4, 5)\n- append_list_to_each_tuple([(1, 2), (3, 4)], [5, 6]) -> [(1, 2, 5, 6), (3, 4, 5, 6)]\n\nNote: Tuples are immutable, so you can\u2019t modify them in place; you always create and return a new tuple."}
{"task_id": "Mbpp/104", "completion": "Here are two Python options for sorting each sublist of strings in a list of lists.\n\nOption 1: Return a new list with each sublist sorted (non-destructive)\n```python\ndef sort_sublists_of_strings(lists_of_lists, case_insensitive=False, reverse=False):\n    \"\"\"\n    Return a new list where each sublist is sorted individually.\n\n    - lists_of_lists: list of lists, each containing strings\n    - case_insensitive: if True, sort ignoring case (s.lower() as key)\n    - reverse: if True, sort in reverse order\n    \"\"\"\n    if not isinstance(lists_of_lists, list):\n        raise TypeError(\"lists_of_lists must be a list of lists\")\n\n    result = []\n    for sub in lists_of_lists:\n        if not isinstance(sub, list):\n            raise TypeError(\"Each item must be a sublist (list) of strings\")\n        if any(not isinstance(x, str) for x in sub):\n            raise ValueError(\"All elements of each sublist must be strings\")\n\n        key = (lambda s: s.lower()) if case_insensitive else None\n        result.append(sorted(sub, key=key, reverse=reverse))\n    return result\n```\n\nOption 2: Sort each sublist in place (in-place modification)\n```python\ndef sort_sublists_in_place(lists_of_lists, case_insensitive=False, reverse=False):\n    \"\"\"\n    Sort each sublist in place. Returns None.\n    - lists_of_lists: list of lists, each containing strings\n    - case_insensitive: if True, sort ignoring case\n    - reverse: if True, sort in reverse order\n    \"\"\"\n    if not isinstance(lists_of_lists, list):\n        raise TypeError(\"lists_of_lists must be a list of lists\")\n\n    for sub in lists_of_lists:\n        if not isinstance(sub, list):\n            raise TypeError(\"Each item must be a sublist (list) of strings\")\n        if any(not isinstance(x, str) for x in sub):\n            raise ValueError(\"All elements of each sublist must be strings\")\n\n        key = (lambda s: s.lower()) if case_insensitive else None\n        sub.sort(key=key, reverse=reverse)\n```\n\nUsage examples:\n```python\nlists = [[\"banana\", \"apple\", \"cherry\"], [\"Dog\", \"ant\", \"Cat\"]]\n\n# Non-destructive\nsorted_lists = sort_sublists_of_strings(lists, case_insensitive=True)\nprint(sorted_lists)\n# [['apple', 'banana', 'cherry'], ['ant', 'Cat', 'Dog']]\n\n# In-place\nsort_sublists_in_place(lists, case_insensitive=False)\nprint(lists)\n# [['apple', 'banana', 'cherry'], ['Cat', 'Dog', 'ant']]\n```\n\nIf you want a one-liner approach for simple use, you can also just do:\n- For non-destructive: [sorted(sub) for sub in lists_of_lists]\n- For in-place: [sub.sort() for sub in lists_of_lists]"}
{"task_id": "Mbpp/126", "completion": "Here's a simple Python function. It uses that the common divisors of a and b are exactly the divisors of gcd(a, b), then sums those divisors.\n\ndef sum_common_divisors(a, b):\n    import math\n    g = math.gcd(a, b)\n    if g == 0:\n        return 0  # both numbers are 0\n    g = abs(g)\n    total = 0\n    i = 1\n    while i * i <= g:\n        if g % i == 0:\n            total += i\n            if i != g // i:\n                total += g // i\n        i += 1\n    return total\n\nNotes:\n- Handles negative inputs via abs(gcd).\n- If both inputs are 0, returns 0 (no well-defined sum of divisors)."}
{"task_id": "Mbpp/128", "completion": "Here\u2019s a simple Python function that returns the words longer than n characters from a given list.\n\ndef words_longer_than(words, n):\n    \"\"\"\n    Return a list of words from 'words' whose length is greater than n.\n\n    - words: iterable of strings\n    - n: non-negative integer\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return [w for w in words if isinstance(w, str) and len(w) > n]\n\n# Example usage\nwords = [\"apple\", \"banana\", \"cat\", \"dog\", \"elephant\"]\nprint(words_longer_than(words, 4))\n# Output: ['apple', 'banana', 'elephant']\n\nNotes:\n- The function uses a strict inequality (len(word) > n), so words with exactly n characters are excluded.\n- Time complexity is O(m), where m is the number of words in the input list."}
{"task_id": "Mbpp/124", "completion": "Here\u2019s how to compute the angle (argument) of a complex number. The angle \u03b8 = atan2(imag, real). It\u2019s typically returned in radians; you can convert to degrees if needed.\n\nPython (supports complex inputs or a (real, imag) pair):\ndef complex_angle(z, deg=False):\n    import math\n    if isinstance(z, complex):\n        x, y = z.real, z.imag\n    elif isinstance(z, (tuple, list)) and len(z) == 2:\n        x, y = z\n    else:\n        raise TypeError(\"z must be a complex number or a (real, imag) pair\")\n    theta = math.atan2(y, x)\n    return math.degrees(theta) if deg else theta\n\n# Examples:\n# complex_angle(3+4j)          -> 0.927295218 rad\n# complex_angle((3, 4), deg=True) -> 53.1301024 deg\n\nJavaScript (using real and imag components):\nfunction complexAngle(re, im, deg) {\n  const a = Math.atan2(im, re);\n  return deg ? (a * 180 / Math.PI) : a;\n}\n\n// If you have an object { re, im }:\n// complexAngle(obj.re, obj.im, true);\n\nC++ (using std::complex):\n#include <complex>\n#include <cmath>\n\ndouble complexAngle(const std::complex<double>& z) {\n    // Returns angle in radians\n    return std::arg(z);\n}\n\n// Example:\n// std::complex<double> z(3.0, 4.0);\n// double ang = complexAngle(z);\n\nNotes:\n- The angle is undefined for 0 + 0i; most implementations return 0 by convention (atan2(0,0) = 0 in these cases).\n- If you need degrees, convert radians (angle_radians) by multiplying by 180/\u03c0."}
{"task_id": "Mbpp/111", "completion": "Here\u2019s a Python function that finds the common leaf elements across several nested lists. It flattens each sublist (recursively) and then computes the intersection of the resulting sets.\n\nCode:\n\n```python\ndef flatten(item):\n    # Recursively flatten lists/tuples, but treat strings as atomic\n    if isinstance(item, (list, tuple)):\n        for sub in item:\n            yield from flatten(sub)\n    else:\n        yield item\n\ndef common_elements_in_nested_lists(nested_lists):\n    \"\"\"\n    nested_lists: a list of (possibly nested) iterables.\n    Returns a sorted list of elements that appear in every sublist (as leaves after flattening).\n    Note: leaves must be hashable (since we use sets).\n    \"\"\"\n    if not nested_lists:\n        return []\n\n    # Build a set of leaves for each sublist\n    sets = []\n    for sub in nested_lists:\n        leafs = set(flatten(sub))\n        sets.append(leafs)\n\n    # Intersection across all sets\n    common = sets[0].copy()\n    for s in sets[1:]:\n        common &= s\n\n    return sorted(common)\n\n# Example\nif __name__ == \"__main__\":\n    nested = [\n        [1, 2, [3, 4], 5],\n        [0, 2, 3, 6, [3]],\n        [2, 3, 7, [2, 3]],\n    ]\n    print(common_elements_in_nested_lists(nested))  # Output: [2, 3]\n```\n\nNotes and variations:\n- This returns unique common elements (duplicates are ignored by using sets).\n- If you want to preserve the order based on the first sublist, you can iterate through the first sublist\u2019s flattened elements and pick those that are in the common set.\n- If the leaves aren\u2019t hashable, you\u2019ll need a different approach (e.g., representing leaves as tuples or counting with a different data structure)."}
{"task_id": "Mbpp/123", "completion": "Here's a Python function that sums all amicable numbers in the range [1, n].\n\n- It first computes the sum of proper divisors for every number up to n.\n- Then, for each a in [2, n], it checks if b = sum_proper_divisors[a] forms an amicable pair with a (i.e., b <= n and sum_proper_divisors[b] == a and a != b).\n- If so, it adds a to the total. This naturally includes both members of any amicable pair that lies entirely within [1, n].\n\nCode:\n\ndef sum_amicable_up_to(n):\n    \"\"\"\n    Return the sum of all amicable numbers in the range [1, n].\n    An amicable pair is (a, b) with a != b, sum_proper_divisors(a) = b, and sum_proper_divisors(b) = a.\n    \"\"\"\n    if n < 2:\n        return 0\n\n    # sum of proper divisors for each number up to n\n    s = [0] * (n + 1)\n    for i in range(1, n // 2 + 1):\n        for j in range(i * 2, n + 1, i):\n            s[j] += i\n\n    total = 0\n    for a in range(2, n + 1):\n        b = s[a]\n        if b != a and b <= n and s[b] == a:\n            total += a\n\n    return total\n\n# Example usage:\n# print(sum_amicable_up_to(10000))  # outputs 31626 (sum of all amicable numbers under 10000)\n\nNotes:\n- Time complexity is roughly O(n log n) due to the divisor-sum sieve.\n- The function adds both members of any amicable pair that lies entirely within [1, n], e.g., for (220, 284) both 220 and 284 are included if n >= 284."}
{"task_id": "Mbpp/133", "completion": "Here\u2019s a simple Python function that sums only the negative numbers in a list (or any iterable of numbers):\n\n```python\ndef sum_negative(numbers):\n    \"\"\"Return the sum of all negative numbers in 'numbers'.\"\"\"\n    return sum(x for x in numbers if x < 0)\n```\n\nExamples:\n- sum_negative([3, -1, -4, 0, 2]) returns -5\n- sum_negative([-2, -5, 7, -1]) returns -8\n\nNotes:\n- Time complexity: O(n), where n is the number of elements.\n- If you want to enforce numeric inputs strictly, you can add type checks inside a loop instead of using the generator."}
{"task_id": "Mbpp/130", "completion": "Here is a Python example. It finds the item with the maximum frequency and returns the item along with its count. If there are ties, it returns the first item (in the original list order) among those with the maximum frequency.\n\nCode (Python):\n\n```python\nfrom collections import Counter\n\ndef most_frequent_item(lst):\n    if not lst:\n        raise ValueError(\"The input list is empty\")\n\n    counts = Counter(lst)\n    max_count = max(counts.values())\n\n    # Return the first item (in original order) that has the max frequency\n    for item in lst:\n        if counts[item] == max_count:\n            return item, max_count\n```\n\nUsage:\n```python\nlst = [1, 2, 2, 3, 3, 3, 2]\nprint(most_frequent_item(lst))  # (2, 3)\n```\n\nNotes and variations:\n- If you want to handle ties by returning all items that have the maximum frequency, you can add a second function:\n\n```python\ndef all_most_frequent_items(lst):\n    if not lst:\n        raise ValueError(\"The input list is empty\")\n\n    counts = Counter(lst)\n    max_count = max(counts.values())\n    max_items = [item for item, cnt in counts.items() if cnt == max_count]\n    return max_items, max_count\n```\n\n- Assumes the list contains hashable items (so it can be used as keys in a Counter/dictionary). If the list might contain unhashable elements, you\u2019d need a slower approach (O(n^2)) that compares items by equality rather than using a dict."}
{"task_id": "Mbpp/120", "completion": "Here's a Python function assuming you want the maximum absolute product formed by taking one number from one tuple and one number from a different tuple (i.e., across pairs of tuples). For each tuple, you only need the larger absolute value, and the overall maximum is the product of the two largest such values from distinct tuples.\n\n```python\nimport heapq\n\ndef max_abs_product_between_tuples(list_of_tuples):\n    \"\"\"\n    list_of_tuples: list of 2-element tuples (e.g., [(a,b), (c,d), ...])\n    Returns the maximum |x*y| where x comes from one tuple and y from a different tuple.\n    \"\"\"\n    if len(list_of_tuples) < 2:\n        raise ValueError(\"Need at least two tuples to form a pair.\")\n\n    # For each tuple, the best you can do (in absolute value) is max(|a|, |b|)\n    abs_max_per_tuple = (max(abs(a), abs(b)) for (a, b) in list_of_tuples)\n\n    # Take the two largest values among different tuples\n    top_two = heapq.nlargest(2, abs_max_per_tuple)\n    if len(top_two) < 2:\n        raise ValueError(\"Need at least two non-empty tuples.\")\n\n    return top_two[0] * top_two[1]\n\n# Example usage\ndata = [(2, -3), (-5, 4), (0, -7)]\nprint(max_abs_product_between_tuples(data))  # Output: 35\n```\n\nNotes:\n- The maximum for a given pair of tuples (t1, t2) is max(|t1[0]|, |t1[1]|) * max(|t2[0]|, |t2[1]|). The overall maximum across all tuple pairs is obtained by multiplying the two largest per-tuple max-abs values from two different tuples.\n- If you have only one tuple or all tuples are effectively empty, the function raises an error. If you\u2019d prefer a returning None in such cases, you can adjust accordingly."}
{"task_id": "Mbpp/132", "completion": "Here are a few Python options depending on what you want the result to look like.\n\nOption 1: Simple string representation (like Python prints a tuple)\n- Uses the built-in str()\n\ndef tuple_to_string(t):\n    \"\"\"Convert a tuple to its string representation.\"\"\"\n    return str(t)\n\n# Example\nt = (1, \"a\", 3.14)\nprint(tuple_to_string(t))  # \"(1, 'a', 3.14)\"\n\nOption 2: Join elements with a delimiter (no surrounding parentheses)\n- Useful if you want a flat string like \"1, a, 3.14\"\n\ndef tuple_to_string_join(t, delimiter=\", \"):\n    \"\"\"Join tuple elements into a string with a delimiter.\"\"\"\n    return delimiter.join(str(x) for x in t)\n\n# Example\nprint(tuple_to_string_join(t, delimiter=\" - \"))  # \"1 - a - 3.14\"\n\nOption 3: JSON-friendly representation (nested structures preserved)\n- Converts the tuple to a JSON array string\n\nimport json\n\ndef tuple_to_json_string(t):\n    \"\"\"Convert a tuple to a JSON string representing a list.\"\"\"\n    return json.dumps(list(t))\n\n# Example\nprint(tuple_to_json_string(t))  # \"[1, \"a\", 3.14]\"\n\nNotes:\n- str(t) is the simplest and preserves Python tuple syntax.\n- The join variant requires converting each element to string (via str(x)).\n- If you need a stable, machine-readable format, JSON via list(t) is a good choice, especially for nested tuples."}
{"task_id": "Mbpp/127", "completion": "Sure\u2014here are simple implementations in a few common languages. If you want a version that avoids using the multiplication operator, I included a bitwise/doubling approach as well. Tell me your preferred language if you don\u2019t see it here.\n\nPython (simple)\ndef multiply(a: int, b: int) -> int:\n    return a * b\n\nPython (without using *) using Russian peasant multiplication\ndef multiply(a: int, b: int) -> int:\n    result = 0\n    negative = (a < 0) ^ (b < 0)\n    a, b = abs(a), abs(b)\n    while b:\n        if b & 1:\n            result += a\n        a <<= 1\n        b >>= 1\n    return -result if negative else result\n\nJavaScript (simple)\nfunction multiply(a, b) {\n  return a * b;\n}\n\nJavaScript (without using *) using bitwise method\nfunction multiply(a, b) {\n  let result = 0;\n  const negative = (a < 0) ^ (b < 0);\n  a = Math.abs(a);\n  b = Math.abs(b);\n  while (b > 0) {\n    if (b & 1) result += a;\n    a <<= 1;\n    b >>= 1;\n  }\n  return negative ? -result : result;\n}\n\nC (simple)\nint multiply(int a, int b) {\n    return a * b;\n}\n\nC (without using *) using shift/add\nlong long multiply_no_op(int a, int b) {\n    long long result = 0;\n    int negative = ((a < 0) ^ (b < 0)) ? -1 : 1;\n    unsigned int ua = (a < 0) ? -a : a;\n    unsigned int ub = (b < 0) ? -b : b;\n    while (ub) {\n        if (ub & 1) result += ua;\n        ua <<= 1;\n        ub >>= 1;\n    }\n    return negative * result;\n}\n\nIf you tell me your target language (and whether you want a no-* version or care about overflow/big integers), I can tailor a single snippet for you."}
{"task_id": "Mbpp/131", "completion": "Here's a Python function that reverses only the vowels in a string, treating y as a consonant.\n\n```python\ndef reverse_vowels(s: str) -> str:\n    def is_vowel(ch: str) -> bool:\n        return ch in \"aeiouAEIOU\"\n\n    s_list = list(s)\n    i, j = 0, len(s_list) - 1\n\n    while i < j:\n        while i < j and not is_vowel(s_list[i]):\n            i += 1\n        while i < j and not is_vowel(s_list[j]):\n            j -= 1\n        if i < j:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n\n    return ''.join(s_list)\n\n# Examples:\nprint(reverse_vowels(\"Hello, World!\"))  # Holl o, Werld! -> \"Hollo, Werld!\"\nprint(reverse_vowels(\"a-bcd-ef\"))       # \"e-bcd-af\"\n```\n\nNotes:\n- Vowels include both lowercase and uppercase: a, e, i, o, u (and A, E, I, O, U).\n- \u2018y\u2019 is not treated as a vowel in this implementation.\n- Time complexity: O(n), Space complexity: O(n) for the character list (in-place with a list)."}
{"task_id": "Mbpp/129", "completion": "Do you want Python? Here\u2019s a Python function you can use. It checks the standard definition of a magic square (all row sums, column sums, and both diagonals equal). It also supports an optional strict mode that enforces the numbers 1..n^2 exactly once.\n\nPython code:\n\n```python\ndef is_magic_square(matrix, require_unique_numbers=True):\n    \"\"\"\n    Check if a matrix is a magic square.\n\n    - matrix: a square matrix as a list of lists (n x n)\n    - require_unique_numbers: if True, also require that the entries are exactly\n      the integers 1..n^2 (each once)\n\n    Returns True or False.\n    \"\"\"\n    if not matrix or not isinstance(matrix, list):\n        return False\n\n    n = len(matrix)\n    # Ensure it's square\n    for row in matrix:\n        if not isinstance(row, (list, tuple)) or len(row) != n:\n            return False\n\n    # Target sum is the sum of the first row\n    try:\n        target = sum(matrix[0])\n    except Exception:\n        return False\n\n    # Check all rows\n    for i in range(1, n):\n        if sum(matrix[i]) != target:\n            return False\n\n    # Check all columns\n    for j in range(n):\n        if sum(matrix[i][j] for i in range(n)) != target:\n            return False\n\n    # Check diagonals\n    if sum(matrix[i][i] for i in range(n)) != target:\n        return False\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != target:\n        return False\n\n    if require_unique_numbers:\n        # All entries must be integers and exactly 1..n^2\n        all_ints = all(isinstance(matrix[i][j], int) for i in range(n) for j in range(n))\n        if not all_ints:\n            return False\n        nums = [matrix[i][j] for i in range(n) for j in range(n)]\n        if sorted(nums) != list(range(1, n * n + 1)):\n            return False\n\n    return True\n```\n\nUsage examples:\n\n```python\n# Lo Shu magic square\nms = [\n    [8, 1, 6],\n    [3, 5, 7],\n    [4, 9, 2]\n]\nprint(is_magic_square(ms))  # True\n\n# Another 3x3 magic square (rotation/reflection)\nms2 = [\n    [2, 7, 6],\n    [9, 5, 1],\n    [4, 3, 8]\n]\nprint(is_magic_square(ms2))  # True\n\n# Not a magic square\nnot_magic = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\nprint(is_magic_square(not_magic))  # False\n\n# Non-square matrix\nnon_square = [\n    [1, 2, 3],\n    [4, 5, 6]\n]\nprint(is_magic_square(non_square))  # False\n```\n\nIf you prefer another language (JavaScript, C++, etc.), tell me which one and I\u2019ll adapt it."}
{"task_id": "Mbpp/103", "completion": "Eulerian numbers A(n, m) count permutations of {1..n} with exactly m descents (a descent i is where p(i) > p(i+1)). They satisfy:\n- 0 \u2264 m \u2264 n-1\n- A(1,0) = 1, and A(n,m) = 0 if m < 0 or m \u2265 n\n- Recurrence: A(n,m) = (n - m) * A(n-1, m-1) + (m + 1) * A(n-1, m)\n\nHere are a few Python options.\n\n1) O(n) space, bottom-up (iterative)\n```python\ndef eulerian(n, m):\n    \"\"\"\n    Return Eulerian number A(n, m): number of permutations of {1..n} with exactly m descents.\n    0 <= m <= n-1\n    \"\"\"\n    if m < 0 or m >= n:\n        return 0\n    # base for n = 1\n    prev = [0] * n\n    prev[0] = 1  # A(1,0) = 1\n    for i in range(2, n + 1):\n        cur = [0] * n\n        for j in range(0, i):  # j corresponds to m\n            val = 0\n            if j - 1 >= 0:\n                val += (i - j) * prev[j - 1]\n            if j <= i - 2:\n                val += (j + 1) * prev[j]\n            cur[j] = val\n        prev = cur\n    return prev[m]\n```\n\nUsage:\n- eulerian(4, 2) -> 11\n\n2) Recursive with memoization (easy to read)\n```python\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef A(n, m):\n    if m < 0 or m >= n:\n        return 0\n    if n == 1:\n        return 1 if m == 0 else 0\n    return (n - m) * A(n - 1, m - 1) + (m + 1) * A(n - 1, m)\n```\n\n3) Closed form (direct formula)\n```python\nfrom math import comb\n\ndef eulerian_closed(n, m):\n    if m < 0 or m >= n:\n        return 0\n    s = 0\n    for k in range(0, m + 1):\n        s += (-1) ** k * comb(n + 1, k) * (m + 1 - k) ** n\n    return s\n```\n\nNotes:\n- The typical range is m = 0, 1, ..., n-1.\n- The DP version runs in O(n^2) time and O(n) extra space; the memoized version is also practical for many n. The closed-form is O(n) time but uses big integer arithmetic."}
{"task_id": "Mbpp/109", "completion": "Here\u2019s a simple Python function that counts how many of the first k left-rotations of a binary string have an odd value. An odd binary number ends with '1', so we just check the last bit after each rotation.\n\n- Assumes left rotation by 1 for each step (i = 1..k).\n- Uses the fact that the last bit after i left-rotations is s[(i-1) % n].\n- Runs in O(n) time overall (n = len(s)).\n\nCode:\n\n```python\ndef count_odd_rotations(s: str, k: int) -> int:\n    \"\"\"\n    Count how many of the first k left-rotations of binary string s yield an odd value.\n\n    s: binary string (consists of '0' and '1')\n    k: number of rotations to perform (positive integer)\n\n    Returns: integer count of rotations resulting in an odd number.\n    \"\"\"\n    if k <= 0 or not s:\n        return 0\n    if any(ch not in '01' for ch in s):\n        raise ValueError(\"s must be a binary string consisting of '0' and '1' only\")\n\n    n = len(s)\n    ones = s.count('1')  # number of '1's in the string\n\n    full = k // n        # how many full cycles of length n\n    rem = k % n          # remaining rotations beyond full cycles\n\n    # For left rotations, the last bit after i-th rotation is s[(i-1) % n].\n    # So among the first k rotations, we get '1' (odd) for each 1 in:\n    # - full cycles: full * (number of '1's in s)\n    # - the first rem characters of s: count of '1's in s[:rem]\n    extra = sum(1 for ch in s[:rem] if ch == '1')\n\n    return full * ones + extra\n\n\n# Example\ns = \"1011\"\nk = 5\nprint(count_odd_rotations(s, k))  # Output: 4\n```\n\nIf you want to consider rotations in the opposite direction (right rotations) instead, you can modify the extra term to count ones in the last rem characters of s (i.e., s[-rem:]) or add a direction parameter."}
{"task_id": "Mbpp/139", "completion": "Here are simple functions to compute the circumference using C = 2\u03c0r (radius) or C = \u03c0d (diameter). I\u2019ve included examples in several common languages.\n\nPython\n- Using radius\nimport math\ndef circumference_radius(r):\n    if r < 0:\n        raise ValueError(\"Radius must be non-negative\")\n    return 2 * math.pi * r\n\n- Using diameter\ndef circumference_diameter(d):\n    if d < 0:\n        raise ValueError(\"Diameter must be non-negative\")\n    return math.pi * d\n\nJavaScript\n- Using radius\nfunction circumferenceFromRadius(r) {\n  if (r < 0) throw new RangeError(\"Radius must be non-negative\");\n  return 2 * Math.PI * r;\n}\n\n- Using diameter\nfunction circumferenceFromDiameter(d) {\n  if (d < 0) throw new RangeError(\"Diameter must be non-negative\");\n  return Math.PI * d;\n}\n\nJava\npublic class Circle {\n    public static double circumferenceFromRadius(double r) {\n        if (r < 0) throw new IllegalArgumentException(\"Radius must be non-negative\");\n        return 2 * Math.PI * r;\n    }\n    public static double circumferenceFromDiameter(double d) {\n        if (d < 0) throw new IllegalArgumentException(\"Diameter must be non-negative\");\n        return Math.PI * d;\n    }\n}\n\nC++\n#include <cmath>\n#include <stdexcept>\n\ndouble circumferenceFromRadius(double r) {\n    if (r < 0) throw std::invalid_argument(\"Radius must be non-negative\");\n    return 2.0 * M_PI * r;\n}\n\ndouble circumferenceFromDiameter(double d) {\n    if (d < 0) throw std::invalid_argument(\"Diameter must be non-negative\");\n    return M_PI * d;\n}\n\nNote:\n- C = 2\u03c0r if you have the radius.\n- C = \u03c0d if you have the diameter.\n- \u03c0 is available as Math.PI in JavaScript/Java, M_PI in C/C++, or you can define your own constant (e.g., 3.141592653589793). If you tell me your preferred language, I can tailor a single-function version for that."}
{"task_id": "Mbpp/135", "completion": "The nth hexagonal number (not centered) is given by:\nH(n) = n * (2n - 1) = 2n^2 - n\nwhere n is a positive integer.\n\nHere are simple implementations in a few languages.\n\n- Python\ndef hexagonal(n):\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return n * (2 * n - 1)\n\n# Example\n# hexagonal(1) -> 1\n# hexagonal(5) -> 45\n\n- JavaScript\nfunction hexagonal(n) {\n    if (n <= 0) throw new Error(\"n must be a positive integer\");\n    return n * (2 * n - 1);\n}\n\n// hexagonal(1) -> 1\n// hexagonal(5) -> 45\n\n- Java\npublic class Hexagonal {\n    public static long hexagonal(long n) {\n        if (n <= 0) throw new IllegalArgumentException(\"n must be a positive integer\");\n        return n * (2 * n - 1);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(hexagonal(1)); // 1\n        System.out.println(hexagonal(5)); // 45\n    }\n}\n\n- C++\n#include <stdexcept>\n#include <limits>\n\nunsigned long long hexagonal(unsigned long long n) {\n    if (n == 0) throw std::invalid_argument(\"n must be positive\");\n    // Be mindful of overflow for very large n. This uses 128-bit intermediate if available.\n#if defined(__SIZEOF_INT128__)\n    __int128 t = (__int128)n * (2 * n - 1);\n    return (unsigned long long)t;\n#else\n    // May overflow for large n\n    return n * (2 * n - 1);\n#endif\n}\n\n// Example usage: hexagonal(1) -> 1, hexagonal(5) -> 45\n\nNotes\n- The formula is direct and runs in O(1) time.\n- Validate n as a positive integer to avoid undefined results.\n- If you expect very large n and want to avoid overflow, use a language or type that supports big integers (e.g., Python int is unbounded, Java BigInteger, etc.)."}
{"task_id": "Mbpp/137", "completion": "Here\u2019s a simple Python function that computes the ratio of zeros to non-zeros in an array of integers. It handles edge cases where there are no non-zeros or the array is empty.\n\nPython (float ratio, with edge-case handling)\n- If there are no non-zeros but at least one zero, returns float('inf').\n- If the array is empty (or both counts are zero), returns None.\n\ndef ratio_zeros_to_nonzeros(arr):\n    zeros = 0\n    non_zeros = 0\n    for x in arr:\n        if x == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n\n    if non_zeros == 0:\n        if zeros == 0:\n            return None  # empty array\n        return float('inf')  # ratio is infinite (zeros > 0, no non-zeros)\n\n    return zeros / non_zeros\n\nUsage example:\n- ratio_zeros_to_nonzeros([0, 1, 0, 2, 3]) -> 2.0\n- ratio_zeros_to_nonzeros([0, 0, 0]) -> inf\n- ratio_zeros_to_nonzeros([1, 2, 3]) -> 0.0\n- ratio_zeros_to_nonzeros([]) -> None\n\nOptional: return a reduced fraction (pair) instead of a float\nThis returns a tuple (zeros_gcd_reduced, non_zeros_gcd_reduced), e.g., (2, 3) for 2 zeros and 3 non-zeros.\n\nimport math\n\ndef reduced_ratio_zeros_to_nonzeros(arr):\n    zeros = 0\n    non_zeros = 0\n    for x in arr:\n        if x == 0:\n            zeros += 1\n        else:\n            non_zeros += 1\n\n    if non_zeros == 0:\n        if zeros == 0:\n            return None\n        return (1, 0)  # infinite ratio represented as 1:0\n\n    g = math.gcd(zeros, non_zeros)\n    return (zeros // g, non_zeros // g)\n\nIf you want this in another language (e.g., JavaScript or Java), tell me which language and I\u2019ll provide equivalents."}
{"task_id": "Mbpp/140", "completion": "Here\u2019s a simple Python function that flattens a list of lists into a set of unique numbers:\n\ndef flatten_to_set(list_of_lists):\n    \"\"\"Flatten a list of lists of numbers into a set of unique numbers.\"\"\"\n    return {num for inner in list_of_lists for num in inner}\n\n# Example\nlst = [[1, 2, 2], [3, 4.0], [4, 5, 1]]\nprint(flatten_to_set(lst))  # {1, 2, 3.0, 4, 5}\n\nNotes:\n- The result is a set of unique numbers. If you mix ints and floats that are equal (e.g., 1 and 1.0), they will be treated as the same element.\n- If you want to enforce numeric types or handle non-numeric items, you can add type checks or conversions inside the loop."}
{"task_id": "Mbpp/142", "completion": "Here\u2019s a Python function that counts the number of positions where all three lists have the same value at that index.\n\n```python\ndef count_identical_in_same_position(a, b, c):\n    \"\"\"\n    Count indices i where a[i] == b[i] == c[i].\n    Uses the shortest length among the three lists.\n    \"\"\"\n    return sum(1 for x, y, z in zip(a, b, c) if x == y == z)\n\n# Example\na = [1, 2, 3, 4]\nb = [5, 2, 3, 6]\nc = [7, 2, 8, 4]\n\nprint(count_identical_in_same_position(a, b, c))  # Output: 1\n```\n\nNotes:\n- The function stops at the shortest list length (zip truncates to the shortest).\n- It returns the count of indices where all three lists have the same value at that position.\n\nIf you want a version that handles any number of lists, you can generalize using itertools.zip_longest with appropriate handling."}
{"task_id": "Mbpp/100", "completion": "Here are Python implementations for both interpretations. The first function returns the next palindrome strictly greater than the given integer. The second returns the previous palindrome strictly smaller (the \u201cnext smallest\u201d palindrome).\n\nPython code:\n\n```python\ndef next_palindrome(n: int) -> int:\n    \"\"\"\n    Return the smallest palindrome strictly greater than n.\n    Works for non-negative integers.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    s = str(n)\n    k = len(s)\n    p = list(s)\n\n    # Mirror left to right\n    for i in range(k // 2):\n        p[-1 - i] = p[i]\n    pal = int(''.join(p))\n\n    if pal > n:\n        return pal\n\n    # Need to increment the middle and propagate carry\n    i = (k - 1) // 2\n    while i >= 0 and p[i] == '9':\n        p[i] = '0'\n        i -= 1\n\n    if i < 0:\n        # All 9's case: 99 -> 101, 999 -> 1001, etc.\n        return int('1' + ('0' * (k - 1)) + '1')\n\n    p[i] = chr(ord(p[i]) + 1)\n\n    # Mirror again after increment\n    for j in range(k // 2):\n        p[-1 - j] = p[j]\n\n    return int(''.join(p))\n\n\ndef prev_palindrome(n: int) -> int:\n    \"\"\"\n    Return the largest palindrome strictly smaller than n.\n    Works for non-negative integers.\n    \"\"\"\n    if n <= 0:\n        return 0\n    if n < 10:\n        return n - 1\n\n    s = str(n)\n    k = len(s)\n    p = list(s)\n\n    # Mirror left to right\n    for i in range(k // 2):\n        p[-1 - i] = p[i]\n    pal = int(''.join(p))\n\n    if pal < n:\n        return pal\n\n    # Decrement the left half (including middle for odd length)\n    i = (k - 1) // 2\n    while i >= 0 and p[i] == '0':\n        p[i] = '9'\n        i -= 1\n\n    if i < 0:\n        # e.g., 1000 -> 999 (k-1 digits of 9)\n        return int('9' * (k - 1))\n\n    p[i] = chr(ord(p[i]) - 1)\n\n    # Mirror again after decrement\n    for j in range(k // 2):\n        p[-1 - j] = p[j]\n\n    if p[0] == '0':\n        return int('9' * (k - 1))\n\n    return int(''.join(p))\n```\n\nUsage examples:\n- next_palindrome(12345) -> 12421\n- next_palindrome(9) -> 11\n- prev_palindrome(1200) -> 1111\n- prev_palindrome(1000) -> 999\n\nIf you meant a different interpretation (e.g., the next palindrome that is not equal to n when n itself is a palindrome), these functions already handle that by requiring strictly greater/strictly smaller results. If you want a single function with a direction parameter, I can adapt it."}
{"task_id": "Mbpp/138", "completion": "Here's a simple function. A positive integer can be represented as a sum of non-zero powers of 2 (i.e., 2^1, 2^2, \u2026) if and only if it is even. So the check is whether n > 0 and n is even.\n\ndef can_be_sum_of_nonzero_powers_of_two(n: int) -> bool:\n    \"\"\"\n    Check if n can be written as a sum of non-zero powers of 2\n    (i.e., 2^k with k >= 1). Returns True for positive even numbers.\n    \"\"\"\n    return n > 0 and (n & 1) == 0\n\n# Examples\nprint(can_be_sum_of_nonzero_powers_of_two(10))  # True  -> 8 + 2\nprint(can_be_sum_of_nonzero_powers_of_two(9))   # False -> needs 1 (2^0)\nprint(can_be_sum_of_nonzero_powers_of_two(2))   # True  -> 2\nprint(can_be_sum_of_nonzero_powers_of_two(0))   # False -> cannot use empty sum\n\nIf you meant a different interpretation (e.g., allowing repeated powers or requiring distinct powers), let me know and I can adjust the solution."}
{"task_id": "Mbpp/165", "completion": "Here\u2019s a Python function that counts how many characters in a string occur at the same position as their alphabetical index (case-insensitive). We treat positions as 1-based and ignore non-letter characters.\n\n```python\ndef count_alphabet_position_matches(s: str) -> int:\n    \"\"\"\n    Count letters in s whose 1-based position in the string equals\n    their position in the English alphabet (a=1, b=2, ..., z=26).\n    Non-letter characters are ignored for the letter-position check.\n    \"\"\"\n    count = 0\n    for i, ch in enumerate(s, start=1):  # i is 1-based position in the string\n        if ch.isalpha():\n            pos = ord(ch.lower()) - ord('a') + 1\n            if 1 <= pos <= 26 and i == pos:\n                count += 1\n    return count\n```\n\nExamples:\n- count_alphabet_position_matches(\"abc123\") -> 3 (a at 1, b at 2, c at 3)\n- count_alphabet_position_matches(\"a1b2c3\") -> 1 (only 'a' at position 1)\n- count_alphabet_position_matches(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") -> 26 (each letter at its matching 1-based position)\n\nIf you\u2019d like, I can provide equivalent versions in JavaScript, Java, or C++."}
{"task_id": "Mbpp/168", "completion": "Here are simple implementations in Python (a couple of options) for counting how many times a given number appears in a list.\n\nOption 1: Explicit loop\ndef count_occurrences(lst, target):\n    \"\"\"Return the number of times target appears in lst.\"\"\"\n    count = 0\n    for x in lst:\n        if x == target:\n            count += 1\n    return count\n\nOption 2: Using built-in count\ndef count_occurrences(lst, target):\n    \"\"\"Return the number of times target appears in lst.\"\"\"\n    return lst.count(target)\n\nUsage:\nprint(count_occurrences([1, 2, 3, 1, 4, 1], 1))  # 3\n\nIf you prefer a one-liner:\ndef count_occurrences(lst, target):\n    return sum(1 for x in lst if x == target)\n\nOther language snippets (quick reference)\n\nJavaScript:\nfunction countOccurrences(arr, target) {\n  return arr.filter(x => x === target).length;\n}\n\nOr:\nfunction countOccurrences(arr, target) {\n  return arr.reduce((acc, x) => (x === target ? acc + 1 : acc), 0);\n}\n\nNotes:\n- Works with any numeric target (integers, floats) and lists containing numbers.\n- Returns 0 if the target isn\u2019t found or the list is empty."}
{"task_id": "Mbpp/166", "completion": "Here's a concise Python solution. The key idea: a^b is even iff a and b have the same parity (both even or both odd). Count evens and odds, and sum the number of pairs from each group.\n\ndef count_pairs_xor_even(nums):\n    evens = sum(1 for x in nums if x % 2 == 0)\n    odds = len(nums) - evens\n    return evens * (evens - 1) // 2 + odds * (odds - 1) // 2\n\n# Example\nnums = [1, 2, 3, 4, 5]\nprint(count_pairs_xor_even(nums))  # Output: 4\n\nExplanation:\n- Evens: [2, 4] -> C(2, 2) = 1 pair\n- Odds: [1, 3, 5] -> C(3, 2) = 3 pairs\n- Total = 1 + 3 = 4\n\nComplexity: O(n) time, O(1) extra space."}
{"task_id": "Mbpp/161", "completion": "Here\u2019s a concise Python solution using a set for fast membership tests. It includes both a non-destructive (returns a new list) and an in-place version.\n\n- Non-destructive (returns a new list):\ndef remove_all(lst, other):\n    \"\"\"\n    Return a new list containing elements from lst that are not in 'other'.\n    \"\"\"\n    removal = set(other or [])\n    return [x for x in lst if x not in removal]\n\n- In-place (modifies the original list):\ndef remove_all_inplace(lst, other):\n    \"\"\"\n    Remove from 'lst' in place all elements that appear in 'other'.\n    Returns the modified list for chaining.\n    \"\"\"\n    removal = set(other or [])\n    lst[:] = [x for x in lst if x not in removal]\n    return lst\n\nNotes:\n- Uses a set for O(1) lookups, giving O(n + m) time and O(n) extra space (n = len(lst), m = len(other)).\n- If elements in lst are unhashable (e.g., lists), the set-based approach won\u2019t work. In that case, fall back to a linear search:\n  removal = list(other or [])\n  return [x for x in lst if x not in removal]\nLet me know if you want versions in another language (JavaScript, Java, C++, etc.)."}
{"task_id": "Mbpp/171", "completion": "A regular pentagon has 5 equal sides, so its perimeter is simply 5 times the side length.\n\nHere\u2019s a Python function:\n\ndef pentagon_perimeter(side_length):\n    \"\"\"\n    Return the perimeter of a regular pentagon given its side length.\n    side_length: non-negative number\n    \"\"\"\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative\")\n    return 5 * side_length\n\n# Example\nprint(pentagon_perimeter(3))  # Output: 15\n\nIf you prefer another language, tell me which one you\u2019re using and I\u2019ll provide a version in that language."}
{"task_id": "Mbpp/145", "completion": "Here are two versions. Pick the one that matches your interpretation.\n\n1) Maximum difference between any two elements (unordered): max(value) - min(value)\n- This is simple and runs in O(n) time.\n\n```python\ndef max_difference_unordered(arr):\n    \"\"\"\n    Return the maximum difference between any two elements in the array.\n    This is max(arr) - min(arr).\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    min_val = arr[0]\n    max_val = arr[0]\n    for x in arr[1:]:\n        if x < min_val:\n            min_val = x\n        if x > max_val:\n            max_val = x\n    return max_val - min_val\n```\n\n2) Maximum difference where the second element comes after the first (i < j): max(arr[j] - arr[i])\n- This is like the maximum profit problem; also O(n).\n\n```python\ndef max_difference_ordered(arr):\n    \"\"\"\n    Return the maximum difference arr[j] - arr[i] with i < j.\n    \"\"\"\n    if len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    min_so_far = arr[0]\n    max_diff = arr[1] - arr[0]\n    for x in arr[1:]:\n        max_diff = max(max_diff, x - min_so_far)\n        min_so_far = min(min_so_far, x)\n    return max_diff\n```\n\nExample:\n- arr = [3, 10, 2, 8, 6]\n- max_difference_unordered(arr) -> 8 (10 - 2)\n- max_difference_ordered(arr) -> 8 (10 - 2)"}
{"task_id": "Mbpp/167", "completion": "Here's a concise Python function that returns the smallest power of 2 that is greater than or equal to n.\n\n```python\ndef smallest_power_of_two_ge(n: int) -> int:\n    \"\"\"\n    Return the smallest power of 2 greater than or equal to n.\n    For n <= 1, returns 1.\n    \"\"\"\n    if n <= 1:\n        return 1\n    # Use bit_length: 1 << ((n-1).bit_length()) gives the next power of two\n    return 1 << ((n - 1).bit_length())\n\n# Example usage\nif __name__ == \"__main__\":\n    for x in [0, 1, 2, 3, 4, 5, 15, 16, 17, 100]:\n        print(x, smallest_power_of_two_ge(x))\n```\n\nNotes:\n- If n <= 1, it returns 1 (since 2^0 = 1 is the smallest power of two).\n- For n > 1, it efficiently computes the next power of two using bit_length."}
{"task_id": "Mbpp/222", "completion": "Here's a concise Python function to check if all elements in a tuple have the same exact data type. It treats an empty tuple (and a single-element tuple) as having the same type by default.\n\n```python\ndef all_elements_same_type(tpl):\n    \"\"\"\n    Return True if all elements in the tuple have the same exact type.\n    Empty tuple or single-element tuple is considered True.\n    \"\"\"\n    if not isinstance(tpl, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if len(tpl) <= 1:\n        return True\n    first_type = type(tpl[0])\n    return all(type(x) is first_type for x in tpl[1:])\n```\n\nUsage examples:\n- all_elements_same_type((1, 2, 3)) -> True\n- all_elements_same_type((1, 2, '3')) -> False\n- all_elements_same_type(()) -> True\n\nNote: This uses exact type equality (type(x) is first_type). If you want to consider subclass instances as the same type, you could use isinstance(x, first_type) instead, but that may treat certain subclasses (like bool vs int) differently."}
{"task_id": "Mbpp/226", "completion": "Here's a simple function that removes characters at odd indices (keeps characters at even indices: 0, 2, 4, ...):\n\ndef remove_odd_index_chars(s: str) -> str:\n    \"\"\"\n    Return a string formed by characters at even indices of s (i.e., remove characters at odd indices).\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return s[::2]\n\n# Example\nprint(remove_odd_index_chars(\"abcdef\"))  # Output: \"ace\""}
{"task_id": "Mbpp/141", "completion": "Here are a few straightforward options in Python. If you\u2019d like another language, tell me which one.\n\n1) Simple, using Python\u2019s built-in sort (recommended for most cases)\n- This returns a new sorted list.\n- Supports an optional key function and reverse order.\n\ndef sort_list(elements, key=None, reverse=False):\n    \"\"\"\n    Return a new list with elements sorted.\n    key: optional function to extract a comparison key from each element.\n    reverse: if True, sort in descending order.\n    \"\"\"\n    return sorted(elements, key=key, reverse=reverse)\n\n# Example\nlst = [3, 1, 4, 1, 5, 9]\nprint(sort_list(lst))                 # [1, 1, 3, 4, 5, 9]\nprint(sort_list(lst, reverse=True))   # [9, 5, 4, 3, 1, 1]\n\n2) In-place sort (modifies the original list)\n- Uses the list.sort method for in-place sorting.\n\ndef sort_inplace(lst, key=None, reverse=False):\n    \"\"\"\n    Sort the list in place.\n    key: optional function to extract a comparison key from each element.\n    reverse: if True, sort in descending order.\n    \"\"\"\n    lst.sort(key=key, reverse=reverse)\n\n# Example\narr = [3, 1, 4, 1, 5, 9]\nsort_inplace(arr)\nprint(arr)  # [1, 1, 3, 4, 5, 9]\n\n3) A simple, explicit sort algorithm (quicksort)\n- Educational example that sorts a list without using the built-in sort.\n- Not as fast as Python\u2019s built-ins for large lists, but demonstrates the algorithm.\n- Supports an optional key function and reverse order.\n\ndef quicksort(arr, key=None, reverse=False):\n    if len(arr) <= 1:\n        return arr[:]\n\n    pivot = arr[len(arr) // 2]\n    get = (lambda x: x) if key is None else key\n    p = get(pivot)\n\n    left = [x for x in arr if get(x) < p]\n    middle = [x for x in arr if get(x) == p]\n    right = [x for x in arr if get(x) > p]\n\n    left_sorted = quicksort(left, key=key, reverse=reverse)\n    right_sorted = quicksort(right, key=key, reverse=reverse)\n\n    result = left_sorted + middle + right_sorted\n    if reverse:\n        result.reverse()\n    return result\n\n# Example\nlst = [3, 1, 4, 1, 5, 9]\nprint(quicksort(lst))                   # [1, 1, 3, 4, 5, 9]\nprint(quicksort(lst, reverse=True))     # [9, 5, 4, 3, 1, 1]\n\nTips:\n- For custom objects, provide a key function (e.g., key=lambda x: x.value) or implement __lt__ on the objects.\n- In practice, use the built-in sorted()/list.sort for performance and reliability.\n\nIf you tell me your language of choice or any constraints (e.g., stable sort, in-place vs. out-of-place, handling custom objects), I can tailor the function accordingly."}
{"task_id": "Mbpp/230", "completion": "Here\u2019s a simple Python function that replaces space characters (' ') in a string with a given replacement character.\n\ndef replace_spaces(s, ch):\n    if not isinstance(s, str):\n        raise TypeError(\"s must be a string\")\n    if not isinstance(ch, str) or len(ch) != 1:\n        raise ValueError(\"ch must be a single character string\")\n    return s.replace(' ', ch)\n\n# Example usage\ntext = \"Hello world from AI\"\nprint(replace_spaces(text, \"_\"))  # \"Hello_world_from_AI\"\n\nNotes:\n- This replaces only the space character ' '. If you meant all whitespace (spaces, tabs, newlines, etc.), you can use a regex version:\n  import re\n  def replace_whitespace(s, ch):\n      if not isinstance(s, str) or not isinstance(ch, str) or len(ch) != 1:\n          raise ValueError(\"Invalid inputs\")\n      return re.sub(r'\\s', ch, s)"}
{"task_id": "Mbpp/232", "completion": "Here\u2019s a Python function that returns the n largest items from a list, handling edge cases and preserving duplicates. It uses a heap for efficiency.\n\n```python\nfrom typing import List, TypeVar\nimport heapq\n\nT = TypeVar('T')\n\ndef n_largest(items: List[T], n: int) -> List[T]:\n    \"\"\"\n    Return the n largest elements from items (in descending order).\n    - If n <= 0: returns []\n    - If n >= len(items): returns all items in descending order\n    - Duplicates are preserved according to their counts in items\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        return []\n    if n >= len(items):\n        return sorted(items, reverse=True)\n    return heapq.nlargest(n, items)\n\n# Example:\n# n_largest([3, 1, 4, 1, 5, 9, 2], 3)  -> [9, 5, 4]\n```\n\nNotes:\n- Time complexity: O(m log n) where m is the length of items, and O(n) extra space.\n- If you want the results in ascending order, you can wrap the result with sorted(...)."}
{"task_id": "Mbpp/160", "completion": "Here\u2019s a Python function that finds integers x and y such that a*x + b*y = n, or returns None if no solution exists.\n\n- It uses the extended Euclidean algorithm to get a particular solution to a*x0 + b*y0 = gcd(a,b), then scales to n.\n- A solution exists iff gcd(a,b) divides n.\n- Handles edge cases like a or b being zero.\n\nCode:\n\n```python\ndef _extended_gcd(a, b):\n    # Returns (g, x, y) such that a*x + b*y = g, where g = gcd(a, b) (g >= 0)\n    if b == 0:\n        return (abs(a), 1 if a >= 0 else -1, 0)\n    g, x1, y1 = _extended_gcd(b, a % b)\n    x = y1\n    y = x1 - (a // b) * y1\n    return (g, x, y)\n\ndef diophantine(a, b, n):\n    \"\"\"\n    Return a tuple (x, y) of integers such that a*x + b*y = n, or None if no solution.\n    \"\"\"\n    if a == 0 and b == 0:\n        return (0, 0) if n == 0 else None\n\n    g, x0, y0 = _extended_gcd(a, b)\n    if g < 0:\n        g, x0, y0 = -g, -x0, -y0\n\n    if n % g != 0:\n        return None\n\n    mult = n // g\n    return (x0 * mult, y0 * mult)\n\n# Examples\n# diophantine(6, 9, 15) -> e.g., (-5, 5)\n# diophantine(4, 2, 7) -> None\n```\n\nIf you want a quick one-liner check:\n- Return None if gcd(a,b) does not divide n; otherwise return the scaled extended gcd solution."}
{"task_id": "Mbpp/227", "completion": "Here are simple implementations in a few popular languages. All take three numbers and return the smallest.\n\n- Python\n  def min_of_three(a, b, c):\n      return min(a, b, c)\n\n- JavaScript\n  function minOfThree(a, b, c) {\n      return Math.min(a, b, c);\n  }\n\n- Java (primitive ints)\n  public static int minOfThree(int a, int b, int c) {\n      return Math.min(a, Math.min(b, c));\n  }\n\n- Java (generic with Comparable)\n  public static <T extends Comparable<T>> T minOfThree(T a, T b, T c) {\n      T m = a;\n      if (b.compareTo(m) < 0) m = b;\n      if (c.compareTo(m) < 0) m = c;\n      return m;\n  }\n\n- C++\n  #include <algorithm>\n  template <typename T>\n  T minOfThree(T a, T b, T c) {\n      return std::min(a, std::min(b, c));\n  }\n\nIf you tell me your preferred language or any constraints (e.g., handling non-numeric inputs, floating-point NaN, etc.), I can tailor the function accordingly."}
{"task_id": "Mbpp/162", "completion": "Here's a concise Python function using a closed-form formula.\n\nDerivation:\nLet m = floor(n/2). The sum S = sum_{i=0}^{m} (n - 2i) = (m+1)*n - 2*(m*(m+1)/2) = (m+1)*(n - m).\n\nPython function:\n\ndef sum_seq(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    m = n // 2\n    return (m + 1) * (n - m)\n\n# Examples\nprint(sum_seq(5))  # 9  -> 5 + 3 + 1\nprint(sum_seq(4))  # 6  -> 4 + 2 + 0\n\nIf you prefer a straightforward loop (less efficient but clear):\n\ndef sum_seq_loop(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    total = 0\n    i = 0\n    while n - 2*i >= 0:\n        total += n - 2*i\n        i += 1\n    return total\n\nBoth will compute the sum n + (n-2) + (n-4) ... down to the last term which is >= 0."}
{"task_id": "Mbpp/233", "completion": "Here\u2019s a simple function in Python. It uses the formula LSA = 2 * pi * r * h and validates inputs.\n\nPython\ndef lateral_surface_area(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n    LSA = 2 * pi * radius * height\n    \"\"\"\n    if radius < 0 or height < 0:\n        raise ValueError(\"radius and height must be non-negative\")\n    import math\n    return 2 * math.pi * radius * height\n\n# Example usage:\n# LSA for radius=3, height=5\nprint(lateral_surface_area(3, 5))  # \u2248 94.2477796077\n\nIf you\u2019d like this in another language, I can provide JavaScript, Java, or C++ versions as well. Which language should I use?"}
{"task_id": "Mbpp/237", "completion": "Here\u2019s a simple Python function that does this.\n\n```python\ndef count_tuple_occurrences(tuples_list):\n    \"\"\"\n    Given a list of tuples, return a dict mapping each unique tuple\n    to the number of times it occurs in the list.\n    All elements of the list must be tuples with hashable contents.\n    \"\"\"\n    counts = {}\n    for t in tuples_list:\n        if not isinstance(t, tuple):\n            raise TypeError(\"All elements must be tuples.\")\n        counts[t] = counts.get(t, 0) + 1\n    return counts\n```\n\nExample:\n- data = [(1, 2), (3, 4), (1, 2), (5, 6)]\n- count_tuple_occurrences(data) -> {(1, 2): 2, (3, 4): 1, (5, 6): 1}\n\nNotes:\n- Tuples must contain hashable elements to be usable as dictionary keys.\n- Time complexity: O(n) where n is the length of the list.\n- Space complexity: O(k) where k is the number of unique tuples."}
{"task_id": "Mbpp/234", "completion": "The volume of a cube is side_length^3. Here is a simple Python function with input validation:\n\n```python\ndef cube_volume(side_length):\n    \"\"\"\n    Return the volume of a cube with the given side length.\n    side_length must be a non-negative number (int or float).\n    \"\"\"\n    if not isinstance(side_length, (int, float)):\n        raise TypeError(\"side_length must be a number (int or float)\")\n    if side_length < 0:\n        raise ValueError(\"side_length must be non-negative\")\n    return side_length ** 3\n```\n\nIf you\u2019d like this in another language (JavaScript, Java, C++, etc.), tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/170", "completion": "Here are simple implementations in a few common languages. I\u2019ll treat the range as inclusive by default, and I\u2019ll also show how to handle an exclusive option. If you want a fast answer for many queries, you can precompute prefix sums.\n\n1) Python (inclusive by default, with an option for exclusive)\n- Simple approach (O(n) for each call)\ndef sum_range(nums, start, end, inclusive=True):\n    n = len(nums)\n    if start > end:\n        start, end = end, start\n    # clamp to valid indices\n    i = max(0, start)\n    j = min(n - 1, end)\n    if i > j:\n        return 0\n    if inclusive:\n        return sum(nums[i:j+1])\n    else:\n        return sum(nums[i:j])\n\n- Prefix-sums approach (O(1) per query after O(n) preprocessing)\ndef prefix_sums(nums):\n    ps = [0]\n    for x in nums:\n        ps.append(ps[-1] + x)\n    return ps\n\ndef range_sum_ps(ps, start, end, inclusive=True):\n    # nums length is len(ps) - 1\n    n = len(ps) - 1\n    i, j = min(start, end), max(start, end)\n    i = max(0, i)\n    j = min(n - 1, j)\n    if i > j:\n        return 0\n    if inclusive:\n        return ps[j + 1] - ps[i]\n    else:\n        return ps[j] - ps[i]\n\n2) JavaScript (inclusive by default)\nfunction sumRange(arr, i, j, inclusive = true) {\n  let a = Math.min(i, j);\n  let b = Math.max(i, j);\n  a = Math.max(0, a);\n  b = Math.min(arr.length - 1, b);\n  if (a > b) return 0;\n  let sum = 0;\n  if (inclusive) {\n    for (let k = a; k <= b; k++) sum += arr[k];\n  } else {\n    for (let k = a; k < b; k++) sum += arr[k];\n  }\n  return sum;\n}\n\n3) Java\npublic static int sumRange(int[] arr, int i, int j, boolean inclusive) {\n    int a = Math.min(i, j);\n    int b = Math.max(i, j);\n    a = Math.max(0, a);\n    b = Math.min(arr.length - 1, b);\n    if (a > b) return 0;\n    int sum = 0;\n    for (int k = a; k <= (inclusive ? b : b - 1); k++) {\n        sum += arr[k];\n    }\n    return sum;\n}\n\n4) C++\n#include <vector>\nint sumRange(const std::vector<int>& arr, int i, int j, bool inclusive = true) {\n    int a = std::min(i, j);\n    int b = std::max(i, j);\n    a = std::max(0, a);\n    b = std::min((int)arr.size() - 1, b);\n    if (a > b) return 0;\n    int sum = 0;\n    for (int k = a; k <= (inclusive ? b : b - 1); ++k) sum += arr[k];\n    return sum;\n}\n\nNotes:\n- Inclusive range means you include both endpoints; exclusive means you exclude the end index.\n- If an index is out of bounds, these snippets clamp to valid indices. If you prefer to raise an error instead, add explicit checks and throw/return errors.\n- If you\u2019ll perform many range sums on the same list, consider precomputing prefix sums to get O(1) queries after O(n) setup.\n\nIf you tell me your preferred language and whether you want inclusive or exclusive ranges (and how you want to handle out-of-bounds indices), I can tailor a precise snippet."}
{"task_id": "Mbpp/224", "completion": "Here\u2019s a simple and robust Python function. It uses the built-in bit_count() when available (Python 3.10+), and falls back to a Kernighan\u2019s algorithm for older versions. It expects a non-negative integer.\n\n```python\ndef count_set_bits(n: int) -> int:\n    \"\"\"\n    Return the number of set bits (1s) in the non-negative integer n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    # Prefer the fast built-in if available\n    try:\n        return n.bit_count()\n    except AttributeError:\n        # Fallback for older Python versions\n        count = 0\n        while n:\n            n &= n - 1  # clear the least significant set bit\n            count += 1\n        return count\n```\n\nUsage examples:\n- count_set_bits(0b101101) -> 4\n- count_set_bits(1234) -> 5\n\nIf you need to handle negative numbers or fixed-width representations (e.g., two's complement for 32 bits), I can tailor the function accordingly."}
{"task_id": "Mbpp/238", "completion": "Here is a simple function. For a string of length n, the total number of non-empty substrings (counting duplicates) is n*(n+1)/2.\n\ndef count_nonempty_substrings(s):\n    \"\"\"\n    Return the total number of non-empty substrings of s\n    (counting substrings by position, not distinct substrings).\n    \"\"\"\n    n = len(s)\n    return n * (n + 1) // 2\n\n# Example:\n# count_nonempty_substrings(\"abc\") -> 6\n\nIf you actually meant the number of distinct substrings (unique substrings), that requires generating substrings and counting unique ones, e.g.:\n\ndef count_distinct_substrings(s):\n    seen = set()\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            seen.add(s[i:j])\n    return len(seen)\n\nNote: the distinct-substring version runs in O(n^2) time and O(n^2) space in the worst case."}
{"task_id": "Mbpp/251", "completion": "Here is a simple Python function that inserts the given element before each element of the input list and returns the new list.\n\nOption 1: straightforward loop\ndef insert_before_each(lst, elem):\n    result = []\n    for item in lst:\n        result.append(elem)\n        result.append(item)\n    return result\n\nOption 2: concise using a list comprehension\ndef insert_before_each(lst, elem):\n    return [x for item in lst for x in (elem, item)]\n\nExamples:\n- insert_before_each([1, 2, 3], 0) -> [0, 1, 0, 2, 0, 3]\n- insert_before_each([], 'a') -> []"}
{"task_id": "Mbpp/257", "completion": "Here's a simple Python function that does that:\n\n```python\ndef swap_tuple(a, b):\n    \"\"\"Return a tuple with the second number first, then the first.\"\"\"\n    return (b, a)\n\n# Example:\nprint(swap_tuple(3, 7))  # (7, 3)\n```\n\nIf you want type hints for numbers (int or float):\n\n```python\nfrom typing import Union, Tuple\n\nNumber = Union[int, float]\n\ndef swap_tuple(a: Number, b: Number) -> Tuple[Number, Number]:\n    return (b, a)\n\n# Example:\nprint(swap_tuple(3.5, 2))  # (2, 3.5)\n```"}
{"task_id": "Mbpp/116", "completion": "Here's a clean, invertible way to map a tuple of positive integers to a single integer using Cantor pairing, with decoding support. It includes the length of the tuple so you can recover the original sequence.\n\nPython code:\n\ndef pair(a, b):\n    s = a + b\n    return s * (s + 1) // 2 + b\n\ndef unpair(z):\n    import math\n    w = (math.isqrt(8 * z + 1) - 1) // 2\n    t = w * (w + 1) // 2\n    y = z - t\n    x = w - y\n    return x, y\n\ndef encode_tuple(t):\n    \"\"\"\n    Encode a non-empty tuple of positive integers into a single integer.\n    If t is empty, returns 0.\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple.\")\n    if len(t) == 0:\n        return 0\n    if any((not isinstance(v, int) or v <= 0) for v in t):\n        raise ValueError(\"All elements must be positive integers.\")\n\n    res = t[0]\n    for x in t[1:]:\n        res = pair(res, x)\n    # include the length to allow decoding\n    return pair(len(t), res)\n\ndef decode_tuple(z):\n    \"\"\"\n    Decode an integer produced by encode_tuple back into the original tuple.\n    Returns a tuple of integers.\n    \"\"\"\n    if z == 0:\n        return ()\n    n, res = unpair(z)\n    t = [0] * n\n    for i in range(n - 1, 0, -1):\n        res, ai = unpair(res)\n        t[i] = ai\n    t[0] = res\n    return tuple(t)\n\n# Example\nt = (3, 7, 2, 9)\ncode = encode_tuple(t)\nprint(\"Encoded:\", code)\nprint(\"Decoded:\", decode_tuple(code))\n\nNotes:\n- This method is bijective: every tuple maps to a unique integer and can be recovered exactly if you use the encode/decode pair above.\n- Time complexity is O(n) for both encoding and decoding, where n is the tuple length.\n- The numbers can become very large, since Cantor pairing expands quickly; Python\u2019s big integers handle this, but in other languages you may need to watch for overflow."}
{"task_id": "Mbpp/250", "completion": "Here's a simple function using Python's built-in tuple.count method:\n\ndef count_occurrences(tup: tuple, element) -> int:\n    \"\"\"Return the number of times element occurs in the tuple tup.\"\"\"\n    return tup.count(element)\n\nIf you want to implement it without using count(), you can do it manually:\n\ndef count_occurrences_manual(tup: tuple, element) -> int:\n    \"\"\"Manually count occurrences of element in tup.\"\"\"\n    count = 0\n    for item in tup:\n        if item == element:\n            count += 1\n    return count\n\nExample:\nt = (1, 2, 1, 3, 1)\nprint(count_occurrences(t, 1))  # 3\nprint(count_occurrences_manual(t, 1))  # 3"}
{"task_id": "Mbpp/245", "completion": "Here's a Python function to compute the maximum sum of a bitonic subsequence (strictly increasing then strictly decreasing). It runs in O(n^2) time and uses O(n) extra space.\n\ndef max_sum_bitonic_subsequence(arr):\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    # inc[i] = max sum of an increasing subsequence ending at i\n    inc = arr[:]\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n\n    # dec[i] = max sum of a decreasing subsequence starting at i\n    dec = arr[:]\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n\n    # Combine: peak at i -> inc[i] + dec[i] - arr[i]\n    max_sum = 0\n    for i in range(n):\n        total = inc[i] + dec[i] - arr[i]\n        if total > max_sum:\n            max_sum = total\n\n    return max_sum\n\nUsage example:\narr = [1, 15, 26, 10, 5, 20]\nprint(max_sum_bitonic_subsequence(arr))  # outputs the maximum sum of a bitonic subsequence\n\nNotes:\n- Assumes strictly increasing then strictly decreasing sequences. Use < comparisons for both phases.\n- For an empty array, returns 0. For negative numbers, the result will be the maximum single element."}
{"task_id": "Mbpp/244", "completion": "Here's a concise function that returns the smallest perfect square strictly greater than the given number n.\n\n```python\nimport math\n\ndef next_perfect_square(n):\n    \"\"\"\n    Return the smallest perfect square strictly greater than n.\n    For n < 0, returns 0 since 0 is the first perfect square greater than negative numbers.\n    \"\"\"\n    if n < 0:\n        return 0\n    root = math.isqrt(n)  # floor(sqrt(n))\n    return (root + 1) ** 2\n```\n\nNotes:\n- Uses math.isqrt for an exact integer floor square root (Python 3.8+).\n- Time and space complexity: O(1).\n- Examples:\n  - next_perfect_square(9) -> 16\n  - next_perfect_square(8) -> 9\n  - next_perfect_square(-5) -> 0\n\nIf you need compatibility with older Python versions (without math.isqrt), you can replace the sqrt computation with int(n**0.5) or provide a small fallback."}
{"task_id": "Mbpp/240", "completion": "Here\u2019s a Python function that replaces the last element of the first list with the elements of the second list. It mutates the first list in place and returns it for convenience.\n\n```python\ndef replace_last_with_list(first, second):\n    \"\"\"\n    Replace the last element of 'first' with the elements of 'second'.\n    Mutates 'first' in place. Raises ValueError if 'first' is empty.\n    \"\"\"\n    if not isinstance(first, list) or not isinstance(second, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if len(first) == 0:\n        raise ValueError(\"First list must contain at least one element to replace its last element.\")\n    \n    # Replace the last element with all elements from 'second'\n    first[-1:] = second\n    return first\n```\n\nUsage example:\n```python\nlst1 = [1, 2, 3]\nlst2 = [4, 5]\nprint(replace_last_with_list(lst1, lst2))  # Output: [1, 2, 4, 5]\n```\n\nIf you prefer a non-mutating version (returns a new list and leaves the originals unchanged):\n\n```python\ndef merged_without_mutation(first, second):\n    if not isinstance(first, list) or not isinstance(second, list):\n        raise TypeError(\"Both arguments must be lists.\")\n    if len(first) == 0:\n        raise ValueError(\"First list must contain at least one element.\")\n    return first[:-1] + second\n```\n\nUsage:\n```python\nlst1 = [1, 2, 3]\nlst2 = [4, 5]\nnew_list = merged_without_mutation(lst1, lst2)\nprint(new_list)  # [1, 2, 4, 5]\nprint(lst1)      # [1, 2, 3]  (unchanged)\n```"}
{"task_id": "Mbpp/223", "completion": "Here's a clean approach: since the array is sorted, the number of occurrences of x is last_index_of_x minus first_index_of_x. If that count is greater than n/2, x is the majority element.\n\nPython implementation (binary-search to get first and last positions):\n\n```python\ndef is_majority_sorted(arr, n, x):\n    # Find first index of x (lower_bound)\n    lo, hi = 0, n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid\n    first = lo\n\n    # Find first index > x (upper_bound)\n    lo, hi = 0, n\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if arr[mid] <= x:\n            lo = mid + 1\n        else:\n            hi = mid\n    last = lo\n\n    count = last - first\n    return count > n // 2\n```\n\nNotes:\n- Time complexity: O(log n) due to two binary searches.\n- Space complexity: O(1).\n\nAlternative (using Python's bisect module):\n\n```python\nimport bisect\n\ndef is_majority_sorted_bisect(arr, n, x):\n    left = bisect.bisect_left(arr, x, 0, n)\n    right = bisect.bisect_right(arr, x, 0, n)\n    return (right - left) > n // 2\n```\n\nC++ variant (using standard library):\n\n```cpp\n#include <vector>\n#include <algorithm>\n\nbool is_majority_sorted(const std::vector<int>& arr, int n, int x) {\n    int first = std::lower_bound(arr.begin(), arr.begin() + n, x) - arr.begin();\n    int last  = std::upper_bound(arr.begin(), arr.begin() + n, x) - arr.begin();\n    return (last - first) > n / 2;\n}\n```"}
{"task_id": "Mbpp/242", "completion": "Here are simple ways to count characters in a string in a few common languages. By default, this counts Unicode code points (not just bytes). If you need user-perceived characters (grapheme clusters), you\u2019ll want a more advanced approach or a library.\n\nPython\n- Counts Unicode code points\ndef count_chars(s: str) -> int:\n    return len(s)\n\nJavaScript\n- Counts Unicode code points (works for surrogate pairs)\nfunction countChars(s) {\n  // Using Array.from or spread operator to iterate by code points\n  return Array.from(s).length;\n  // or: return [...s].length;\n}\n\nJava\n- Counts UTF-16 code units (basic)\npublic static int countChars(String s) {\n    return s.length();\n}\n- Counts Unicode code points\npublic static int countCodePoints(String s) {\n    return s.codePointCount(0, s.length());\n}\n\nIf you tell me your preferred language (and whether you want code points or grapheme clusters), I can tailor the exact function accordingly."}
{"task_id": "Mbpp/252", "completion": "Here\u2019s a simple Python function that converts a complex number to polar coordinates (radius r and angle theta). It returns theta in radians by default, and you can request degrees with deg=True.\n\n```python\nimport math\n\ndef complex_to_polar(z, deg=False):\n    \"\"\"\n    Convert a complex number z to polar coordinates (r, theta).\n\n    Parameters:\n        z: complex or real number (will be treated as complex)\n        deg: if True, return theta in degrees, else in radians\n\n    Returns:\n        (r, theta) where:\n            r     = magnitude |z|\n            theta = angle/phase of z\n    \"\"\"\n    z = complex(z)\n    r = abs(z)\n    theta = math.atan2(z.imag, z.real)  # radians in (-pi, pi]\n    if deg:\n        theta = math.degrees(theta)\n    return (r, theta)\n```\n\nExamples:\n- complex_to_polar(3 + 4j) -> (5.0, 0.9272952180016122)\n- complex_to_polar(3 + 4j, deg=True) -> (5.0, 53.13010235415599)\n\nNote: Python\u2019s cmath module already provides this directly via cmath.polar(z), which returns (r, phi) with phi in radians. You can use it as an alternative:\n- import cmath\n- cmath.polar(3+4j)  # -> (5.0, 0.9272952180016122)"}
{"task_id": "Mbpp/261", "completion": "Here\u2019s a Python function that does element-wise division of two tuples, with basic validation and clear errors.\n\n```python\nfrom typing import Tuple\n\ndef elementwise_divide(t1: Tuple[float, ...], t2: Tuple[float, ...]) -> Tuple[float, ...]:\n    \"\"\"\n    Divide corresponding elements of t1 by t2.\n    Both tuples must be the same length and contain numbers.\n    \"\"\"\n    if not isinstance(t1, tuple) or not isinstance(t2, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must be of the same length.\")\n    \n    result = []\n    for a, b in zip(t1, t2):\n        if b == 0:\n            raise ZeroDivisionError(\"Division by zero encountered in the second tuple.\")\n        result.append(a / b)\n    return tuple(result)\n```\n\nExample usage:\n```python\na = (6, 9, 3)\nb = (2, 3, 0.5)\nprint(elementwise_divide(a, b))  # Output: (3.0, 3.0, 6.0)\n```\n\nNotes:\n- Returns a tuple of floats.\n- Raises meaningful errors for non-tuple inputs, mismatched lengths, or division by zero.\n- If you want to handle non-numeric values gracefully, you could add type checks inside the loop."}
{"task_id": "Mbpp/253", "completion": "Here are simple options. The base version counts elements that are instances of int. Note that in Python, bool is a subclass of int, so True/False would be counted too unless you opt to exclude booleans.\n\nBasic version (includes booleans as integers):\ndef count_integers(lst):\n    \"\"\"\n    Return the number of integer elements in lst.\n    Note: booleans are counted as integers since bool is a subclass of int.\n    \"\"\"\n    return sum(isinstance(x, int) for x in lst)\n\nIf you want to exclude booleans:\ndef count_integers_excluding_bools(lst):\n    return sum(type(x) is int for x in lst)\n\nOr a single function with an option:\ndef count_integers(lst, exclude_bools=False):\n    if exclude_bools:\n        return sum(type(x) is int for x in lst)\n    else:\n        return sum(isinstance(x, int) for x in lst)\n\nUsage examples:\nprint(count_integers([1, 2, \"3\", True, False, 4]))  # 5 (includes booleans)\nprint(count_integers([1, 2, \"3\", True, False, 4], exclude_bools=True))  # 3 (excludes booleans)"}
{"task_id": "Mbpp/247", "completion": "Here\u2019s a Python function that computes the length of the longest palindromic subsequence (LPS) using dynamic programming.\n\ndef longest_palindromic_subsequence_length(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n\n    # dp[i][j] will hold the length of the LPS in s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    # Substrings of length 1 are palindromes of length 1\n    for i in range(n):\n        dp[i][i] = 1\n\n    # Build up solutions for substrings of increasing length\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                if length == 2:\n                    dp[i][j] = 2\n                else:\n                    dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]\n\nNotes:\n- Time complexity: O(n^2)\n- Space complexity: O(n^2)\n- If you want a space-optimized version, you can implement a 1D DP approach (still O(n^2) time) by iterating and keeping only the current and previous rows.\n\nExamples:\n- longest_palindromic_subsequence_length(\"bbbab\") -> 4\n- longest_palindromic_subsequence_length(\"cbbd\") -> 2\n- longest_palindromic_subsequence_length(\"\") -> 0\n- longest_palindromic_subsequence_length(\"a\") -> 1"}
{"task_id": "Mbpp/255", "completion": "Here are two Python options. Both return a list of tuples, each tuple representing a combination of length n with repetition allowed.\n\nOption 1: Backtracking (no extra imports)\n- Keeps the order non-decreasing with respect to the input list (i.e., combinations, not permutations).\n\ndef combinations_with_repetition(items, n):\n    \"\"\"Return all combinations of length n from items with repetition.\n    Each combination is a tuple. Order within a combination is non-decreasing\n    with respect to the input order (combinations, not permutations).\"\"\"\n    result = []\n    if n == 0:\n        return [()]\n    if not items:\n        return []  # or [()] if you want to treat empty list specially when n==0\n\n    def backtrack(start, k, path):\n        if k == 0:\n            result.append(tuple(path))\n            return\n        for i in range(start, len(items)):\n            path.append(items[i])\n            backtrack(i, k - 1, path)  # i allows repetition\n            path.pop()\n\n    backtrack(0, n, [])\n    return result\n\n# Example\n# combinations_with_repetition([1, 2, 3], 2)\n# -> [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n\nOption 2: Using itertools (short and idiomatic)\nimport itertools\n\ndef combinations_with_repetition_itertools(items, n):\n    \"\"\"Return all combinations of length n from items with repetition,\n    using itertools. Returns a list of tuples.\"\"\"\n    return list(itertools.combinations_with_replacement(items, n))\n\n# Example\n# combinations_with_repetition_itertools([1, 2, 3], 2)\n# -> [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]\n\nIf you have a different language in mind, tell me which one and I\u2019ll adapt accordingly."}
{"task_id": "Mbpp/235", "completion": "Here\u2019s a Python function that sets all even-positioned bits (0-based, i.e., bits 0, 2, 4, ...) of a non-negative integer. It constructs a mask with 1s at even positions up to the number\u2019s bit length and ORs it with the input.\n\ndef set_even_bits(n):\n    \"\"\"\n    Return n with all even-positioned bits set to 1.\n    Bit positions are 0-based (LSB is bit 0).\n    Works for non-negative integers. If n == 0, returns 1.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 1\n\n    mask = 0\n    limit = n.bit_length()  # consider bits 0 .. limit-1\n    i = 0\n    while i < limit:\n        mask |= (1 << i)\n        i += 2\n    return n | mask\n\nYou can test a couple of cases:\n- set_even_bits(0) -> 1\n- set_even_bits(5) (101b) -> 5 (bits 0 and 2 already 1)\n- set_even_bits(8) (1000b) -> 13 (1101b)"}
{"task_id": "Mbpp/172", "completion": "Here is a simple function in Python that counts occurrences of the substring \"std\" in a given string. By default it does non-overlapping, case-sensitive counting. You can adjust for case-insensitivity if needed.\n\nPython (non-overlapping, case-sensitive by default)\n```\ndef count_std(s, case_sensitive=True):\n    if case_sensitive:\n        return s.count(\"std\")\n    else:\n        return s.lower().count(\"std\")\n```\n\nIf you want to count overlapping occurrences (though for \"std\" there isn\u2019t any practical overlap), you can implement a small tweak:\n```\ndef count_std_overlapping(s, case_sensitive=True):\n    needle = \"std\"\n    text = s if case_sensitive else s.lower()\n    if not case_sensitive:\n        needle = \"std\"\n    count = 0\n    for i in range(len(text) - len(needle) + 1):\n        if text[i:i+len(needle)] == needle:\n            count += 1\n    return count\n```\n\nIf you\u2019d like, I can provide equivalents in another language (JavaScript, Java, C++, etc.). Which language should I target?"}
{"task_id": "Mbpp/256", "completion": "Here's a Python function that counts how many primes are less than a given non-negative number. It handles integers and floats (by flooring the input to an integer).\n\n```python\ndef count_primes_less_than(n):\n    \"\"\"\n    Return the number of primes p with 0 <= p < n.\n    n can be int or float (non-negative). If n is not an integer, it is floored.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    m = int(n)  # floor for non-integer inputs\n    if m < 2:\n        return 0\n\n    # Sieve of Eratosthenes to count primes < m\n    is_prime = [True] * m\n    is_prime[0] = is_prime[1] = False\n\n    p = 2\n    while p * p < m:\n        if is_prime[p]:\n            for i in range(p * p, m, p):\n                is_prime[i] = False\n        p += 1\n\n    return sum(is_prime)\n\n# Example:\n# count_primes_less_than(10) -> 4  (primes: 2, 3, 5, 7)\n```"}
{"task_id": "Mbpp/266", "completion": "The lateral surface area of a cube is the area of the four side faces, which equals 4 \u00d7 a^2, where a is the side length.\n\nPython function:\n\n```python\ndef lateral_surface_area_cube(side: float) -> float:\n    \"\"\"\n    Return the lateral surface area of a cube given its side length.\n    LSA = 4 * side^2\n    Side length must be non-negative.\n    \"\"\"\n    if side < 0:\n        raise ValueError(\"Side length must be non-negative.\")\n    return 4 * (side ** 2)\n```\n\nExample:\n- lateral_surface_area_cube(3) -> 36.0"}
{"task_id": "Mbpp/262", "completion": "Here's a Python function that splits a list into two parts where the first part has length L. It includes input validation to ensure L is within [0, len(lst)].\n\ndef split_list(lst, L):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(L, int):\n        raise TypeError(\"L must be an integer\")\n    if L < 0 or L > len(lst):\n        raise ValueError(\"L must be between 0 and the length of lst inclusive\")\n\n    return lst[:L], lst[L:]\n\nUsage examples:\n- split_list([1, 2, 3, 4, 5], 3) -> ([1, 2, 3], [4, 5])\n- split_list([], 0) -> ([], [])\n- split_list([1, 2, 3], 3) -> ([1, 2, 3], [])\n\nIf you want a version that tolerates out-of-range L by clamping it to valid bounds, use:\n\ndef split_list_clamped(lst, L):\n    L = max(0, min(L, len(lst)))\n    return lst[:L], lst[L:]"}
{"task_id": "Mbpp/265", "completion": "Here\u2019s a simple Python function that splits a list into chunks of size n. The last chunk may be shorter if the list length isn\u2019t a multiple of n.\n\ndef split_every_n(lst, n):\n    \"\"\"\n    Split lst into chunks of size n. The last chunk may be smaller.\n    Args:\n        lst (list): input list\n        n (int): chunk size (positive)\n    Returns:\n        list[list]: list of sublists\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return [lst[i:i+n] for i in range(0, len(lst), n)]\n\n# Examples\nprint(split_every_n([1, 2, 3, 4, 5, 6, 7], 3))\n# [[1, 2, 3], [4, 5, 6], [7]]\n\nIf you want a version that returns an iterator (generator) instead of a list of lists, you can use a similar approach with yield."}
{"task_id": "Mbpp/268", "completion": "Star numbers are given by S(n) = 6n(n \u2212 1) + 1 (for n \u2265 1). So the n-th star number can be computed in O(1) time.\n\nPython example:\n\ndef nth_star_number(n):\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 6 * n * (n - 1) + 1\n\n# Examples\nfor n in range(1, 6):\n    print(n, nth_star_number(n))\n\nNotes:\n- This yields the sequence: 1, 13, 37, 73, 121, ...\n- If n is large, be mindful of integer size in your language (Python handles big integers; others may require 64-bit or BigInt)."}
{"task_id": "Mbpp/273", "completion": "Here\u2019s a simple Python function that subtracts corresponding elements of two tuples. It requires the tuples to have the same length.\n\n```python\ndef subtract_tuples(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Subtract elements of t2 from t1 at the same indices.\n    Both tuples must have the same length.\n    Returns a new tuple with the results.\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must have the same length\")\n    return tuple(a - b for a, b in zip(t1, t2))\n\n# Example:\n# subtract_tuples((5, 3, 9), (1, 2, 7)) -> (4, 1, 2)\n```"}
{"task_id": "Mbpp/259", "completion": "There are a few sensible interpretations of \u201cmaximize the given two tuples.\u201d Here are common ones in Python, with example implementations. Let me know which one you want or if you have a different criterion.\n\n1) Lexicographic maximum (Python\u2019s default behavior)\n- Returns the tuple that would come later in lexicographic order.\n\ndef max_tuples_lex(a, b):\n    return a if a >= b else b\n\n# Example\n# max_tuples_lex((1, 4, 2), (1, 3, 9)) -> (1, 4, 2)\n\n2) Element-wise maximum (per-position max; longer tuple keeps extra elements)\n- Builds a new tuple where each position is max(a[i], b[i]).\n- If lengths differ, extra elements from the longer tuple are kept.\n\nfrom itertools import zip_longest\n\ndef max_tuples_elementwise(a, b):\n    res = []\n    for x, y in zip_longest(a, b, fillvalue=None):\n        if y is None:\n            res.append(x)\n        elif x is None:\n            res.append(y)\n        else:\n            res.append(x if x >= y else y)\n    return tuple(res)\n\n# Example\n# max_tuples_elementwise((1, 4, 2), (1, 3)) -> (1, 4, 2)\n\n3) Max by sum of elements\n- Chooses the tuple with the larger total sum.\n\ndef max_tuple_by_sum(a, b):\n    return a if sum(a) >= sum(b) else b\n\n# Example\n# max_tuple_by_sum((1, 4), (2, 3, 1)) -> (2, 3, 1)\n\n4) General function with a mode switch\n- Lets you pick the criterion via a parameter.\n\ndef maximize_tuples(a, b, mode='lex'):\n    if mode == 'lex':\n        return a if a >= b else b\n    elif mode == 'elementwise':\n        res = []\n        for x, y in zip_longest(a, b, fillvalue=None):\n            if y is None:\n                res.append(x)\n            elif x is None:\n                res.append(y)\n            else:\n                res.append(x if x >= y else y)\n        return tuple(res)\n    elif mode == 'sum':\n        sa, sb = sum(a), sum(b)\n        return a if sa >= sb else b\n    else:\n        raise ValueError('Unknown mode: ' + str(mode))\n\n# Examples\n# maximize_tuples((1,4,2), (1,3,9), mode='lex') -> (1,3,9)\n# maximize_tuples((1,4,2), (1,3,9), mode='elementwise') -> (1,4,9)\n# maximize_tuples((1,4), (2,3,1), mode='sum') -> (2,3,1)\n\nIf you share how you want to compare the two tuples (lexicographic, per-element, by sum, or something else), I can tailor the function exactly to that and provide tests."}
{"task_id": "Mbpp/276", "completion": "Here is the formula: Volume = \u03c0 \u00d7 r\u00b2 \u00d7 h\n\nExamples in a few common languages:\n\nPython\n```python\nimport math\n\ndef cylinder_volume(radius, height):\n    if radius < 0 or height < 0:\n        raise ValueError(\"radius and height must be non-negative\")\n    return math.pi * (radius ** 2) * height\n```\n\nJavaScript\n```javascript\nfunction cylinderVolume(radius, height) {\n  if (radius < 0 || height < 0) {\n    throw new Error(\"radius and height must be non-negative\");\n  }\n  return Math.PI * radius * radius * height;\n}\n```\n\nJava\n```java\npublic static double cylinderVolume(double radius, double height) {\n    if (radius < 0 || height < 0) {\n        throw new IllegalArgumentException(\"radius and height must be non-negative\");\n    }\n    return Math.PI * radius * radius * height;\n}\n```\n\nC++\n```cpp\n#include <stdexcept>\n#include <cmath>\n\ndouble cylinderVolume(double radius, double height) {\n    if (radius < 0 || height < 0) {\n        throw std::invalid_argument(\"radius and height must be non-negative\");\n    }\n    const double pi = 3.141592653589793;\n    return pi * radius * radius * height;\n}\n```\n\nIf you want it in a different language, tell me which one and I\u2019ll provide the exact function."}
{"task_id": "Mbpp/239", "completion": "Here's a Python function using dynamic programming.\n\nIdea:\n- Let dp[i][x] be the number of sequences of length i that end with x.\n- Base: dp[1][x] = 1 for all x in 1..m.\n- Transition: to have a[i] = x, the previous value y must satisfy y <= floor(x/2) and y <= m. So\n  dp[i][x] = sum_{y=1}^{floor(x/2)} dp[i-1][y].\n- Answer: sum over x of dp[n][x].\n\nImplementation (O(n*m) time, O(m) space):\n\ndef count_sequences(m, n):\n    \"\"\"\n    Count sequences of length n of positive integers such that:\n      a1 >= 1\n      ai >= 2*ai-1 for i > 1\n      ai <= m for all i\n    Returns the number of valid sequences.\n    \"\"\"\n    if n <= 0 or m <= 0:\n        return 0\n\n    # Quick feasibility check: if n > floor(log2(m)) + 1, impossible\n    if n > m.bit_length():\n        return 0\n\n    # Initialize for length 1: dp[x] = 1 for all x in 1..m\n    dp = [0] * (m + 1)\n    for x in range(1, m + 1):\n        dp[x] = 1\n\n    # Build up to length n\n    for _ in range(2, n + 1):\n        dp2 = [0] * (m + 1)\n        acc = 0\n        j = 1\n        for x in range(1, m + 1):\n            limit = x // 2\n            while j <= limit:\n                acc += dp[j]\n                j += 1\n            dp2[x] = acc\n        dp = dp2\n\n    return sum(dp[1:])\n\n# Example\nprint(count_sequences(5, 3))  # Output: 2\n\nNotes:\n- If m < 2^(n-1), the function returns 0 quickly due to the feasibility check (via bit_length).\n- The result can be large; Python handles big integers automatically."}
{"task_id": "Mbpp/272", "completion": "Here are a few simple options in Python. The basic idea is to take the last element of each tuple.\n\nOption 1: strict (assumes every tuple is non-empty)\n- Behavior: will raise IndexError if a tuple is empty.\n\n```python\nfrom typing import List, Tuple, Any\n\ndef rear_elements(tuples: List[Tuple[Any, ...]]) -> List[Any]:\n    \"\"\"\n    Return the last element of each tuple in the input list.\n    \"\"\"\n    return [t[-1] for t in tuples]\n```\n\nExample:\n- rear_elements([(1, 2, 3), (4, 5), (6,)]) -> [3, 5, 6]\n\nOption 2: tolerant (returns None for empty tuples)\n- Behavior: empty tuples yield None (or you can supply a different default).\n\n```python\nfrom typing import List, Tuple, Any\n\ndef rear_elements_tolerant(tuples: List[Tuple[Any, ...]], default: Any = None) -> List[Any]:\n    return [t[-1] if t else default for t in tuples]\n```\n\nExample:\n- rear_elements_tolerant([(1, 2, 3), (), (7, 8)]) -> [3, None, 8]\n\nOption 3: explicit loop (same as strict, with clearer handling)\n```python\nfrom typing import List, Tuple, Any\n\ndef rear_elements_loop(tuples: List[Tuple[Any, ...]]) -> List[Any]:\n    result = []\n    for t in tuples:\n        result.append(t[-1])  # will raise IndexError if t is empty\n    return result\n```\n\nChoose the version that matches how you want to handle empty tuples."}
{"task_id": "Mbpp/269", "completion": "Here are simple functions to get the numeric ASCII value of a single character in a few common languages. Note: in many languages, characters are Unicode, so the value you get may be a Unicode code point; for true ASCII you\u2019ll limit to 0\u2013127.\n\n- Python\n  def ascii_value(ch):\n      if not isinstance(ch, str) or len(ch) != 1:\n          raise ValueError(\"Provide a single character.\")\n      return ord(ch)\n\n- JavaScript\n  function asciiValue(ch) {\n      if (typeof ch !== 'string' || ch.length !== 1) {\n          throw new Error('Provide a single character.');\n      }\n      return ch.charCodeAt(0);\n  }\n\n- C\n  #include <stdint.h>\n  int ascii_value(char c) {\n      return (unsigned char) c; // 0\u2013255\n  }\n\n  // If you want to restrict to ASCII (0\u2013127):\n  // if (c < 0 || c > 127) handle_error();\n\n- C++\n  #include <cstdint>\n  int asciiValue(char c) {\n      return static_cast<unsigned char>(c);\n  }\n\n- Java\n  int asciiValue(char c) {\n      return (int) c; // Java chars are Unicode (16-bit)\n  }\n\n- Go\n  // For a single-byte ASCII character\n  func asciiValue(b byte) int {\n      return int(b)\n  }\n  // If you have a string:\n  // func asciiValue(s string) (int, error) { if len(s) != 1 { return 0, errors.New(\"one char\") }; return int(s[0]), nil }\n\n- Ruby\n  def ascii_value(ch)\n    ch.ord\n  end\n\n- PHP\n  function asciiValue($char) {\n      return ord($char);\n  }\n\n- C# (optional)\n  int asciiValue(char c) {\n      return (int)c;\n  }\n\nIf you tell me the language you\u2019re using (or whether you want to enforce ASCII 0\u2013127 strictly), I can tailor a single example for you."}
{"task_id": "Mbpp/267", "completion": "Here's a concise Python function using a closed-form formula for the sum:\n\n- Sum of squares of the first n odd numbers: sum_{k=1..n} (2k-1)^2 = n*(4n^2 - 1) / 3\n\nCode:\n\n```python\ndef sum_odd_squares(n: int) -> int:\n    \"\"\"\n    Return the sum of squares of the first n odd natural numbers.\n    i.e., sum_{k=1..n} (2k-1)^2\n\n    Uses the closed-form: n*(4*n*n - 1) // 3\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    return n * (4 * n * n - 1) // 3\n\n# Example:\n# sum_odd_squares(5) -> 165\n```"}
{"task_id": "Mbpp/270", "completion": "Here\u2019s a simple function that sums the even numbers located at even indices (0, 2, 4, ...) in a list. It ignores non-integer values and booleans.\n\n```python\ndef sum_even_numbers_at_even_positions(lst):\n    \"\"\"\n    Sum of elements that are even numbers at even indices (0-based).\n    Only integers are considered; booleans are ignored.\n    \"\"\"\n    total = 0\n    for i in range(0, len(lst), 2):  # even positions in 0-based indexing\n        val = lst[i]\n        if type(val) is int and val % 2 == 0:\n            total += val\n    return total\n\n# Example\nlst = [1, 2, 3, 4, 6, 7, 8]\nprint(sum_even_numbers_at_even_positions(lst))  # Output: 14\n```\n\nNotes:\n- If you meant \u201ceven positions\u201d in 1-based indexing (2nd, 4th, ...), use i % 2 == 1 instead of i % 2 == 0, or range(1, len(lst), 2).\n- If you want to include all numbers (not just integers), you can remove the type check."}
{"task_id": "Mbpp/277", "completion": "Here\u2019s a concise Python function that returns a new dictionary containing only items whose values are greater than or equal to n. It ignores non-numeric values.\n\n```python\ndef filter_dict_by_min_value(d, n):\n    if not isinstance(d, dict):\n        raise TypeError(\"d must be a dictionary\")\n    if not isinstance(n, (int, float)):\n        raise TypeError(\"n must be a number\")\n\n    return {k: v for k, v in d.items() if isinstance(v, (int, float)) and v >= n}\n```\n\nExample:\n```python\ndata = {'a': 3, 'b': 1.5, 'c': 10, 'd': 'x'}\nprint(filter_dict_by_min_value(data, 2))\n# Output: {'a': 3, 'c': 10}\n```"}
{"task_id": "Mbpp/279", "completion": "The nth decagonal number is given by D(n) = 4n^2 - 3n for n >= 1 (1-indexed).\n\nPython function:\n\ndef nth_decagonal(n: int) -> int:\n    \"\"\"\n    Return the nth decagonal number (n >= 1).\n    Decagonal numbers follow D(n) = 4n^2 - 3n.\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 4 * n * n - 3 * n\n\n# Examples\n# nth_decagonal(1) -> 1\n# nth_decagonal(2) -> 10\n# nth_decagonal(3) -> 27\n\nIf you prefer a 0-based index (where n=0 would correspond to the first decagonal number), you can use:\ndef nth_decagonal_zero_based(n: int) -> int:\n    k = n + 1\n    return 4 * k * k - 3 * k\n\nLet me know if you want this in another language."}
{"task_id": "Mbpp/271", "completion": "Here's a concise Python function that computes the sum of the fifth powers of the first n even natural numbers, i.e., sum_{i=1}^n (2i)^5.\n\nOption 1: using a closed-form formula (efficient, O(1))\n\n```python\ndef sum_first_n_even_fifth(n: int) -> int:\n    \"\"\"\n    Return sum_{i=1}^n (2i)^5.\n\n    Uses:\n    sum_{i=1}^n i^5 = n^2 (n+1)^2 (2n^2 + 2n - 1) / 12\n    Therefore sum_{i=1}^n (2i)^5 = 32 * sum_{i=1}^n i^5\n                                 = 8 * n^2 * (n+1)^2 * (2n^2 + 2n - 1) / 3\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    sum_i5 = n * n * (n + 1) * (n + 1) * (2 * n * n + 2 * n - 1) // 12\n    return 32 * sum_i5\n```\n\nOption 2: a simple loop (straightforward, O(n))\n\n```python\ndef sum_first_n_even_fifth_loop(n: int) -> int:\n    \"\"\"\n    Simple loop version to compute sum_{i=1}^n (2i)^5.\n    \"\"\"\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n\n    total = 0\n    for i in range(1, n + 1):\n        total += (2 * i) ** 5\n    return total\n```\n\nUsage example:\n- sum_first_n_even_fifth(3) computes (2^5) + (4^5) + (6^5).\n- sum_first_n_even_fifth_loop(3) does the same via a loop."}
{"task_id": "Mbpp/274", "completion": "Here's a concise Python function. It uses the identity that for n \u2265 1, the sum of even-index binomial coefficients equals 2^(n\u22121).\n\n```python\ndef sum_even_binomial_coefficients(n):\n    \"\"\"\n    Return sum of C(n, k) for even k (k = 0, 2, 4, ..., n).\n    For positive integer n, this sum equals 2**(n-1).\n    \"\"\"\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return 1 << (n - 1)  # equivalent to 2**(n-1)\n```\n\nExample:\n- sum_even_binomial_coefficients(5) -> 16\n- sum_even_binomial_coefficients(4) -> 8\n\nIf you want to verify by direct summation instead of using the identity, you can use:\nsum(math.comb(n, k) for k in range(0, n+1, 2))"}
{"task_id": "Mbpp/278", "completion": "Here\u2019s a Python function that returns the number of elements before the first occurrence of a given value in a tuple. If the value isn\u2019t in the tuple, it returns -1.\n\n```python\ndef count_before_element(t, value):\n    \"\"\"\n    Return the number of elements before the first occurrence of 'value' in tuple t.\n    If 'value' is not in t, return -1.\n    \"\"\"\n    try:\n        return t.index(value)\n    except ValueError:\n        return -1\n\n# Examples\nt = (3, 5, 7, 3, 9)\nprint(count_before_element(t, 7))  # Output: 2\nprint(count_before_element(t, 3))  # Output: 0 (first 3 is at index 0)\nprint(count_before_element(t, 10)) # Output: -1 (not found)\n```\n\nNotes:\n- The return value is the count of elements before the first occurrence (0-based index).\n- If you prefer 1-based counting (i.e., positions starting at 1), return t.index(value) + 1.\n- If you want the count before a later occurrence, you can modify the function to search for the nth occurrence."}
{"task_id": "Mbpp/284", "completion": "Here are simple implementations in a couple of common languages.\n\nPython:\n- Function:\n  def all_items_equal_to(lst, element):\n      \"\"\"\n      Return True if every item in lst equals element.\n      Empty list returns True (vacuous truth).\n      \"\"\"\n      return all(x == element for x in lst)\n\n- Example:\n  all_items_equal_to([1, 1, 1], 1)  # True\n  all_items_equal_to([1, 2, 1], 1)  # False\n  all_items_equal_to([], 5)          # True\n\nJavaScript:\n- Function:\n  function allItemsEqualTo(arr, element) {\n    return arr.every(x => x === element);\n  }\n\n- Example:\n  allItemsEqualTo([1, 1, 1], 1); // true\n  allItemsEqualTo([1, 2, 1], 1); // false\n  allItemsEqualTo([], 5);         // true\n\nNotes:\n- Using all (Python) or every (JS) yields True for an empty list/array (vacuous truth). If you want to treat an empty input as False, you can add an explicit length check, e.g., return arr.length > 0 and arr.every(...)."}
{"task_id": "Mbpp/282", "completion": "Here are simple implementations in a few popular languages. They compute result[i] = a[i] - b[i] and require the two inputs to have the same length. If you want a different behavior (e.g., padding shorter lists), tell me.\n\nPython (list input, same length)\ndef subtract_lists(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length\")\n    return [x - y for x, y in zip(a, b)]\n\nJavaScript (arrays)\nfunction subtractLists(a, b) {\n  if (a.length !== b.length) throw new Error(\"Arrays must have the same length\");\n  return a.map((val, idx) => val - b[idx]);\n}\n\nJava\npublic static int[] subtractLists(int[] a, int[] b) {\n    if (a.length != b.length) {\n        throw new IllegalArgumentException(\"Arrays must have the same length\");\n    }\n    int[] res = new int[a.length];\n    for (int i = 0; i < a.length; i++) {\n        res[i] = a[i] - b[i];\n    }\n    return res;\n}\n\nC++\n#include <vector>\n#include <stdexcept>\n\nstd::vector<int> subtractLists(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) throw std::invalid_argument(\"Sizes must match\");\n    std::vector<int> res(a.size());\n    for (size_t i = 0; i < a.size(); ++i) res[i] = a[i] - b[i];\n    return res;\n}\n\nOptional: if you want to allow lists of different lengths by padding with zeros (or another fill value), I can add a version for that. Which language do you prefer, and how should you want to handle length mismatches?"}
{"task_id": "Mbpp/281", "completion": "Here is a robust Python function that checks if all elements in a list are unique. It uses set for hashable items (fast) and gracefully falls back to an equality-based check for unhashable elements.\n\n```python\ndef are_elements_unique(lst):\n    \"\"\"Return True if all elements in lst are unique.\n    Works with hashable elements (fast) and also handles unhashable ones.\"\"\"\n    try:\n        return len(lst) == len(set(lst))\n    except TypeError:\n        # Fallback for unhashable elements (e.g., lists inside the list)\n        seen = []\n        for x in lst:\n            for s in seen:\n                if x == s:\n                    return False\n            seen.append(x)\n        return True\n```\n\nUsage examples:\n- are_elements_unique([1, 2, 3]) -> True\n- are_elements_unique([1, 2, 2]) -> False\n- are_elements_unique([1, [2], 3]) -> True\n\nNotes:\n- If all elements are hashable (typical case), the function runs in O(n) time on average.\n- If unhashable elements are present, it falls back to an O(n^2) equality-based check."}
{"task_id": "Mbpp/280", "completion": "Here are simple implementations in Python and JavaScript/TypeScript. Both return a tuple/array where the first element is a boolean indicating if the target is in the array, and the second is the index of the first occurrence (or -1 if not found).\n\nPython (returns a tuple)\ndef find_in_array(arr, target):\n    for idx, val in enumerate(arr):\n        if val == target:\n            return (True, idx)\n    return (False, -1)\n\n# Example:\n# find_in_array([1, 2, 3, 4], 3) -> (True, 2)\n# find_in_array([1, 2, 3], 5)    -> (False, -1)\n\nOptional Python using built-in index (slightly shorter, but uses exception handling)\ndef find_in_array_builtin(arr, target):\n    try:\n        idx = arr.index(target)\n        return (True, idx)\n    except ValueError:\n        return (False, -1)\n\nJavaScript / TypeScript (returns a tuple-like [boolean, number])\nfunction findInArray<T>(arr: T[], target: T): [boolean, number] {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) return [true, i];\n  }\n  return [false, -1];\n}\n\n// Example:\nconsole.log(findInArray([1, 2, 3, 2], 2)); // [true, 1]\n// If not found:\nconsole.log(findInArray([1, 2, 3], 4));    // [false, -1]\n\nNotes\n- If the array contains duplicates, these return the index of the first occurrence.\n- Time complexity: O(n) in the worst case. Space complexity: O(1) extra space (besides return value). If you know the array is sorted and want a faster approach, you could implement binary search and still return a [found, index]-style result."}
{"task_id": "Mbpp/283", "completion": "Here\u2019s a simple Python function that checks the property for an integer (ignoring the sign):\n\n- For every digit d that appears in the number, its frequency in the number must be <= d.\n\nCode:\n\ndef digit_frequency_leq(n: int) -> bool:\n    \"\"\"\n    Return True if for every digit d that appears in n, the frequency of d in n\n    is <= d. Ignores the sign of n.\n    \"\"\"\n    from collections import Counter\n\n    m = abs(n)\n    s = str(m)\n    freq = Counter(s)\n\n    for ch, f in freq.items():\n        d = int(ch)\n        if f > d:\n            return False\n    return True\n\n# Examples\nprint(digit_frequency_leq(1223))   # True (1->1, 2->2, 3->1)\nprint(digit_frequency_leq(112233)) # False (1 appears 2 times > 1)\nprint(digit_frequency_leq(0))       # False (0 appears once -> 1 > 0)\nprint(digit_frequency_leq(-221))    # True (2 appears 2 times, 1 appears 1 time)"}
{"task_id": "Mbpp/290", "completion": "Here\u2019s a Python function that returns all sublists that have the maximum length in a list of lists (preserves order, and handles ties):\n\n```python\nfrom typing import List, Any\n\ndef max_length_lists(lists: List[List[Any]]) -> List[List[Any]]:\n    \"\"\"\n    Given a list of lists, return all sublists with the maximum length.\n    If input is empty, return an empty list.\n    \"\"\"\n    if not lists:\n        return []\n    max_len = max(len(sub) for sub in lists)\n    return [sub for sub in lists if len(sub) == max_len]\n\n# Example\nlst = [[1, 2], [3], [4, 5], [], [6, 7, 8], [9, 10, 11]]\nprint(max_length_lists(lst))  # [[6, 7, 8], [9, 10, 11]]\n```\n\nNotes:\n- If there are multiple sublists tied for the maximum length, all are returned.\n- Time complexity: O(n) to find the max length plus O(n) to filter (total O(n)).\n- Space complexity: O(k) for the result, where k is the number of max-length sublists."}
{"task_id": "Mbpp/264", "completion": "Here are simple functions in Python and JavaScript to convert a human age to dog years. I include two common formulas you can choose from.\n\nOption 1: Classic (15 years for the first year, 9 for the second, 5 for each additional year)\nPython:\ndef dog_years(human_years, approach=\"classic\"):\n    if human_years < 0:\n        raise ValueError(\"human_years must be non-negative\")\n\n    if approach == \"classic\":\n        if human_years <= 1:\n            return 15 * human_years\n        elif human_years <= 2:\n            return 15 + 9 * (human_years - 1)\n        else:\n            return 24 + 5 * (human_years - 2)\n    elif approach == \"modern\":\n        # See Option 2 below\n        return dog_years(human_years, approach=\"modern\")\n    else:\n        raise ValueError(\"Unknown approach\")\n\n# Examples\nprint(dog_years(1))    # 15.0\nprint(dog_years(2))    # 24.0\nprint(dog_years(3))    # 29.0\n\nOption 2: Modern (simpler: first two years = 10.5 each, then 4 per year)\nPython:\ndef dog_years(human_years, approach=\"modern\"):\n    if human_years < 0:\n        raise ValueError(\"human_years must be non-negative\")\n\n    if approach == \"modern\":\n        if human_years <= 2:\n            return human_years * 10.5\n        else:\n            return 21 + 4 * (human_years - 2)\n    else:\n        raise ValueError(\"Unknown approach\")\n\n# Examples\nprint(dog_years(1))  # 10.5\nprint(dog_years(2))  # 21.0\nprint(dog_years(3))  # 25.0\n\nJavaScript (classic approach):\nfunction dogYears(humanYears, approach = \"classic\") {\n  if (humanYears < 0) {\n    throw new Error(\"humanYears must be non-negative\");\n  }\n\n  if (approach === \"classic\") {\n    if (humanYears <= 1) {\n      return 15 * humanYears;\n    } else if (humanYears <= 2) {\n      return 15 + 9 * (humanYears - 1);\n    } else {\n      return 24 + 5 * (humanYears - 2);\n    }\n  } else {\n    throw new Error(\"Unknown approach\");\n  }\n}\n\n// Examples\nconsole.log(dogYears(1)); // 15\nconsole.log(dogYears(2)); // 24\nconsole.log(dogYears(3)); // 29\n\nJavaScript (modern approach):\nfunction dogYearsModern(humanYears) {\n  if (humanYears < 0) {\n    throw new Error(\"humanYears must be non-negative\");\n  }\n  if (humanYears <= 2) {\n    return humanYears * 10.5;\n  } else {\n    return 21 + 4 * (humanYears - 2);\n  }\n}\n\n// Examples\nconsole.log(dogYearsModern(1)); // 10.5\nconsole.log(dogYearsModern(2)); // 21\nconsole.log(dogYearsModern(3)); // 25\n\nNotes:\n- There are different conventions for \u201cdog years.\u201d The classic formula (15, 9, then 5) is common in many contexts. The modern formula (first two years about 10.5 each, then 4 per year) is another popular approximation.\n- Both implementations handle fractional ages (e.g., 1.5 human years) by prorating the first two years where appropriate.\n- If you want a single function, you can pick one approach and remove the other branch; just be explicit about which rule you\u2019re using."}
{"task_id": "Mbpp/292", "completion": "Here\u2019s a simple function that returns the quotient rounded down (floor) to the nearest integer:\n\ndef floor_division(numerator, denominator):\n    if denominator == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    # Use Python's floor division //, then cast to int for a clean integer result\n    return int(numerator // denominator)\n\n# Examples\nprint(floor_division(7, 3))   # 2\nprint(floor_division(-7, 3))  # -3\nprint(floor_division(7, -3))  # -3\n\nNotes:\n- The // operator in Python performs floor division, which rounds down toward negative infinity.\n- The function raises a ZeroDivisionError if the denominator is zero."}
{"task_id": "Mbpp/296", "completion": "Here's a Python function that counts inversions in an array using a merge-sort based approach (O(n log n) time, O(n) extra space). It does not modify the original input.\n\n```python\ndef count_inversions(arr):\n    \"\"\"\n    Count inversions in arr using a merge sort approach.\n\n    An inversion is a pair (i, j) such that i < j and arr[i] > arr[j].\n\n    Returns:\n        int: the number of inversions.\n    \"\"\"\n    a = list(arr)  # work on a copy to avoid mutating input\n    n = len(a)\n    if n < 2:\n        return 0\n\n    temp = [0] * n\n\n    def merge_count(left, mid, right):\n        i = left\n        j = mid + 1\n        k = left\n        inv = 0\n\n        while i <= mid and j <= right:\n            if a[i] <= a[j]:\n                temp[k] = a[i]\n                i += 1\n            else:\n                temp[k] = a[j]\n                inv += (mid - i + 1)  # all remaining in left half form inversions with a[j]\n                j += 1\n            k += 1\n\n        while i <= mid:\n            temp[k] = a[i]\n            i += 1\n            k += 1\n\n        while j <= right:\n            temp[k] = a[j]\n            j += 1\n            k += 1\n\n        for idx in range(left, right + 1):\n            a[idx] = temp[idx]\n\n        return inv\n\n    def sort_count(left, right):\n        if left >= right:\n            return 0\n        mid = (left + right) // 2\n        inv = sort_count(left, mid)\n        inv += sort_count(mid + 1, right)\n        inv += merge_count(left, mid, right)\n        return inv\n\n    return sort_count(0, n - 1)\n\n# Example:\n# arr = [2, 4, 1, 3, 5]\n# print(count_inversions(arr))  # Output: 3\n```\n\nIf you\u2019d like, I can also provide a version that returns both the sorted array and the inversion count, or a Fenwick-tree based version for counting inversions with coordinate compression."}
{"task_id": "Mbpp/287", "completion": "Here's a concise Python function using the closed-form formula:\n\n```python\ndef sum_squares_of_first_n_even(n: int) -> int:\n    \"\"\"\n    Return the sum of squares of the first n even natural numbers: 2^2 + 4^2 + ... + (2n)^2.\n\n    Uses the formula: sum = (2 * n * (n + 1) * (2n + 1)) // 3\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    return (2 * n * (n + 1) * (2 * n + 1)) // 3\n```\n\nExample:\n- sum_squares_of_first_n_even(3) -> 56 (since 2^2 + 4^2 + 6^2 = 4 + 16 + 36 = 56)"}
{"task_id": "Mbpp/297", "completion": "Here are a few Python options to flatten a nested list (handles lists and tuples, and avoids flattening strings).\n\n1) Simple recursive generator (concise)\n- Flattens arbitrarily nested lists/tuples and yields items in left-to-right order.\n\n```python\ndef flatten(nested):\n    for item in nested:\n        if isinstance(item, (list, tuple)):\n            yield from flatten(item)\n        else:\n            yield item\n\n# helper to get a list\ndef flatten_to_list(nested):\n    return list(flatten(nested))\n\n# example\nnested = [1, [2, 3], [4, [5, 6]], 7]\nprint(flatten_to_list(nested))  # [1, 2, 3, 4, 5, 6, 7]\n```\n\n2) Iterative (non-recursive) version (avoids recursion depth issues)\n- Uses a stack to traverse and flatten.\n\n```python\ndef flatten_iter(nested):\n    stack = list(reversed(nested))\n    while stack:\n        item = stack.pop()\n        if isinstance(item, (list, tuple)):\n            stack.extend(reversed(item))\n        else:\n            yield item\n\ndef flatten_to_list_iter(nested):\n    return list(flatten_iter(nested))\n\n# example\nnested = [1, [2, 3], [4, [5, 6]], 7]\nprint(flatten_to_list_iter(nested))  # [1, 2, 3, 4, 5, 6, 7]\n```\n\nNotes:\n- Strings are not flattened because the code only recurses on lists or tuples.\n- If you also want to flatten other iterables, you can modify the isinstance check accordingly."}
{"task_id": "Mbpp/310", "completion": "Here's a simple Python function that converts a string to a tuple of its characters:\n\n```python\ndef string_to_char_tuple(s: str) -> tuple[str, ...]:\n    \"\"\"Return a tuple containing each character of the input string.\"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return tuple(s)\n```\n\nUsage:\n- string_to_char_tuple(\"hello\") -> ('h', 'e', 'l', 'l', 'o')\n\nIf you don\u2019t want the type-check, you can simplify to:\n\n```python\ndef string_to_char_tuple(s: str) -> tuple:\n    return tuple(s)\n```"}
{"task_id": "Mbpp/285", "completion": "Here are simple implementations. The idea is to look for the substrings \"abb\" or \"abbb\" anywhere in the string (i.e., an 'a' followed by 2 or 3 'b's).\n\nPython (regex)\n- Function:\ndef contains_a_followed_by_two_or_three_bs(s: str) -> bool:\n    import re\n    return bool(re.search(r\"ab{2,3}\", s))\n\n- Example:\nprint(contains_a_followed_by_two_or_three_bs(\"zabbbz\"))  # True\nprint(contains_a_followed_by_two_or_three_bs(\"zabbz\"))   # True\nprint(contains_a_followed_by_two_or_three_bs(\"zaba\"))    # False\n\nJavaScript\nfunction containsAThenTwoOrThreeBs(s) {\n  return /ab{2,3}/.test(s);\n}\n// examples\ncontainsAThenTwoOrThreeBs(\"zabbbz\"); // true\ncontainsAThenTwoOrThreeBs(\"zabbz\");  // true\ncontainsAThenTwoOrThreeBs(\"zaba\");   // false\n\nJava\npublic static boolean containsAThenTwoOrThreeBs(String s) {\n    return s.matches(\".*ab{2,3}.*\");\n}\n\nC#\nusing System.Text.RegularExpressions;\n\nbool ContainsAThenTwoOrThreeBs(string s)\n{\n    return Regex.IsMatch(s, \"ab{2,3}\");\n}\n\nNotes\n- The pattern ab{2,3} matches an 'a' followed by 2 or 3 'b' characters immediately after it.\n- If you want case-insensitive checks, adjust the patterns to account for case (e.g., use flags or convert the string to a consistent case)."}
{"task_id": "Mbpp/300", "completion": "Idea:\nLet the first half have k ones and the second half also have k ones. For each k (0 \u2264 k \u2264 n) there are C(n, k) choices for the first half and C(n, k) choices for the second half, giving C(n, k)^2 sequences. Summing over k gives sum_{k=0}^n C(n, k)^2 = C(2n, n). So the count is the central binomial coefficient (2n choose n).\n\nPython function (uses Python's built-in comb):\ndef count_sequences(n):\n    from math import comb\n    return comb(2 * n, n)\n\n# Example\n# count_sequences(3) -> 20 (since C(6,3) = 20)\n\nIf math.comb isn\u2019t available, you can implement a simple binomial function:\ndef count_sequences(n):\n    def binom(N, K):\n        if K < 0 or K > N:\n            return 0\n        K = min(K, N - K)\n        res = 1\n        for i in range(1, K + 1):\n            res = res * (N - K + i) // i\n        return res\n    return binom(2 * n, n)\n\nThis runs in O(n) time and uses O(1) extra space (besides integer arithmetic)."}
{"task_id": "Mbpp/305", "completion": "Here's a Python function that returns the first two words starting with 'p' (case-insensitive) from a list. It raises a ValueError if fewer than two such words exist.\n\n```python\ndef two_words_starting_with_p(words):\n    \"\"\"\n    Return the first two words starting with 'p' (case-insensitive) from the given list.\n    Raises ValueError if fewer than two such words are found.\n    \"\"\"\n    found = []\n    for w in words:\n        if isinstance(w, str) and w.lower().startswith('p'):\n            found.append(w)\n            if len(found) == 2:\n                return found[0], found[1]\n    raise ValueError(\"Fewer than two words start with 'p'.\")\n\n# Example usage:\nwords = [\"apple\", \"pear\", \"pine\", \"peach\", \"plum\"]\nprint(two_words_starting_with_p(words))  # ('pear', 'pine')\n```\n\nNotes:\n- If you want to allow fewer-than-two results without raising, you can return None or an empty tuple when you can\u2019t find two words.\n- This checks strings case-insensitively (e.g., 'Pear' or 'PINE' also match). If you want a strict lowercase check, remove the .lower() call."}
{"task_id": "Mbpp/299", "completion": "Here are a few common interpretations and corresponding Python functions. If you had a different meaning in mind, tell me and I can adjust.\n\n1) Maximum sum across the tuples (i.e., the largest sum of elements in any tuple)\n- This returns the maximum of sum(t) for each tuple t.\n\ndef max_tuple_sum(tuples):\n    if not tuples:\n        raise ValueError(\"tuples must not be empty\")\n    return max(sum(t) for t in tuples)\n\n# Example\n# max_tuple_sum([(1, 2, 3), (4, 5), (0, -1)]) -> 9 (from (1,2,3) -> 6, (4,5) -> 9, (0,-1) -> -1)\n\n2) Maximum element across all elements of all tuples\n- This flattens all tuples and returns the largest element.\n\ndef max_element_across_all(tuples):\n    flat = [x for t in tuples for x in t]\n    if not flat:\n        raise ValueError(\"no elements to compare\")\n    return max(flat)\n\n# Example\n# max_element_across_all([(1, 2), (3, 4)]) -> 4\n\n3) Tuple with the maximum aggregate according to a custom function\n- agg is a function like sum, max, or any other numeric aggregation over a tuple.\n- This returns the tuple that achieves the highest agg(t).\n\ndef max_tuple_by_aggregate(tuples, agg):\n    if not tuples:\n        raise ValueError(\"tuples must not be empty\")\n    return max(tuples, key=agg)\n\n# Example\n# max_tuple_by_aggregate([(1, 2), (3, 4), (0, 9)], sum) -> (0, 9)\n# max_tuple_by_aggregate([(1, 2), (3, 4), (0, 9)], max) -> (3, 4)\n\n4) Maximum aggregate value across all tuples with a custom function\n- Returns the highest value of agg(t) across tuples.\n\ndef max_aggregate_value(tuples, agg):\n    if not tuples:\n        raise ValueError(\"tuples must not be empty\")\n    return max(agg(t) for t in tuples)\n\n# Example\n# max_aggregate_value([(1, 2), (3, 4), (0, 9)], sum) -> 9\n# max_aggregate_value([(1, 2), (3, 4), (0, 9)], max) -> 9\n\nIf you share a sample input and specify what \u201cmaximum aggregate\u201d means in your context (and the language you\u2019re using), I can tailor the exact function."}
{"task_id": "Mbpp/309", "completion": "Here\u2019s a simple Python function to find the maximum of two numbers, with basic type checking:\n\ndef max_of_two(a, b):\n    \"\"\"Return the maximum of two numbers a and b.\"\"\"\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"Both a and b must be numeric (int or float).\")\n    return a if a >= b else b\n\n# Examples\nprint(max_of_two(3, 5))      # 5\nprint(max_of_two(-2, -7))     # -2\n\nNote: If you just want a concise version without explicit checks, you can use the built-in max:\n# def max_of_two(a, b):\n#     return max(a, b)"}
{"task_id": "Mbpp/260", "completion": "Newman\u2013Shanks\u2013Williams (NSW) primes are primes that appear in the NSW sequence defined by W_0 = 1, W_1 = 1, and W_n = 2*W_{n-1} + W_{n-2} for n >= 2. The NSW numbers are W_n = ((1+\u221a2)^n + (1-\u221a2)^n)/2, and the NSW primes are the prime values among {W_n}. The nth NSW prime is the nth prime value in that sequence (usually starting with W_2 = 3 as the first NSW prime).\n\nHere is a Python function to compute the nth NSW prime. It generates NSW numbers by the recurrence and tests primality with a probabilistic Miller\u2013Rabin tester (you can increase rounds for more certainty).\n\n- Note: This is a practical, general-purpose implementation. NSW primes grow quickly, so for large n you\u2019ll need substantial computation time.\n\nPython code:\n\n```python\nimport random\n\ndef is_probable_prime(n, rounds=12):\n    if n < 2:\n        return False\n    # Small trial division to quickly weed out composites\n    small_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    for p in small_primes:\n        if n % p == 0:\n            return n == p\n\n    # Write n-1 as d * 2^s with d odd\n    d = n - 1\n    s = 0\n    while d % 2 == 0:\n        d //= 2\n        s += 1\n\n    for _ in range(rounds):\n        a = random.randrange(2, max(3, n - 2))\n        x = pow(a, d, n)\n        if x == 1 or x == n - 1:\n            continue\n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                break\n        else:\n            return False\n    return True\n\ndef NSW_prime(nth, rounds=12):\n    \"\"\"\n    Return the nth Newman\u2013Shanks\u2013Williams prime number (1-indexed).\n    The first NSW prime is 3 (W_2).\n    \"\"\"\n    if nth < 1:\n        raise ValueError(\"nth must be >= 1\")\n\n    a0, a1 = 1, 1  # W_0, W_1\n    count = 0\n    k = 2\n    while True:\n        ak = 2 * a1 + a0  # W_k\n        if is_probable_prime(ak, rounds=rounds):\n            count += 1\n            if count == nth:\n                return ak\n        a0, a1 = a1, ak\n        k += 1\n\n# Example usage:\n# NSW_prime(1) -> 3\n# NSW_prime(2) -> 7\n# NSW_prime(3) -> 17\n# NSW_prime(4) -> 41\n# NSW_prime(5) -> 239\n# NSW_prime(6) -> 577\n```\n\nIf you want a deterministic primality test for smaller numbers, you can replace the is_probable_prime function with a deterministic Miller\u2013Rabin variant (using fixed bases) for the range you care about."}
{"task_id": "Mbpp/388", "completion": "Here's a concise Python function that returns the largest power of two less than or equal to n. It handles n >= 1 efficiently in O(1) time.\n\ndef highest_power_of_two_leq(n):\n    \"\"\"\n    Return the greatest power of two (2**k) such that 2**k <= n.\n    If n < 1, returns 0.\n    Works for integers; non-integer inputs are floored to int.\n    \"\"\"\n    if n < 1:\n        return 0\n    n = int(n)\n    return 1 << (n.bit_length() - 1)\n\n# Examples\n# highest_power_of_two_leq(1) -> 1\n# highest_power_of_two_leq(2) -> 2\n# highest_power_of_two_leq(3) -> 2\n# highest_power_of_two_leq(0) -> 0\n# highest_power_of_two_leq(10) -> 8"}
{"task_id": "Mbpp/293", "completion": "Here are two clean Python functions for the common cases of finding the third side of a right triangle.\n\n- If you know the two legs, the third side is the hypotenuse: c = sqrt(a^2 + b^2)\n- If you know the hypotenuse and one leg, the other leg is: other = sqrt(hyp^2 - leg^2)\n\nCode:\n\n```python\nimport math\n\ndef hypotenuse_from_legs(a, b):\n    \"\"\"\n    Given the two legs a and b, return the hypotenuse.\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Sides must be positive.\")\n    return math.hypot(a, b)  # sqrt(a*a + b*b)\n\ndef missing_leg_from_hypotenuse(hypotenuse, leg):\n    \"\"\"\n    Given the hypotenuse and one leg, return the other leg.\n    \"\"\"\n    if hypotenuse <= 0 or leg <= 0:\n        raise ValueError(\"Sides must be positive.\")\n    if leg >= hypotenuse:\n        raise ValueError(\"Hypotenuse must be larger than the given leg.\")\n    return math.sqrt(hypotenuse**2 - leg**2)\n```\n\nUsage examples:\n\n```python\n# Two legs -> hypotenuse\nc = hypotenuse_from_legs(3, 4)   # 5.0\n\n# Hypotenuse and one leg -> the other leg\nb = missing_leg_from_hypotenuse(5, 3)  # 4.0\n```\n\nIf you want a single function that handles both cases, you can wrap them with a simple mode flag:\n\n```python\ndef third_side(x, y, mode='legs'):\n    \"\"\"\n    mode:\n      'legs' -> x and y are the two legs, return the hypotenuse\n      'hyp_and_leg' -> x is the hypotenuse, y is a leg, return the other leg\n    \"\"\"\n    if mode == 'legs':\n        return hypotenuse_from_legs(x, y)\n    elif mode == 'hyp_and_leg':\n        return missing_leg_from_hypotenuse(x, y)\n    else:\n        raise ValueError(\"mode must be 'legs' or 'hyp_and_leg'\")\n\n# Examples\nthird_side(3, 4, mode='legs')        # 5.0\nthird_side(5, 3, mode='hyp_and_leg') # 4.0\n```\n\nTell me your preferred language (JavaScript, Java, etc.) if you\u2019d like versions in another language."}
{"task_id": "Mbpp/312", "completion": "Here\u2019s a simple Python function to compute the volume of a cone (V = 1/3 \u00b7 \u03c0 \u00b7 r^2 \u00b7 h). It includes basic input validation and an optional way to use a custom value for \u03c0.\n\nCode (Python):\nimport math\n\ndef cone_volume(radius, height, pi=None):\n    if radius < 0 or height < 0:\n        raise ValueError(\"radius and height must be non-negative\")\n    pi = pi if pi is not None else math.pi\n    return pi * (radius ** 2) * height / 3.0\n\n# Optional: allow using diameter instead of radius\ndef cone_volume_from_diameter(diameter, height, pi=None):\n    return cone_volume(diameter / 2.0, height, pi=pi)\n\nUsage:\nprint(cone_volume(3, 5))  # ~47.1239\nprint(cone_volume_from_diameter(6, 5))  # ~47.1239\n\nIf you\u2019d like this in another language (JavaScript, Java, C++, etc.), tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/294", "completion": "Here's a Python function that finds the maximum value in a heterogeneous list (numbers and other types). It prioritizes numeric values when present; if no numeric items exist, it uses the lexicographic order of their string representations.\n\n- Approach: assign a key to each item:\n  - numeric items get a key (1, numeric_value)\n  - non-numeric items get a key (0, str(item))\n  - max() will prefer numeric items and then pick the largest numeric value; if only non-numeric items exist, it uses lexicographic string order.\n\nCode:\n\ndef max_heterogeneous(lst):\n    \"\"\"\n    Return the maximum element from a heterogeneous list.\n    - If numeric elements exist (ints/floats/bools or numeric strings), the largest numeric value is returned.\n    - If no numeric elements exist, returns the lexicographically greatest string (via str(item)).\n    \"\"\"\n    def key(x):\n        # Treat numeric types and numeric strings as numeric\n        if isinstance(x, bool) or isinstance(x, (int, float)):\n            return (1, float(x))\n        if isinstance(x, str):\n            try:\n                return (1, float(x))\n            except ValueError:\n                pass\n        # Fallback: non-numeric, compare by string representation\n        return (0, str(x))\n\n    max_item = None\n    max_k = None\n    for item in lst:\n        k = key(item)\n        if max_k is None or k > max_k:\n            max_k, max_item = k, item\n    return max_item\n\n# Examples\nprint(max_heterogeneous([3, \"a\", 2.5, \"20\", True, \"hello\"]))  # 3 (largest numeric)\nprint(max_heterogeneous([\"apple\", \"banana\", \"cherry\"]))        # \"cherry\" (lexicographically greatest)\nprint(max_heterogeneous([None, \"10\", \"2\", 1.5]))              # 1.5 (largest numeric)\nprint(max_heterogeneous([None, \"apple\", 42]))                 # 42\n\nNotes and variations:\n- If you want to ignore non-numeric items entirely, drop the non-numeric path and only consider numeric items.\n- If you want to handle a specific language other than Python, tell me which language and I\u2019ll tailor the function accordingly."}
{"task_id": "Mbpp/405", "completion": "Here are two simple Python options.\n\n1) Simple membership check (most common)\n- Uses the in operator directly.\n- Assumes a flat tuple (no nested tuples).\n\ndef contains_in_tuple(tup, element):\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple\")\n    return element in tup\n\n# Examples\nt = (1, 2, 3, 'apple')\nprint(contains_in_tuple(t, 'apple'))  # True\nprint(contains_in_tuple(t, 4))        # False\n\n2) If you want to search inside nested tuples as well\n- Recursively checks inside any nested tuples.\n\ndef contains_in_tuple_recursive(tup, element):\n    if not isinstance(tup, tuple):\n        raise TypeError(\"tup must be a tuple')\n    for item in tup:\n        if item == element:\n            return True\n        if isinstance(item, tuple):\n            if contains_in_tuple_recursive(item, element):\n                return True\n    return False\n\n# Example\nnested = (1, (2, 3), (4, (5, 6)), 7)\nprint(contains_in_tuple_recursive(nested, 6))  # True\nprint(contains_in_tuple_recursive(nested, 'apple'))  # False\n\nNote: In Python, the in operator already does a membership test:\nelement in tup\nSo the first function is essentially a wrapper around that."}
{"task_id": "Mbpp/404", "completion": "Here are two simple options.\n\nOption 1: explicit comparison\ndef min_of_two(a, b):\n    \"\"\"\n    Return the smaller of a and b.\n    Assumes a and b are numeric types (or otherwise comparable).\n    \"\"\"\n    return a if a <= b else b\n\nOption 2: using built-in min\ndef min_of_two_builtin(a, b):\n    return min(a, b)\n\nUsage examples:\n# min_of_two(3, 7) -> 3\n# min_of_two_builtin(-5, -2) -> -5"}
{"task_id": "Mbpp/389", "completion": "Here\u2019s a simple Python function to compute the nth Lucas number.\n\n- Lucas numbers: L0 = 2, L1 = 1, and L_n = L_{n-1} + L_{n-2} for n >= 2.\n\nPython (iterative, O(n) time, O(1) space):\n\ndef lucas(n):\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n == 0:\n        return 2\n    if n == 1:\n        return 1\n    a, b = 2, 1  # L0, L1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n\nUsage:\n- lucas(0) -> 2\n- lucas(5) -> 11\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(1)\n\nIf you need to handle very large n more efficiently, you can use a fast doubling method (O(log n)) or matrix exponentiation. Let me know if you\u2019d like a version with that approach."}
{"task_id": "Mbpp/394", "completion": "Here\u2019s a Python function to check if a given tuple contains no duplicates.\n\n```python\ndef has_no_duplicates(tup: tuple) -> bool:\n    \"\"\"\n    Return True if the input tuple contains no duplicate elements.\n    Elements are compared by equality. Works with hashable elements;\n    if unhashable elements are present, falls back to an O(n^2) check.\n    \"\"\"\n    try:\n        return len(set(tup)) == len(tup)\n    except TypeError:\n        # Fallback for unhashable elements (e.g., lists inside the tuple)\n        seen = []\n        for item in tup:\n            if item in seen:\n                return False\n            seen.append(item)\n        return True\n```\n\nUsage:\n- has_no_duplicates((1, 2, 3)) -> True\n- has_no_duplicates((1, 2, 2, 3)) -> False\n\nNotes:\n- Works best when the tuple contains hashable items (like numbers, strings, tuples of hashables).\n- If the tuple contains unhashable elements, it falls back to a slower O(n^2) check using equality."}
{"task_id": "Mbpp/395", "completion": "Here's a concise Python function that finds the first non-repeated character in a string. It uses a two-pass approach: first count frequencies, then find the first character with count 1.\n\n```python\nfrom typing import Optional\n\ndef first_non_repeated_char(s: Optional[str], case_sensitive: bool = True) -> Optional[str]:\n    \"\"\"\n    Return the first non-repeated character in s.\n    - If case_sensitive is False, characters are treated case-insensitively\n      for counting, but the original character (with its case) is returned.\n    - Returns None if there is no non-repeated character or if s is None/empty.\n    \"\"\"\n    if s is None or len(s) == 0:\n        return None\n\n    key_s = s if case_sensitive else s.lower()\n\n    # Count occurrences of each character (in the chosen case form)\n    counts = {}\n    for ch in key_s:\n        counts[ch] = counts.get(ch, 0) + 1\n\n    # Find the first character with count 1\n    for i in range(len(s)):\n        if counts[key_s[i]] == 1:\n            return s[i]\n\n    return None\n\n# Examples:\nif __name__ == \"__main__\":\n    print(first_non_repeated_char(\"loveleetcode\"))  # Output: 'v'\n    print(first_non_repeated_char(\"aabbcc\"))        # Output: None\n    print(first_non_repeated_char(\"aAa\", case_sensitive=True))  # Output: 'A'\n    print(first_non_repeated_char(\"aAa\", case_sensitive=False)) # Output: None\n```\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(k) where k is the number of distinct characters\n- Returns None when no non-repeated character exists."}
{"task_id": "Mbpp/397", "completion": "Here\u2019s a simple approach and implementation in Python. The median of three numbers a, b, c can be computed as a + b + c minus the max and the min.\n\nPython:\n\ndef median_of_three(a, b, c):\n    \"\"\"\n    Return the median of three numbers.\n    \"\"\"\n    return a + b + c - max(a, b, c) - min(a, b, c)\n\n# Examples\nprint(median_of_three(1, 2, 3))  # 2\nprint(median_of_three(9, 1, 5))  # 5\nprint(median_of_three(4, 4, 7))  # 4\n\nIf you\u2019d like this in another language, here are quick equivalents:\n\nJavaScript:\n\nfunction medianOfThree(a, b, c) {\n  return a + b + c - Math.max(a, Math.max(b, c)) - Math.min(a, Math.min(b, c));\n}\n\nJava (long to avoid overflow for large ints):\n\nstatic long medianOfThree(long a, long b, long c) {\n    long max = Math.max(a, Math.max(b, c));\n    long min = Math.min(a, Math.min(b, c));\n    return a + b + c - max - min;\n}\n\nGo (int version):\n\nfunc medianOfThree(a, b, c int) int {\n    max := maxInt(a, maxInt(b, c))\n    min := minInt(a, minInt(b, c))\n    return a + b + c - max - min\n}\n\nIf you tell me your target language, I\u2019ll tailor a clean version for it."}
{"task_id": "Mbpp/398", "completion": "Here are simple Python implementations. They compute, for each number in the list, the sum of its digits. Negative numbers are treated by using their absolute value.\n\nVariant 1: concise (uses string conversion)\n```\ndef sum_digits_per_list(nums):\n    # nums: iterable of integers\n    return [sum(int(d) for d in str(abs(int(n)))) for n in nums]\n\n# Example\nprint(sum_digits_per_list([123, -456, 0, 1001]))  # [6, 15, 0, 2]\n```\n\nVariant 2: using numeric arithmetic (no string conversion)\n```\ndef sum_digits(n):\n    n = abs(int(n))\n    total = 0\n    while n:\n        total += n % 10\n        n //= 10\n    return total  # for n == 0, returns 0\n\ndef sum_digits_per_list(nums):\n    return [sum_digits(n) for n in nums]\n\n# Example\nprint(sum_digits_per_list([123, -456, 0, 1001]))  # [6, 15, 0, 2]\n```\n\nIf you\u2019d like this in another language (JavaScript, Java, etc.), tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/301", "completion": "Here's a Python function that computes the maximum nesting depth of dictionaries inside a given dictionary. By convention, the depth of an empty dictionary is 1; non-dictionary values don\u2019t contribute to depth.\n\n```python\ndef dict_depth(d):\n    \"\"\"\n    Return the depth (max nesting level) of dictionaries inside the given dictionary.\n    - Depth of an empty dictionary is 1.\n    - Non-dictionary values don't contribute to depth directly.\n    - Dictionaries inside lists/tuples/sets are also accounted for.\n    \"\"\"\n    if not isinstance(d, dict):\n        raise TypeError(\"Input must be a dictionary\")\n\n    def max_depth(obj):\n        if isinstance(obj, dict):\n            if not obj:\n                return 1\n            return 1 + max((max_depth(v) for v in obj.values()), default=0)\n        elif isinstance(obj, (list, tuple, set)):\n            if not obj:\n                return 0\n            return max((max_depth(item) for item in obj))\n        else:\n            return 0\n\n    return max_depth(d)\n```\n\nUsage examples:\n- dict_depth({\"a\": 1}) -> 1\n- dict_depth({\"a\": {\"b\": 2}}) -> 2\n- dict_depth({\"a\": [ {\"b\": {\"c\": 3}} ]}) -> 3\n\nIf you\u2019d like a version that handles only dictionaries (and ignores lists/tuples/sets), or a version that uses an iterative approach, I can adapt it."}
{"task_id": "Mbpp/406", "completion": "Here\u2019s a simple Python function that returns True if the given integer has odd parity (i.e., is odd), and False otherwise.\n\n```python\ndef is_odd(n: int) -> bool:\n    \"\"\"\n    Return True if n is odd, False if n is even.\n    n must be an integer.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return (n & 1) == 1  # works for negative numbers as well\n```\n\nExamples:\n- is_odd(5) -> True\n- is_odd(4) -> False\n- is_odd(-3) -> True"}
{"task_id": "Mbpp/286", "completion": "Here's a concise approach and a Python implementation.\n\nIdea:\n- Let A be the original array, and k the number of times it's repeated.\n- If k = 1, the answer is the standard maximum subarray sum (Kadane\u2019s algorithm) on A.\n- If k >= 2, compute Kadane on A concatenated with A (A + A). This covers subarrays entirely inside one copy or spanning the boundary of two copies.\n- If the total sum S = sum(A) > 0 and k > 2, you can add full copies in the middle. The best cross-boundary sum is:\n  cross = max_suffix(A) + max_prefix(A) + S * (k - 2)\n  where max_suffix(A) is the maximum sum of a suffix of A, and max_prefix(A) is the maximum sum of a prefix of A.\n- The final answer is:\n  - If k = 1: Kadane(A)\n  - Else: max(Kadane(A+A), cross) if S > 0 and k > 2; otherwise Kadane(A+A)\n\nPython implementation:\n\n```python\ndef max_subarray_sum_k_repeats(arr, k):\n    \"\"\"\n    Return the largest sum of a contiguous subarray in the array formed by\n    repeating 'arr' k times.\n    \"\"\"\n    if not arr or k <= 0:\n        return 0\n\n    def kadane(a):\n        max_ending = a[0]\n        max_so_far = a[0]\n        for x in a[1:]:\n            max_ending = max(x, max_ending + x)\n            max_so_far = max(max_so_far, max_ending)\n        return max_so_far\n\n    n = len(arr)\n\n    if k == 1:\n        return kadane(arr)\n\n    # Kadane on two copies to cover subarrays within or crossing one boundary\n    best_two = kadane(arr + arr)\n\n    total = sum(arr)\n\n    # max prefix sum\n    pref = 0\n    max_pref = -10**18\n    for x in arr:\n        pref += x\n        if pref > max_pref:\n            max_pref = pref\n\n    # max suffix sum\n    suff = 0\n    max_suff = -10**18\n    for x in reversed(arr):\n        suff += x\n        if suff > max_suff:\n            max_suff = suff\n\n    if total > 0 and k > 2:\n        cross = max_suff + max_pref + total * (k - 2)\n        return max(best_two, cross)\n    else:\n        return best_two\n```\n\nUsage example:\n\n```python\narr = [1, -2, 3]\nfor k in range(1, 6):\n    print(f\"k={k} -> {max_subarray_sum_k_repeats(arr, k)}\")\n```\n\nThis will correctly handle all cases, including large k and negative numbers."}
{"task_id": "Mbpp/419", "completion": "Here's a Python function that rounds each number in a list, sums the rounded values, multiplies by the list length, prints the result, and returns it.\n\n```python\ndef round_sum_times_len(nums):\n    \"\"\"\n    Rounds each number in nums, sums the rounded numbers,\n    multiplies by the length of nums, prints and returns the result.\n    Note: Python's round uses bankers' rounding for halves (rounds to even).\n    \"\"\"\n    if not nums:\n        print(0)\n        return 0\n\n    rounded = [round(n) for n in nums]\n    total = sum(rounded)\n    result = total * len(rounded)\n    print(result)\n    return result\n\n# Example usage:\nnumbers = [1.2, 2.5, -3.1, 4.0]\nround_sum_times_len(numbers)  # prints and returns the computed value\n```\n\nIf you want a different rounding rule (e.g., always round halves up), I can adapt the function accordingly. Also happy to provide a JavaScript version if needed."}
{"task_id": "Mbpp/392", "completion": "Here's a Python approach that computes f(n) = max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n), using integer division. The base is f(n) = n for small n (we stop recursing at n < 2).\n\nRecursive with memoization (easy to read):\n\ndef max_sum(n, memo=None):\n    if memo is None:\n        memo = {}\n    if n < 2:\n        return n\n    if n in memo:\n        return memo[n]\n    s = max_sum(n // 2, memo) + max_sum(n // 3, memo) + max_sum(n // 4, memo) + max_sum(n // 5, memo)\n    ans = n if n > s else s\n    memo[n] = ans\n    return ans\n\nUsage:\nprint(max_sum(10))  # 12\nprint(max_sum(50))\n\nIterative dynamic programming (no recursion, good for small to moderate n):\n\ndef max_sum_dp(n):\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        s = dp[i // 2] + dp[i // 3] + dp[i // 4] + dp[i // 5]\n        dp[i] = i if i > s else s\n    return dp[n]\n\nUsage:\nprint(max_sum_dp(10))  # 12\nprint(max_sum_dp(50))\n\nNotes:\n- Use integer division (floor) for n/2, n/3, n/4, n/5. In Python that\u2019s //.\n- The recursive version with memoization is generally better for large n, since it only explores the necessary states.\n- Time complexity is roughly O(number of distinct n values visited) with memoization; each computed once and does O(1) extra work. Space complexity is O(number of states stored). The DP version uses O(n) space for the dp array."}
{"task_id": "Mbpp/420", "completion": "Here is an efficient Python function using the closed-form formula.\n\nExplanation:\nThe first n even numbers are 2, 4, ..., 2n. Their cubes sum to:\nsum_{k=1..n} (2k)^3 = 8 * sum_{k=1..n} k^3 = 8 * [n(n+1)/2]^2 = 2 * n^2 * (n+1)^2\n\nCode:\n\ndef sum_cube_first_n_even(n: int) -> int:\n    \"\"\"\n    Return the sum of cubes of the first n even natural numbers:\n    (2)^3 + (4)^3 + ... + (2n)^3\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    return 2 * n * n * (n + 1) * (n + 1)\n\n# Example\nprint(sum_cube_first_n_even(3))  # 288 (since 2^3 + 4^3 + 6^3 = 8 + 64 + 216 = 288)"}
{"task_id": "Mbpp/412", "completion": "Here\u2019s a simple function that returns a new list containing only the even numbers from the input list.\n\ndef remove_odds(nums):\n    \"\"\"Return a new list with all even numbers from nums.\"\"\"\n    return [n for n in nums if n % 2 == 0]\n\n# Example\nlst = [1, 2, 3, 4, 5]\nprint(remove_odds(lst))  # [2, 4]\n\nIf you want to modify the list in place, you can reassign to a slice:\n\ndef remove_odds_inplace(nums):\n    \"\"\"Remove odd numbers from nums in place.\"\"\"\n    nums[:] = [n for n in nums if n % 2 == 0]\n\n# Example\nlst2 = [1, 2, 3, 4, 5]\nremove_odds_inplace(lst2)\nprint(lst2)  # [2, 4]\n\nNotes:\n- This treats odd numbers as those with n % 2 != 0. It works for negative numbers too (e.g., -3 is odd).\n- If the list may contain non-integers, you might want to add type checks or convert to int first."}
{"task_id": "Mbpp/413", "completion": "Two common interpretations. I\u2019ll show Python implementations for both:\n\n1) Extract the nth element from each tuple in a list (column extraction)\n- n is a 0-based index (0 means the first element of each tuple)\n\nCode:\ndef extract_nth_from_tuples(tuples_list, n):\n    \"\"\"\n    Return a list containing the nth element of each tuple in tuples_list.\n    Raises IndexError if any tuple is too short.\n    \"\"\"\n    return [t[n] for t in tuples_list]\n\nExample:\nlst = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nprint(extract_nth_from_tuples(lst, 1))  # [2, 5, 8]\n\nIf you want to guard against non-tuples or short tuples:\ndef extract_nth_from_tuples_safe(tuples_list, n):\n    result = []\n    for t in tuples_list:\n        if not isinstance(t, (tuple, list)):\n            raise TypeError(\"All items must be tuples or lists\")\n        if n < 0 or n >= len(t):\n            raise IndexError(f\"Index {n} out of range for tuple {t}\")\n        result.append(t[n])\n    return result\n\n2) Extract the nth tuple from the list\n- n is a 0-based index (0 means the first tuple)\n\nCode:\ndef nth_tuple(tuples_list, n):\n    \"\"\"\n    Return the nth tuple from the list (0-based index).\n    \"\"\"\n    return tuples_list[n]\n\nExample:\nlst = [(1, 2), (3, 4), (5, 6)]\nprint(nth_tuple(lst, 2))  # (5, 6)\n\nNotes:\n- If you prefer 1-based indexing, pass n-1 to the 0-based functions, or adjust accordingly.\n- If you want a single function that can do either, you could add a parameter to choose the mode. For example:\ndef extract(tuples_or_list, n, mode='each'):  # mode: 'each' or 'list'\n    if mode == 'each':\n        return [t[n] for t in tuples_or_list]\n    elif mode == 'list':\n        return tuples_or_list[n]\n    else:\n        raise ValueError(\"mode must be 'each' or 'list'\")\n\nWould you like this in another language (e.g., JavaScript, Java) or with different indexing behavior?"}
{"task_id": "Mbpp/421", "completion": "Here's a simple Python function to concatenate each element of a tuple with a given delimiter. It converts all elements to strings.\n\n```python\ndef join_tuple_elements(t, delimiter):\n    \"\"\"\n    Concatenate each element of a tuple `t` with `delimiter`.\n    All elements are converted to strings.\n\n    Examples:\n        join_tuple_elements((1, 2, 3), '-') -> '1-2-3'\n        join_tuple_elements(('a', 'b'), ', ') -> 'a, b'\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"t must be a tuple\")\n    return str(delimiter).join(map(str, t))\n```\n\nNotes:\n- If the tuple is empty, it returns an empty string.\n- If you pass a non-string delimiter, it will be converted to a string automatically."}
{"task_id": "Mbpp/390", "completion": "Here\u2019s a Python function that applies a given format string to every element in a list. It supports both format specifications (like \".2f\" or \"04d\") and format templates using braces (like \"{:.2f}\" or \"Value: {}\").\n\nCode:\n\ndef apply_format_to_list(items, fmt):\n    \"\"\"\n    Apply a given format to all elements in 'items' and return a list of formatted strings.\n    fmt can be:\n      - a format specification (e.g., \".2f\", \"04d\")\n      - a format string template using str.format syntax (e.g., \"{:.2f}\", \"Value: {}\")\n    \"\"\"\n    if \"{\" in fmt and \"}\" in fmt:\n        # Use Python's str.format syntax\n        return [fmt.format(x) for x in items]\n    else:\n        # Use the format specification\n        return [format(x, fmt) for x in items]\n\nUsage examples:\n\n- apply_format_to_list([1.234, 2.5, 3], \".2f\")\n  -> [\"1.23\", \"2.50\", \"3.00\"]\n\n- apply_format_to_list([1, 2, 3], \"{:04d}\")\n  -> [\"0001\", \"0002\", \"0003\"]\n\n- apply_format_to_list([1.234, 2.345], \"Value: {:.2f}\")\n  -> [\"Value: 1.23\", \"Value: 2.35\"]\n\nIf you\u2019re using another language, I can provide a similar function in that language as well."}
{"task_id": "Mbpp/311", "completion": "Here\u2019s a Python function that sets the leftmost unset (0) bit of a non-negative integer. It works within a given width (bits you consider). If width is not provided, it uses the minimal width needed to represent n. If all bits in that width are 1, it extends by one bit on the left.\n\ndef set_leftmost_zero(n, width=None):\n    \"\"\"\n    Set the leftmost 0 bit of n within the given width.\n    If width is None, use the minimum width needed to represent n (at least 1 bit).\n    If all bits in the width are 1, extend by one bit to the left.\n    Returns the new integer.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    if width is None:\n        width = max(1, n.bit_length())  # at least 1 bit\n\n    mask = (1 << width) - 1\n    zero_mask = (~n) & mask  # bits that are 0 in n within the width\n\n    if zero_mask == 0:\n        # All bits in width are 1; extend by one bit to the left\n        return n | (1 << width)\n\n    # Position of the leftmost 0 bit within width\n    pos = zero_mask.bit_length() - 1\n    return n | (1 << pos)\n\nExamples:\n- set_leftmost_zero(11, 4) -> 15   (binary 1011 -> leftmost 0 is at bit 2; result 1111)\n- set_leftmost_zero(5, 4)  -> 13   (0101 -> leftmost 0 is at bit 3; result 1101)\n- set_leftmost_zero(7, 3)  -> 15   (111 -> all ones; extend to 1111)\n- set_leftmost_zero(0)     -> 1    (0 -> width 1; set bit 0) \n\nIf you want a fixed 32-bit width, you can call set_leftmost_zero(n, width=32)."}
{"task_id": "Mbpp/306", "completion": "Idea:\n- Let A be the array, and we want the maximum sum of an increasing subsequence that ends at index k and uses only indices from 0..i before k (i < k).\n- First compute for every t: dp[t] = maximum sum of an increasing subsequence that ends at t (using indices < t). This is the standard MSIS DP:\n  dp[t] = A[t] + max( dp[p] for p < t with A[p] < A[t], or 0 if none ).\n- Then any valid subsequence ending at k and using only 0..i before k can be formed by taking the best subsequence ending at some j where 0 <= j <= i and A[j] < A[k], and then appending A[k].\n  So the answer is:\n  best_prev = max( dp[j] for 0 <= j <= i with A[j] < A[k], or 0 if none )\n  answer = best_prev + A[k]\n\nPython implementation (concise and also returns path if desired):\n\ndef max_sum_incr_subseq_prefix_with_k(A, i, k, return_path=False):\n    n = len(A)\n    if not (0 <= i < k < n):\n        raise ValueError(\"Require 0 <= i < k < n\")\n\n    # dp[t]: max sum of an increasing subsequence ending at t\n    dp = [0] * n\n    prev = [-1] * n  # for optional path reconstruction\n    for t in range(n):\n        best = 0\n        best_p = -1\n        for p in range(t):\n            if A[p] < A[t] and dp[p] > best:\n                best = dp[p]\n                best_p = p\n        dp[t] = A[t] + best\n        prev[t] = best_p\n\n    # best subsequence ending before k (within 0..i) that can precede A[k]\n    best_prev = 0\n    best_j = -1\n    for j in range(0, i + 1):\n        if A[j] < A[k] and dp[j] > best_prev:\n            best_prev = dp[j]\n            best_j = j\n\n    total = best_prev + A[k]\n\n    if not return_path:\n        return total\n\n    # Reconstruct the path: indices of the subsequence (ending at k)\n    path = []\n    if best_j != -1:\n        t = best_j\n        while t != -1:\n            path.append(t)\n            t = prev[t]\n        path.reverse()\n    path.append(k)\n    return total, path\n\nNotes:\n- Time complexity: O(n^2) to compute dp, and O(i) to compute best_prev. Overall O(n^2) for a single query (i, k).\n- If you have multiple (i, k) queries on the same array, you can keep the dp[] precomputed (the first loop) and reuse it for each query, then only compute best_prev using i and k, which gives O(i) per query after O(n^2) preprocessing.\n- The path reconstruction (optional) returns the actual indices of the subsequence achieving the maximum sum under the constraint.\n\nExample:\n- A = [3, 1, 2, 4], i = 1, k = 3\n  dp = [3, 1, 3, 7]\n  best_prev over j in [0,1] with A[j] < A[3] (4) is max(dp[0]=3, dp[1]=1) = 3\n  total = 3 + A[3] = 7\n  The subsequence is [3, 4] with indices [0, 3]. If you request the path, it will return [0, 3]."}
{"task_id": "Mbpp/418", "completion": "Here are simple options to get the element with the maximum length (works for strings, lists, tuples, etc.) The first also raises an error on empty input.\n\nOption 1: simple (uses len as length)\ndef element_with_max_length(lst):\n    if not lst:\n        raise ValueError(\"empty list\")\n    return max(lst, key=len)\n\nOption 2: with a customizable length function\ndef element_with_max_length_by(lst, key=None):\n    if not lst:\n        raise ValueError(\"empty list\")\n    if key is None:\n        key = len\n    return max(lst, key=key)\n\nNotes:\n- If multiple elements share the maximum length, max(...) returns the first one encountered.\n- To avoid exceptions on empty input, you could return None instead of raising:\n  def element_with_max_length_or_none(lst):\n      if not lst:\n          return None\n      return max(lst, key=len)"}
{"task_id": "Mbpp/308", "completion": "Here's a robust Python implementation that finds the specified number k of largest products by choosing one element from each of two lists. It works for any integers (positive, negative, zeros) and uses a min-heap to keep only the top k results in memory.\n\n- Function top_k_largest_product_pairs(A, B, k): returns the top k pairs as (product, (a, b)).\n- Function top_k_largest_product_values(A, B, k): same idea but returns only the products.\n\nBoth handle edge cases (empty lists, k <= 0, k > |A|*|B|).\n\nCode:\n\n```python\nimport heapq\n\ndef top_k_largest_product_pairs(A, B, k):\n    \"\"\"\n    Return the k largest products of a*b where a in A and b in B.\n    Returns a list of tuples: (product, (a, b)).\n    The list is sorted in descending order by the product.\n    If k > len(A) * len(B), returns all possible pairs.\n    \"\"\"\n    if not A or not B or k <= 0:\n        return []\n\n    n, m = len(A), len(B)\n    total = n * m\n    k = min(k, total)\n\n    # Min-heap of (product, (a, b)) to keep the top k largest products\n    heap = []\n    for a in A:\n        for b in B:\n            prod = a * b\n            if len(heap) < k:\n                heapq.heappush(heap, (prod, (a, b)))\n            else:\n                if prod > heap[0][0]:\n                    heapq.heapreplace(heap, (prod, (a, b)))\n\n    # Sort results in descending order by product\n    heap.sort(key=lambda x: x[0], reverse=True)\n    return heap\n\n\ndef top_k_largest_product_values(A, B, k):\n    \"\"\"\n    Return the k largest products (values) from A x B.\n    Returns a list of products sorted in descending order.\n    If k > len(A) * len(B), returns all possible products.\n    \"\"\"\n    pairs = top_k_largest_product_pairs(A, B, k)\n    return [p for p, _ in pairs]\n\n\n# Example usage\nif __name__ == \"__main__\":\n    A = [1, -2, 3]\n    B = [4, -5, 6]\n    k = 5\n\n    print(\"Top k pairs (product, (a, b)):\")\n    for item in top_k_largest_product_pairs(A, B, k):\n        print(item)\n\n    print(\"\\nTop k products (values):\")\n    print(top_k_largest_product_values(A, B, k))\n```\n\nNotes:\n- Time complexity: O(n * m log k) to scan all pairings and maintain the top k in a heap, where n = len(A) and m = len(B).\n- Space complexity: O(k) for the heap.\n- If you know your lists are small or you want the simplest solution, you can implement a straightforward O(n*m log(n*m)) version by computing all products and sorting, but the heap-based approach above is more memory-efficient for large inputs."}
{"task_id": "Mbpp/424", "completion": "Here\u2019s a Python function that, given a tuple of strings, returns a new tuple containing the last character of each string (the \u201crear index element\u201d). Empty strings yield an empty string in the result. It validates input and raises an error if any element isn\u2019t a string.\n\n```python\ndef last_chars_of_strings(strings: tuple[str, ...]) -> tuple[str, ...]:\n    if not isinstance(strings, tuple):\n        raise TypeError(\"Input must be a tuple of strings\")\n    return tuple((s[-1] if s else \"\") for s in strings)\n```\n\nUsage examples:\n\n```python\ntu = (\"apple\", \"banana\", \"cat\", \"\")\nprint(last_chars_of_strings(tu))  # ('e', 'a', 't', '')\n\n# Non-string element will raise an error\n# last_chars_of_strings((\"apple\", 1, \"cat\"))  # TypeError\n```\n\nIf you prefer to allow lists as input, you can tweak the function to accept any iterable of strings."}
{"task_id": "Mbpp/409", "completion": "It depends on what you mean by \u201cpairs of tuples.\u201d Here are two common interpretations and ready-to-use Python solutions.\n\nOption 1: Given a list of 2-element tuples, find the minimum product from each pair\n- Example input: [(2, 3), (-1, 4), (0, 5)]\n- Compute a*b for each pair and return the smallest product (and the pair that produced it).\n\nPython code:\n```python\ndef min_product_from_pairs(pairs):\n    \"\"\"\n    Given an iterable of 2-element tuples, return (min_product, min_pair).\n    If multiple pairs have the same minimum product, returns one of them.\n    \"\"\"\n    min_prod = None\n    min_pair = None\n    for a, b in pairs:\n        prod = a * b\n        if min_prod is None or prod < min_prod:\n            min_prod = prod\n            min_pair = (a, b)\n    if min_prod is None:\n        raise ValueError(\"No pairs provided\")\n    return min_prod, min_pair\n\n# Example\npairs = [(2, 3), (-1, 4), (0, 5)]\nprint(min_product_from_pairs(pairs))  # Output: (-4, (-1, 4))\n```\n\nOption 2: Given a list of tuples (of arbitrary length), find the minimum product of the elements inside each tuple\n- For each tuple, multiply all its elements to get a product.\n- Return the smallest such product and the tuple that produced it.\n\nPython code:\n```python\nimport math\nfrom typing import Iterable, Tuple\n\ndef min_product_of_tuples(tuples: Iterable[Tuple[float, ...]]):\n    \"\"\"\n    Given an iterable of tuples (each tuple can have any length),\n    return (min_product, min_tuple) where min_product is the product of\n    elements in min_tuple.\n    \"\"\"\n    min_prod = None\n    min_tuple = None\n    for t in tuples:\n        if not t:\n            continue  # skip empty tuples\n        prod = 1\n        for x in t:\n            prod *= x\n        if min_prod is None or prod < min_prod:\n            min_prod = prod\n            min_tuple = t\n    if min_prod is None:\n        raise ValueError(\"No non-empty tuples provided\")\n    return min_prod, min_tuple\n\n# Example\ntuples = [(2, 3), (-1, 4, 2), (0, 5)]\nprint(min_product_of_tuples(tuples))  # Output: (-8, (-1, 4, 2))\n```\n\nIf you meant a different scenario (e.g., minimum product across all possible pairs of tuples, or the minimum product of two numbers drawn from a single list), tell me the exact input format and I\u2019ll tailor the solution."}
{"task_id": "Mbpp/422", "completion": "Here's a concise Python function using the known sum of cubes formula (sum of cubes from 1 to n is (n(n+1)/2)^2). The average is this sum divided by n, which simplifies to n*(n+1)^2/4.\n\ndef average_cube_first_n(n):\n    \"\"\"\n    Return the average of cubes of the first n natural numbers (1^3 + ... + n^3) / n.\n    Uses the formula: average = n * (n + 1) ** 2 / 4\n    \"\"\"\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    return (n * (n + 1) ** 2) / 4\n\n# Example:\n# print(average_cube_first_n(5))  # 45.0"}
{"task_id": "Mbpp/410", "completion": "Here\u2019s a robust Python function that finds the minimum numeric value in a heterogeneous list, ignoring non-numeric elements (and excluding booleans, since bool is a subclass of int).\n\ndef min_value_in_heterogeneous_list(lst):\n    \"\"\"\n    Return the minimum numeric value from a heterogeneous list.\n    Non-numeric values are ignored. Booleans are ignored as well.\n    Raises ValueError if no numeric values are present.\n    \"\"\"\n    # Collect numeric values (excluding booleans)\n    nums = [x for x in lst if isinstance(x, (int, float)) and not isinstance(x, bool)]\n    if not nums:\n        raise ValueError(\"No numeric values found in the list.\")\n    return min(nums)\n\n# Example\nlst = [3, \"a\", 2.5, None, 4, True]\nprint(min_value_in_heterogeneous_list(lst))  # Output: 2.5\n\nNotes and alternatives:\n- If you want to include numeric-looking strings (e.g., \"2.5\"), you can add a parsing step to convert strings to numbers.\n- If the list may contain NaN, you might want to filter those out before taking min, e.g., using math.isnan to skip NaNs.\n- If you want to consider booleans as numbers, remove the not isinstance(x, bool) check."}
{"task_id": "Mbpp/415", "completion": "Here\u2019s a Python function that returns the pair of integers with the highest product from a list. It runs in O(n) time and O(1) extra space.\n\ndef max_product_pair(arr):\n    if len(arr) < 2:\n        raise ValueError(\"Need at least two numbers to form a pair.\")\n\n    # Track the two largest and two smallest numbers\n    max1 = max2 = float('-inf')\n    min1 = min2 = float('inf')\n\n    for x in arr:\n        # Update the two largest\n        if x > max1:\n            max2, max1 = max1, x\n        elif x > max2:\n            max2 = x\n\n        # Update the two smallest\n        if x < min1:\n            min2, min1 = min1, x\n        elif x < min2:\n            min2 = x\n\n    prod1 = max1 * max2\n    prod2 = min1 * min2\n\n    # The maximum product can come from either two largest positives\n    # or two smallest negatives (negative*negative)\n    if prod1 >= prod2:\n        return (max1, max2)\n    else:\n        return (min1, min2)\n\nUsage example:\npairs = max_product_pair([ -10, -3, 5, 6 ])\nprint(pairs)  # Could print (-10, -3) if their product (30) is the largest, or (5,6) if that product is larger."}
{"task_id": "Mbpp/425", "completion": "Here\u2019s a Python function that counts how many sublists contain a given element at least once. It assumes you have a list (or iterable) of sublists.\n\nPython\ndef count_sublists_with_element(nested, target):\n    \"\"\"\n    nested: iterable of iterables (e.g., list of lists)\n    target: element to look for\n    Returns: number of sublists that contain target\n    \"\"\"\n    return sum(1 for sub in nested if target in sub)\n\n# Example\nnested = [[1, 2, 3], [4, 5], [1], [], [2, 3, 4]]\nprint(count_sublists_with_element(nested, 1))  # 2\n\nIf you want to count the total number of occurrences of the element across all sublists (not just how many sublists contain it), you can use:\n\ndef total_occurrences(nested, target):\n    total = 0\n    for sub in nested:\n        for item in sub:\n            if item == target:\n                total += 1\n    return total\n\nNotes:\n- The first function counts each sublist at most once, regardless of how many times target appears inside it.\n- Uses O(n*m) time in the worst case, where n is the number of sublists and m is the average sublist length.\n\nIf you\u2019d like this in another language (JavaScript, Java, etc.), tell me which one and I\u2019ll adapt it."}
{"task_id": "Mbpp/436", "completion": "Here\u2019s a simple function that returns the negative numbers from a list:\n\ndef negatives(nums):\n    \"\"\"Return a list of negative numbers from nums.\"\"\"\n    return [x for x in nums if x < 0]\n\n# Example\nprint(negatives([3, -1.5, 0, -2, 7]))  # [-1.5, -2]\n\nIf you expect non-numeric values and want to skip them safely, you can wrap it a bit more:\n\ndef negatives_safe(nums):\n    \"\"\"Return a list of negative numbers from nums, skipping non-numeric values.\"\"\"\n    result = []\n    for x in nums:\n        try:\n            if x < 0:\n                result.append(x)\n        except TypeError:\n            pass\n    return result\n\n# Example\nprint(negatives_safe([3, -1.5, 'a', -2, 7]))  # [-1.5, -2]"}
{"task_id": "Mbpp/435", "completion": "Here's a simple Python function that returns the last decimal digit of a number. It works for integers and strings that represent integers (including negative numbers).\n\n```python\ndef last_digit(n):\n    \"\"\"\n    Return the last decimal digit of an integer n.\n    Accepts int or string representing an integer (e.g., 1234 or \"-56\" or \"789\").\n    \"\"\"\n    try:\n        n = int(n)\n    except Exception:\n        raise ValueError(\"Input must be an integer or a string representing an integer.\")\n    return abs(n) % 10\n\n# Examples:\nprint(last_digit(12345))   # 5\nprint(last_digit(-9876))   # 6\nprint(last_digit(\"4321\"))  # 1\n```\n\nIf you only want to support integers (not strings), you can simplify by removing the int conversion guard and just return abs(n) % 10."}
{"task_id": "Mbpp/414", "completion": "Here's a robust Python function that checks whether any value from one sequence exists in another sequence (i.e., whether they have at least one common element). It tries to be efficient by using a set from the smaller sequence, and it also handles unhashable elements with a fallback.\n\nCode:\n\ndef any_common(seq1, seq2):\n    \"\"\"\n    Return True if seq1 and seq2 have at least one value in common.\n    Works for hashable elements. Tries to optimize by building a set from\n    the smaller sequence to reduce memory usage.\n    \"\"\"\n    # Try to use sizes if available (works for lists, tuples, strings, etc.)\n    try:\n        len1, len2 = len(seq1), len(seq2)\n    except TypeError:\n        len1 = len2 = None\n\n    if len1 is not None and (len2 is None or len1 <= len2):\n        small, large = seq1, seq2\n    else:\n        small, large = seq2, seq1\n\n    try:\n        s = set(small)\n    except TypeError:\n        # Fallback if elements are unhashable (e.g., lists inside)\n        for a in seq1:\n            for b in seq2:\n                if a == b:\n                    return True\n        return False\n\n    for item in large:\n        if item in s:\n            return True\n    return False\n\nUsage examples:\n\nprint(any_common([1, 2, 3], [4, 5, 3]))  # True\nprint(any_common(\"abc\", \"xyz\"))          # False\nprint(any_common([1, 2], [3, 4]))        # False\n\nNote: If elements are unhashable (like lists), the function falls back to a nested comparison. If you know the elements are hashable (common case), the set-based approach is efficient."}
{"task_id": "Mbpp/441", "completion": "The surface area of a cube with side length s is 6 * s^2.\n\nHere are simple implementations in a few common languages:\n\nPython\n```python\ndef cube_surface_area(side: float) -> float:\n    if side < 0:\n        raise ValueError(\"Side length must be non-negative\")\n    return 6 * side * side\n```\n\nJavaScript\n```javascript\nfunction cubeSurfaceArea(side) {\n  if (side < 0) throw new Error(\"Side length must be non-negative\");\n  return 6 * side * side;\n}\n```\n\nJava\n```java\npublic static double cubeSurfaceArea(double side) {\n    if (side < 0) throw new IllegalArgumentException(\"Side length must be non-negative\");\n    return 6 * side * side;\n}\n```\n\nC++\n```cpp\n#include <stdexcept>\n\ndouble cubeSurfaceArea(double side) {\n    if (side < 0) throw std::invalid_argument(\"Side length must be non-negative\");\n    return 6.0 * side * side;\n}\n```\n\nUsage example (Python):\n```python\nprint(cube_surface_area(3))  # 54\n```"}
{"task_id": "Mbpp/426", "completion": "Here are simple implementations in a few popular languages. If you want a different language, tell me.\n\nPython\n- Quick version (returns a new list)\ndef filter_odds(nums):\n    return [n for n in nums if n % 2 != 0]\n\n- Generator version (lazy)\ndef filter_odds(nums):\n    for n in nums:\n        if n % 2 != 0:\n            yield n\n\nJavaScript\nfunction filterOdds(arr) {\n    return arr.filter(n => n % 2 !== 0);\n}\n\nJava (Java 8+)\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nstatic List<Integer> filterOdds(List<Integer> nums) {\n    return nums.stream()\n               .filter(n -> n % 2 != 0)\n               .collect(Collectors.toList());\n}\n\nC#\nusing System.Linq;\n\nIEnumerable<int> FilterOdds(IEnumerable<int> nums) => nums.Where(n => n % 2 != 0);\n\nC++\n#include <vector>\n\nstd::vector<int> filterOdds(const std::vector<int>& nums) {\n    std::vector<int> res;\n    for (int n : nums) {\n        if (n % 2 != 0) res.push_back(n);\n    }\n    return res;\n}\n\nNotes:\n- These assume integer inputs. The odd check uses n % 2 != 0 (works for positive and negative numbers in the shown ways).\n- If you want an in-place or streaming variant, I can tailor it to your use case. Which language and input type are you using?"}
{"task_id": "Mbpp/427", "completion": "Here are simple implementations in two common languages. They take a date in yyyy-mm-dd and return dd-mm-yyyy, with validation.\n\nPython\ndef ymd_to_dmy(date_str: str) -> str:\n    from datetime import datetime\n    dt = datetime.strptime(date_str, \"%Y-%m-%d\")  # validates format and date\n    return dt.strftime(\"%d-%m-%Y\")\n\n# Example\n# print(ymd_to_dmy(\"2025-12-06\"))  # 06-12-2025\n\nJavaScript\nfunction ymdToDmy(dateStr) {\n  // Validate format YYYY-MM-DD\n  const m = dateStr.match(/^(\\d{4})-(\\d{2})-(\\d{2})$/);\n  if (!m) throw new Error(\"Invalid date format, expected YYYY-MM-DD\");\n\n  const year = Number(m[1]);\n  const month = Number(m[2]);\n  const day = Number(m[3]);\n\n  // Validate actual date\n  const dt = new Date(year, month - 1, day);\n  if (dt.getFullYear() !== year || dt.getMonth() + 1 !== month || dt.getDate() !== day) {\n    throw new Error(\"Invalid date\");\n  }\n\n  const pad = (n) => String(n).padStart(2, '0');\n  return `${pad(day)}-${pad(month)}-${year}`;\n}\n\n// Example\n// console.log(ymdToDmy(\"2025-12-06\")); // 06-12-2025\n\nIf you prefer a single-language example or want to avoid exceptions and return null on invalid input, tell me your preferred language and error-handling style."}
{"task_id": "Mbpp/428", "completion": "Here is a Python function that sorts a list using Shell sort (Knuth gap sequence). It sorts in place and returns the same list.\n\n```python\ndef shell_sort(arr):\n    \"\"\"Sort a list in place using Shell sort with Knuth's gap sequence.\"\"\"\n    n = len(arr)\n    gap = 1\n    # Build gap sequence: 1, 4, 13, 40, ...\n    while gap < n:\n        gap = gap * 3 + 1\n    gap //= 3\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 3\n    return arr\n```\n\nUsage example:\n```python\na = [12, 3, 7, 1, 9, 2]\nshell_sort(a)\nprint(a)  # [1, 2, 3, 7, 9, 12]\n```\n\nIf you want this in another language (C++, Java, JavaScript, etc.), tell me which language and I\u2019ll provide the equivalent function."}
{"task_id": "Mbpp/391", "completion": "Here's a Python function that converts any number of lists into a nested dictionary. Each index across the lists forms a path of keys from the first list up to the second-to-last list, with the last list providing the value at the deepest level.\n\ndef lists_to_nested_dict(*lists):\n    \"\"\"\n    Convert multiple lists into a nested dictionary.\n    For N lists, the i-th elements form a path:\n      lists[0][i] -> lists[1][i] -> ... -> lists[N-2][i] = value lists[N-1][i]\n    Result example for N=3: { L0[i]: { L1[i]: L2[i] } }\n    All input lists must have the same length.\n    \"\"\"\n    if not lists:\n        return {}\n    length = len(lists[0])\n    for lst in lists:\n        if len(lst) != length:\n            raise ValueError(\"All input lists must have the same length.\")\n\n    result = {}\n    n = len(lists)  # number of lists\n\n    for i in range(length):\n        d = result\n        # Create nested dicts for the first n-2 lists\n        for j in range(n - 2):\n            key = lists[j][i]\n            if key not in d or not isinstance(d[key], dict):\n                d[key] = {}\n            d = d[key]\n        # Use the (n-2)th list's element as the last key, and the last list's element as the value\n        last_key = lists[n - 2][i]\n        value = lists[n - 1][i]\n        d[last_key] = value\n\n    return result\n\nExample usage:\nL0 = ['a', 'b', 'c']\nL1 = ['x', 'y', 'z']\nL2 = [1, 2, 3]\nprint(lists_to_nested_dict(L0, L1, L2))\n# Output: {'a': {'x': 1}, 'b': {'y': 2}, 'c': {'z': 3}}\n\nIf you have only two lists, it will simply produce a flat mapping {L0[i]: L1[i]}. If you have more lists, it builds deeper nesting accordingly."}
{"task_id": "Mbpp/433", "completion": "Here are simple implementations that check if a given number is strictly greater than every element in the array. If the array is empty, the condition is treated as true (vacuous truth).\n\nPython\ndef is_greater_than_all(num, arr):\n    return all(num > x for x in arr)\n\n# Examples\n# is_greater_than_all(10, [1, 2, 3]) -> True\n# is_greater_than_all(5, [5, 4, 3]) -> False\n\nJavaScript\nfunction isGreaterThanAll(num, arr) {\n  return arr.every(x => num > x);\n}\n\n# Examples\n# isGreaterThanAll(10, [1, 2, 3]); // true\n# isGreaterThanAll(5, [5, 4, 3]);  // false\n\nJava\npublic static boolean isGreaterThanAll(int num, int[] arr) {\n    for (int x : arr) {\n        if (num <= x) return false;\n    }\n    return true;\n}\n\nC++\n#include <vector>\n\nbool isGreaterThanAll(int num, const std::vector<int>& arr) {\n    for (int x : arr) {\n        if (num <= x) return false;\n    }\n    return true;\n}\n\nC\nint is_greater_than_all(int num, const int* arr, size_t n) {\n    for (size_t i = 0; i < n; ++i) {\n        if (num <= arr[i]) return 0;\n    }\n    return 1;\n}\n\nNotes:\n- These implementations check strictly greater than all elements (num > element).\n- Time complexity: O(n) where n is the array length.\n- Space complexity: O(1) extra space.\n- If you want to check \"greater than or equal to\" instead, replace the comparison with num >= x."}
{"task_id": "Mbpp/445", "completion": "Here's a Python function to multiply elements at the same index in two tuples.\n\nOption 1: Strict (tuples must have the same length)\n```python\ndef mul_tuples_indexwise(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Multiply elements at the same index from t1 and t2.\n    Raises ValueError if the tuples have different lengths.\n    \"\"\"\n    if len(t1) != len(t2):\n        raise ValueError(\"Tuples must have the same length.\")\n    return tuple(a * b for a, b in zip(t1, t2))\n\n# Example\nprint(mul_tuples_indexwise((1, 2, 3), (4, 5, 6)))  # (4, 10, 18)\n```\n\nOption 2: Flexible (uses the shortest length, no error on different lengths)\n```python\ndef mul_tuples_indexwise_min(t1: tuple, t2: tuple) -> tuple:\n    \"\"\"\n    Multiply elements at the same index from t1 and t2.\n    Uses the shortest length of the two tuples.\n    \"\"\"\n    return tuple(a * b for a, b in zip(t1, t2))\n\n# Example\nprint(mul_tuples_indexwise_min((1, 2, 3, 4), (5, 6, 7)))  # (5, 12, 21)\n```\n\nNotes:\n- The result is a tuple of products, one per index.\n- If you expect both tuples to be the same length, use the strict version to enforce it.\n- If you want to see the behavior with non-numeric elements, ensure the elements support multiplication."}
{"task_id": "Mbpp/447", "completion": "Here\u2019s a simple Python function that returns the cube of each element in a list.\n\n- Simple version (works for int and float elements):\n\ndef cube_list(nums: list) -> list:\n    \"\"\"Return a list with the cube of each numeric element in nums.\"\"\"\n    return [x ** 3 for x in nums]\n\n# Example\nprint(cube_list([1, 2, 3]))  # [1, 8, 27]\n\n- Version with basic error handling (raises if non-numeric present):\n\ndef cube_list_safe(nums: list) -> list:\n    \"\"\"Return a list with the cube of each numeric element in nums.\n    Raises TypeError if any element is not numeric.\"\"\"\n    result = []\n    for x in nums:\n        if not isinstance(x, (int, float)):\n            raise TypeError(f\"Element {x} is not numeric\")\n        result.append(x ** 3)\n    return result\n\n- Variant that works with any iterable:\n\ndef cubes(iterable) -> list:\n    \"\"\"Return a list with the cube of each element from any iterable.\"\"\"\n    return [x ** 3 for x in iterable]\n\nUsage remains the same: cube_list([1, 2, 3]) -> [1, 8, 27]."}
{"task_id": "Mbpp/432", "completion": "The median (mid-segment) length of a trapezium is the average of the two base lengths. If the bases have lengths a and b, the median m is m = (a + b) / 2.\n\nHere are simple implementations in a couple of languages.\n\nPython\ndef trapezium_median(base1, base2):\n    \"\"\"\n    Return the median length of a trapezium given the two base lengths.\n    base1, base2: lengths of the two parallel sides (bases).\n    \"\"\"\n    a = float(base1)\n    b = float(base2)\n    if a < 0 or b < 0:\n        raise ValueError(\"Base lengths must be non-negative.\")\n    return (a + b) / 2.0\n\n# Example:\n# print(trapezium_median(3, 5))  # 4.0\n\nJavaScript\nfunction trapeziumMedian(base1, base2) {\n  const a = Number(base1);\n  const b = Number(base2);\n  if (Number.isNaN(a) || Number.isNaN(b)) {\n    throw new TypeError(\"base1 and base2 must be numbers\");\n  }\n  if (a < 0 || b < 0) {\n    throw new RangeError(\"Base lengths must be non-negative\");\n  }\n  return (a + b) / 2;\n}\n\n// Example:\n// console.log(trapeziumMedian(3, 5)); // 4\n\nIf you want a version that computes the median from the coordinates of the trapezium (i.e., given four points in order, assuming the bases are opposite sides), I can provide that as well. Would you like that?"}
{"task_id": "Mbpp/439", "completion": "Here's a Python example that concatenates a list of non-negative integers by their decimal representations into a single integer.\n\n```python\ndef join_integers(nums):\n    \"\"\"\n    Join a list of non-negative integers into a single integer\n    by concatenating their decimal representations.\n    Example: [12, 3, 45] -> 12345\n    \"\"\"\n    if nums is None:\n        raise TypeError(\"nums must be a list or tuple of non-negative integers\")\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"nums must be a list or tuple of non-negative integers\")\n    if not nums:\n        return 0\n\n    for n in nums:\n        if not isinstance(n, int):\n            raise TypeError(\"All elements must be integers\")\n        if n < 0:\n            raise ValueError(\"All elements must be non-negative\")\n\n    return int(''.join(str(n) for n in nums))\n```\n\nUsage examples:\n- join_integers([1, 23, 456]) -> 123456\n- join_integers([0, 0, 7]) -> 7 (leading zeros are not preserved when converting to int)\n\nNotes and alternatives:\n- If you want to join a list of digits (0-9) specifically, you can reuse the same approach with a small type check:\n  - Ensure every element is in [0, 9], then return int(''.join(str(d) for d in digits)).\n- If you want to preserve leading zeros (as a string) instead of returning an int, you can return the joined string instead of converting to int:\n  - return ''.join(str(n) for n in nums)  # returns a string like \"00123\" for [0, 0, 1, 2, 3]"}
{"task_id": "Mbpp/451", "completion": "Here are simple implementations in several popular languages to remove all whitespace characters (spaces, tabs, newlines, etc.) from a string.\n\n- Python\ndef remove_whitespace(s: str) -> str:\n    import re\n    return re.sub(r'\\s+', '', s)\n\n# Alternatively:\n# def remove_whitespace(s: str) -> str:\n#     return ''.join(s.split())\n\n- JavaScript\nfunction removeWhitespace(str) {\n  return str.replace(/\\s+/g, '');\n}\n\n- Java\npublic static String removeWhitespace(String s) {\n    return s.replaceAll(\"\\\\s+\", \"\");\n}\n\n- C++\n#include <string>\n#include <cctype>\n\nstd::string removeWhitespace(const std::string& s) {\n    std::string out;\n    out.reserve(s.size());\n    for (char c : s) {\n        if (!std::isspace(static_cast<unsigned char>(c)))\n            out.push_back(c);\n    }\n    return out;\n}\n\n- C#\nusing System.Text.RegularExpressions;\n\nstring RemoveWhitespace(string s) {\n    return Regex.Replace(s, @\"\\s+\", \"\");\n}\n\nNotes:\n- These remove all whitespace characters, including spaces, tabs, newlines, etc.\n- In languages with null input handling (e.g., Java, C#), you may want to add a null check if needed."}
{"task_id": "Mbpp/450", "completion": "Here\u2019s a simple Python function that extracts strings of a specified length from a list (i.e., keeps only strings whose length equals size).\n\n```python\nfrom typing import List\n\ndef extract_strings_of_size(values: List[str], size: int) -> List[str]:\n    \"\"\"\n    Return strings from 'values' whose length is exactly 'size'.\n    \"\"\"\n    if size < 0:\n        raise ValueError(\"size must be non-negative\")\n    return [s for s in values if len(s) == size]\n\n# Example\nvalues = [\"apple\", \"pear\", \"kiwi\", \"fig\", \"plum\", \"peach\"]\nprint(extract_strings_of_size(values, 4))  # ['pear', 'kiwi', 'plum']\n```\n\nIf you instead want to extract the first n characters from each string (i.e., substrings of length size), you can use a variant:\n\n```python\ndef first_n_chars(values: List[str], size: int, pad_short=False, pad_char=\" \") -> List[str]:\n    \"\"\"\n    For each string in 'values', take the first 'size' characters.\n    - If a string is shorter than 'size', either skip it or pad it (depending on pad_short).\n    \"\"\"\n    if size < 0:\n        raise ValueError(\"size must be non-negative\")\n    result = []\n    for s in values:\n        if len(s) >= size:\n            result.append(s[:size])\n        elif pad_short:\n            result.append(s.ljust(size, pad_char))\n    return result\n\n# Example\nprint(first_n_chars(values, 4))              # ['ipea', 'pear', 'kiwi', 'fig\u026a'] (adjusted example)\n\n```\n\nNotes:\n- The first function filters to strings of exact length equal to size.\n- The second function extracts the first size characters from each string; you can choose to pad short strings if desired. If you had a different interpretation (e.g., subsets, random sampling, etc.), tell me and I\u2019ll tailor the function."}
{"task_id": "Mbpp/429", "completion": "Here\u2019s a flexible Python function that takes two tuples, returns the pairwise (elementwise) pairs, and also returns the results of applying a specified elementwise operation. If you don\u2019t pass an operation, it will try to sum the elements by default.\n\nCode:\n\ndef extract_elementwise_and_tuples(a, b, op=None):\n    \"\"\"\n    Given two sequences (tuples) a and b, return:\n      - pairs: tuple of corresponding element pairs up to the shortest length\n      - elementwise: results of applying op to each pair (or sum if op is None)\n\n    - If op is None, it tries to compute a[i] + b[i] for each i.\n    - If types don\u2019t support the operation, elementwise will be None.\n    \"\"\"\n    a_t = tuple(a)\n    b_t = tuple(b)\n    min_len = min(len(a_t), len(b_t))\n    pairs = tuple((a_t[i], b_t[i]) for i in range(min_len))\n\n    if op is None:\n        try:\n            elementwise = tuple(a_t[i] + b_t[i] for i in range(min_len))\n        except Exception:\n            elementwise = None\n    else:\n        elementwise = tuple(op(x, y) for x, y in pairs)\n\n    return pairs, elementwise\n\nUsage examples:\n\nt1 = (1, 2, 3)\nt2 = (4, 5, 6, 7)\n\n# Default (try to sum elementwise)\npairs, sums = extract_elementwise_and_tuples(t1, t2)\n# pairs -> ((1, 4), (2, 5), (3, 6))\n# sums  -> (5, 7, 9)\n\n# With a specific operation (e.g., multiplication)\nimport operator\npairs, products = extract_elementwise_and_tuples(t1, t2, op=operator.mul)\n# products -> (4, 10, 18)\n\nNotes:\n- The result uses the length of the shorter input by default. If you want to keep extra elements from the longer tuple, you can extend the function accordingly.\n- If you pass a custom operation that isn\u2019t supported for the given types, elementwise will be None."}
{"task_id": "Mbpp/437", "completion": "Here are simple implementations. I\u2019ll assume you want to remove characters at odd indices (0-based), i.e., keep indices 0, 2, 4, \u2026\n\nPython\ndef remove_odd_indices(s):\n    return s[::2]\n\n# Example: \"abcdef\" -> \"ace\"\n\nJavaScript\nfunction removeOddIndices(s) {\n  return s.split('').filter((_, i) => i % 2 === 0).join('');\n}\n\n# Example: \"abcdef\" -> \"ace\"\n\nJava\npublic static String removeOddIndices(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i += 2) {\n        sb.append(s.charAt(i));\n    }\n    return sb.toString();\n}\n\nIf you instead meant removing characters at odd positions (counting from 1, i.e., 1st, 3rd, 5th, ...), use the complementary indices:\n- Python: return s[1::2]\n- JavaScript: keep i % 2 === 1\n- Java: loop i = 1; i < s.length(); i += 2 and append s.charAt(i)\n\nExample for that interpretation with \"abcdef\" would yield \"bdf\"."}
{"task_id": "Mbpp/456", "completion": "Here are simple implementations in a few common languages. Each function returns a new list/array with every string reversed.\n\nPython\n- Non-destructive (returns a new list)\ndef reverse_strings(strings):\n    \"\"\"Return a new list with each string reversed.\"\"\"\n    if strings is None:\n        return None\n    return [s[::-1] for s in strings]\n\n- In-place (mutates the input list)\ndef reverse_strings_in_place(strings):\n    \"\"\"Reverse each string in place (mutates input list).\"\"\"\n    for i in range(len(strings)):\n        strings[i] = strings[i][::-1]\n\nJavaScript\nfunction reverseStrings(arr) {\n  if (!Array.isArray(arr)) {\n    throw new TypeError('Expected an array of strings');\n  }\n  return arr.map(s => (typeof s === 'string' ? s.split('').reverse().join('') : s));\n}\n\nJava\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static List<String> reverseStrings(List<String> input) {\n    if (input == null) return null;\n    List<String> result = new ArrayList<>(input.size());\n    for (String s : input) {\n        result.add(new StringBuilder(s).reverse().toString());\n    }\n    return result;\n}\n\nC#\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static List<string> ReverseStrings(IEnumerable<string> input)\n{\n    return input.Select(s => new string(s.Reverse().ToArray())).ToList();\n}\n\nNotes\n- Each version reverses the characters in every string, not the order of the strings themselves.\n- Time complexity: O(total number of characters) across all strings.\n- If you want to handle non-string elements, you can adjust validation or convert elements to strings first."}
{"task_id": "Mbpp/454", "completion": "Here\u2019s a simple approach: use a regex that finds word boundaries and requires at least one 'z' inside the word. Use case-insensitive matching if you want to include 'Z' as well.\n\nRegex pattern (case-insensitive): \\b\\w*z\\w*\\b\nIf you want only letters (no digits/underscore) use: \\b[a-z]*z[a-z]*\\b with the ignore-case flag.\n\nExamples in common languages:\n\n- Python\n  import re\n  pattern = re.compile(r'\\b\\w*z\\w*\\b', re.IGNORECASE)\n  text = \"alpha zebra zzz zone pizza zap\"\n  matches = pattern.findall(text)\n  # matches -> ['zebra', 'zzz', 'zone', 'pizza', 'zap']\n\n- JavaScript\n  const text = \"alpha zebra zzz zone pizza zap\";\n  const matches = text.match(/\\b\\w*z\\w*\\b/gi) || [];\n  // matches -> [\"zebra\",\"zzz\",\"zone\",\"pizza\",\"zap\"]\n\nNotes:\n- \\b marks word boundaries.\n- \\w*z\\w* ensures there is at least one 'z' (or 'Z') somewhere in the word.\n- Use a version you prefer depending on whether digits/underscore should count as part of the word. If you want strictly alphabetic words, use a-z instead of \\w."}
{"task_id": "Mbpp/455", "completion": "Here is a simple function in Python. It returns True if the given month (as 1\u201312) has 31 days, and False otherwise. It raises an error for invalid input.\n\nPython\ndef has_31_days(month):\n    \"\"\"Return True if month (1-12) has 31 days, else False. Raises ValueError for invalid input.\"\"\"\n    if not isinstance(month, int) or not (1 <= month <= 12):\n        raise ValueError(\"month must be an integer from 1 to 12\")\n    return month in {1, 3, 5, 7, 8, 10, 12}\n\n# Examples:\n# has_31_days(1) -> True\n# has_31_days(2) -> False\n\nIf you prefer a shorter version without the explicit error, you could also do:\ndef has_31_days(month):\n    return month in {1, 3, 5, 7, 8, 10, 12}\n\nEquivalent implementations in other languages:\n\nJavaScript\nfunction has31Days(month) {\n  if (!Number.isInteger(month) || month < 1 || month > 12) {\n    throw new Error(\"Invalid month\");\n  }\n  return [1, 3, 5, 7, 8, 10, 12].includes(month);\n}\n\nJava\npublic static boolean has31Days(int month) {\n    if (month < 1 || month > 12) {\n        throw new IllegalArgumentException(\"month must be 1-12\");\n    }\n    return month == 1 || month == 3 || month == 5 || month == 7 ||\n           month == 8 || month == 10 || month == 12;\n}\n\nC\n#include <stdbool.h>\n\nbool has_31_days(int month) {\n    if (month < 1 || month > 12) {\n        // handle error as you prefer\n        return false;\n    }\n    return month == 1 || month == 3 || month == 5 || month == 7 ||\n           month == 8 || month == 10 || month == 12;\n}\n\nNote: February is not included in the 31-day months, regardless of leap year. If you need to validate leap-year logic elsewhere, you can add that separately."}
{"task_id": "Mbpp/460", "completion": "Here are a couple of simple options.\n\nBasic version (returns None for empty sublists):\ndef first_of_each(sublists):\n    \"\"\"Return the first element of each sublist; None if a sublist is empty.\"\"\"\n    return [sub[0] if sub else None for sub in sublists]\n\nExample:\ndata = [[1, 2], [3, 4], [], [5]]\nprint(first_of_each(data))  # [1, 3, None, 5]\n\nSkip empty sublists (only include sublists that have a first element):\ndef first_of_each_skip_empty(sublists):\n    \"\"\"Return the first element of each non-empty sublist.\"\"\"\n    return [sub[0] for sub in sublists if sub]\n\nExample:\nprint(first_of_each_skip_empty(data))  # [1, 3, 5]"}
{"task_id": "Mbpp/430", "completion": "Here are Python examples for common representations of a parabola.\n\n1) Parabola in standard vertical form: y = a x^2 + b x + c\n- Directrix is the horizontal line y = k - p, where:\n  - h = -b/(2a)\n  - k = c - b^2/(4a)\n  - p = 1/(4a)\n\nCode:\n```python\ndef directrix_from_quadratic(a, b, c):\n    if a == 0:\n        raise ValueError(\"Coefficient a must be nonzero for a parabola.\")\n    h = -b / (2 * a)\n    k = c - (b*b) / (4 * a)\n    p = 1.0 / (4 * a)\n    directrix_y = k - p\n    return f\"y = {directrix_y}\"\n```\n\nExample:\n- For y = x^2 (a=1, b=0, c=0) -> \"y = -1/4\"\n\n2) Parabola in vertex form (x - h)^2 = 4p (y - k)\n- Directrix is y = k - p\n\nCode:\n```python\ndef directrix_from_vertex_form(h, k, p):\n    directrix_y = k - p\n    return f\"y = {directrix_y}\"\n```\n\nExample:\n- (x - 2)^2 = 8 (y - 3) => h=2, k=3, p=2 -> \"y = 1\"\n\n3) Horizontal parabola (y - k)^2 = 4p (x - h)\n- Directrix is x = h - p\n\nCode:\n```python\ndef directrix_from_horizontal_parabola(h, p):\n    directrix_x = h - p\n    return f\"x = {directrix_x}\"\n```\n\nIf you\u2019re using a different language (JavaScript, C++, etc.) or a rotated parabola, tell me the exact representation you have and I\u2019ll adapt the function."}
{"task_id": "Mbpp/448", "completion": "Here\u2019s a simple Python function that computes the sum of Perrin numbers from P(0) through P(n).\n\nPerrin sequence (for reference):\n- P(0) = 3, P(1) = 0, P(2) = 2\n- P(n) = P(n-2) + P(n-3) for n >= 3\n\nFunction:\n\n```python\ndef sum_perrin(n):\n    \"\"\"Return sum of Perrin numbers P(0) + P(1) + ... + P(n).\"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n\n    # Handle small n directly\n    if n == 0:\n        return 3\n    if n == 1:\n        return 3 + 0\n    if n == 2:\n        return 3 + 0 + 2\n\n    # Sum up to P(2)\n    total = 3 + 0 + 2\n\n    # Rolling window: a = P(i-3), b = P(i-2), c = P(i-1)\n    a, b, c = 3, 0, 2\n\n    for i in range(3, n + 1):\n        p = a + b       # P(i) = P(i-2) + P(i-3)\n        total += p\n        a, b, c = b, c, p  # slide the window\n\n    return total\n```\n\nExample:\n- sum_perrin(5) returns 15 (since P: 3, 0, 2, 3, 2, 5; sum = 15).\n\nIf you meant a different interpretation of \"sum of Perrin numbers\" (e.g., sum over a range, or a closed-form), tell me and I\u2019ll adjust."}
{"task_id": "Mbpp/458", "completion": "Here are simple implementations in a few common languages. Let me know which language you prefer and I can tailor it.\n\n- Python (robust version with input validation)\ndef rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle given length and width.\n    Accepts numbers (ints/floats). Raises ValueError for negative or non-numeric inputs.\n    \"\"\"\n    try:\n        l = float(length)\n        w = float(width)\n    except (TypeError, ValueError):\n        raise ValueError(\"length and width must be numbers\")\n    if l < 0 or w < 0:\n        raise ValueError(\"length and width must be non-negative\")\n    return l * w\n\n- Python (with type hints)\ndef rectangle_area(length: float, width: float) -> float:\n    if length < 0 or width < 0:\n        raise ValueError(\"length and width must be non-negative\")\n    return length * width\n\n- JavaScript (Node/Browser)\nfunction rectangleArea(length, width) {\n  if (typeof length !== 'number' || typeof width !== 'number') {\n    throw new TypeError('length and width must be numbers');\n  }\n  if (length < 0 || width < 0) {\n    throw new RangeError('length and width must be non-negative');\n  }\n  return length * width;\n}\n\n- Java\npublic static double rectangleArea(double length, double width) {\n    if (length < 0 || width < 0) {\n        throw new IllegalArgumentException(\"length and width must be non-negative\");\n    }\n    return length * width;\n}\n\n- C++\n#include <stdexcept>\n\ndouble rectangleArea(double length, double width) {\n    if (length < 0 || width < 0) {\n        throw std::invalid_argument(\"length and width must be non-negative\");\n    }\n    return length * width;\n}\n\nIf you tell me your preferred language or any constraints (like no exceptions, or handling units), I can adjust accordingly."}
{"task_id": "Mbpp/440", "completion": "Here\u2019s a Python function that returns the first adverb and the positions (token indices) of all adverbs in a sentence. It uses spaCy if available (which is the reliable approach), and falls back to a simple heuristic if spaCy isn\u2019t installed.\n\nPython code:\n\n```python\ndef find_first_adverb_and_positions(sentence: str):\n    \"\"\"\n    Returns a dict with:\n      - 'first_adverb': the first adverb as text, or None if none found\n      - 'positions': list of token indices (0-based) where adverbs occur\n\n    Tries spaCy (pos_ == 'ADV') first; if spaCy/model isn't available, falls back\n    to a simple heuristic (ends with -ly or common adverbs).\n    \"\"\"\n    # Try spaCy-based tagging\n    try:\n        import spacy\n        nlp = spacy.load(\"en_core_web_sm\")\n        doc = nlp(sentence)\n        positions = [i for i, tok in enumerate(doc) if tok.pos_ == \"ADV\"]\n        first = doc[positions[0]].text if positions else None\n        return {\"first_adverb\": first, \"positions\": positions}\n    except Exception:\n        # Fallback heuristic: detect words ending with -ly or a small set of common adverbs\n        words = sentence.split()\n        common_adverbs = {\n            'very','extremely','quite','too','so','well','fast','hard','late','early','often',\n            'almost','barely','simply','therefore','therein','thereafter','still','just'\n        }\n        positions = [\n            i for i, w in enumerate(words)\n            if w.lower().endswith(\"ly\") or w.lower() in common_adverbs\n        ]\n        first = words[positions[0]] if positions else None\n        return {\"first_adverb\": first, \"positions\": positions}\n```\n\nUsage example:\n\n```python\nsentence = \"She quickly ran to the store and spoke very softly.\"\nresult = find_first_adverb_and_positions(sentence)\nprint(\"First adverb:\", result[\"first_adverb\"])\nprint(\"Adverb positions:\", result[\"positions\"])\n```\n\nNotes:\n- If you want the spaCy path, install the library and model:\n  - pip install spacy\n  - python -m spacy download en_core_web_sm\n- The function returns:\n  - first_adverb: the first adverb token text (or None if none found)\n  - positions: a list of 0-based token indices where adverbs occur in the sentence\n\nIf you\u2019d prefer a version that always returns 1-based positions or returns more metadata (e.g., the actual tokens), I can adjust it."}
{"task_id": "Mbpp/470", "completion": "Here\u2019s a simple Python function that returns the sums of neighboring elements in a tuple. For a tuple (a1, a2, a3, ..., an), it returns (a1+a2, a2+a3, ..., a_{n-1}+a_n).\n\n```python\ndef pairwise_sum_neighbors(t):\n    \"\"\"\n    Return a tuple containing sums of adjacent elements of the input tuple t.\n    Example: (1, 2, 3, 4) -> (3, 5, 7)\n    \"\"\"\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return tuple(a + b for a, b in zip(t, t[1:]))\n```\n\nUsage examples:\n- pairwise_sum_neighbors((1, 2, 3, 4)) -> (3, 5, 7)\n- pairwise_sum_neighbors((5, 7)) -> (12,)\n- pairwise_sum_neighbors((10,)) -> ()\n\nNotes:\n- If the input tuple has fewer than 2 elements, the result is an empty tuple.\n- The function assumes elements support the + operator (numbers, or other addable types)."}
{"task_id": "Mbpp/471", "completion": "Here\u2019s a concise Python function that computes the product of an array modulo n in one pass (O(n) time, O(1) space). It also handles negative numbers and empty input gracefully.\n\n```python\nfrom typing import Iterable\n\ndef product_mod(arr: Iterable[int], mod: int) -> int:\n    \"\"\"\n    Return (product of all elements in arr) modulo mod.\n    - arr: iterable of integers\n    - mod: positive integer modulus\n    If arr is empty, returns 1 % mod.\n    \"\"\"\n    if mod <= 0:\n        raise ValueError(\"mod must be a positive integer\")\n    \n    result = 1 % mod\n    for x in arr:\n        result = (result * (x % mod)) % mod\n    return result\n```\n\nExamples:\n- product_mod([2, 3, 5], 7) -> (2*3*5) % 7 = 30 % 7 = 2\n- product_mod([], 5) -> 1 % 5 = 1\n- product_mod([ -1, 2, 3 ], 5) -> ((-1)%5 * 2 * 3) % 5 = (4*2*3)%5 = 24%5 = 4\n\nIf you\u2019re using Python 3.8+, you can also implement it with a small variation using math.prod, but keep the modulo reduction in the loop to avoid huge intermediate products."}
{"task_id": "Mbpp/453", "completion": "Here's a concise Python function to compute the sum of even divisors of a positive integer n.\n\nIdea: sum of all divisors sigma(n) minus sum of odd divisors sigma(odd_part(n)) gives sum of even divisors. The odd part is n with all factors of 2 removed.\n\nCode:\n\n```python\ndef sigma(n):\n    # Sum of all positive divisors of n (n >= 1)\n    if n == 1:\n        return 1\n    result = 1\n    temp = n\n\n    # factor out powers of 2\n    cnt = 0\n    while temp % 2 == 0:\n        temp //= 2\n        cnt += 1\n    if cnt > 0:\n        result *= (2**(cnt+1) - 1) // (2 - 1)  # 2^(cnt+1) - 1\n\n    # factor odd part\n    p = 3\n    while p * p <= temp:\n        if temp % p == 0:\n            cnt = 0\n            while temp % p == 0:\n                temp //= p\n                cnt += 1\n            result *= (p**(cnt+1) - 1) // (p - 1)\n        p += 2\n\n    if temp > 1:\n        # remaining prime factor\n        result *= (temp**2 - 1) // (temp - 1)\n\n    return result\n\ndef sum_even_divisors(n):\n    \"\"\"\n    Return the sum of even divisors of n.\n    Works for positive integers. For n <= 0, it raises ValueError.\n    \"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n <= 0:\n        raise ValueError(\"n must be positive\")\n\n    # odd part: remove all factors of 2\n    odd = n\n    while odd % 2 == 0:\n        odd //= 2\n\n    # sum of even divisors = sigma(n) - sigma(odd_part)\n    return sigma(n) - sigma(odd)\n\n# Examples:\n# print(sum_even_divisors(12))  # 2+4+6+12 = 24\n# print(sum_even_divisors(15))  # 0\n```\n\nIf you want a simpler (but slower) version for small n, you can use a straightforward loop:\ndef sum_even_divisors_naive(n):\n    s = 0\n    for i in range(2, n+1, 2):\n        if n % i == 0:\n            s += i\n    return s\n\nBut the sigma-based approach above is more efficient for larger n."}
{"task_id": "Mbpp/446", "completion": "Here\u2019s a Python function that counts how many times each element from a given list appears in a tuple. It returns a dictionary mapping each unique element (from the input list) to its count in the tuple.\n\n```python\nfrom collections import Counter\nfrom typing import Iterable, Any, Dict\n\ndef count_occurrences_in_tuple(elements: Iterable[Any], tup: tuple) -> Dict[Any, int]:\n    \"\"\"\n    elements: iterable of elements to count (values to look for)\n    tup: the tuple in which to count occurrences\n    Returns: dict mapping each unique element from 'elements' to its count in 'tup'\n    Note: The keys in the result must be hashable to be valid dict keys.\n    \"\"\"\n    # Count occurrences in the tuple\n    try:\n        counts = Counter(tup)\n        result = {}\n        seen = set()\n        for e in elements:\n            if e not in seen:\n                seen.add(e)\n                result[e] = counts.get(e, 0)\n        return result\n    except TypeError:\n        # Fallback for unhashable elements in 'tup'\n        result = {}\n        seen = []\n        for e in elements:\n            if any(e == s for s in seen):\n                continue\n            seen.append(e)\n            result[e] = sum(1 for x in tup if x == e)\n        return result\n\n# Example\nlst = [1, 2, 3, 2]\ntup = (1, 2, 2, 4, 1)\nprint(count_occurrences_in_tuple(lst, tup))\n# Output: {1: 2, 2: 2, 3: 0}\n```\n\nIf you want a simpler, single-line version (without preserving input order or handling unhashable elements gracefully), you can use:\n- {e: tup.count(e) for e in lst}"}
{"task_id": "Mbpp/457", "completion": "Here is a simple function that finds the shortest sublist from a list of sublists (or tuples). If there are several with the same minimum length, it returns the first one by default. You can also ask for all shortest sublists.\n\nCode:\n\ndef shortest_sublist(data, return_all=False):\n    \"\"\"\n    data: iterable of sublists/tuples (e.g., [[1,2], [3], (4,5)])\n    return_all: if True, return all sublists with the minimal length,\n                otherwise return the first one.\n    Returns None if input is empty.\n    \"\"\"\n    data_list = list(data)\n    if not data_list:\n        return [] if return_all else None\n\n    min_len = min(len(sub) for sub in data_list)\n\n    if return_all:\n        return [sub for sub in data_list if len(sub) == min_len]\n    else:\n        for sub in data_list:\n            if len(sub) == min_len:\n                return sub\n        return None\n\nUsage examples:\n\nprint(shortest_sublist([[1, 2, 3], [4], [5, 6]]))  # [4]\nprint(shortest_sublist([[1, 2], [], [3, 4, 5]], return_all=True))  # [ [] ] (the empty sublist in this case)\n\nNotes:\n- This assumes the input is a sequence of sublists/tuples (i.e., each element supports len()).\n- If you want to include empty sublists as valid shortest ones, keep as is. If you want to ignore empty sublists, you can filter them first."}
{"task_id": "Mbpp/463", "completion": "Here\u2019s a concise O(n) solution using dynamic programming. We keep two running products:\n- curr_max: maximum product ending at the current position\n- curr_min: minimum product ending at the current position (needed because a negative times a negative can become positive)\n\nReason: a negative number can turn a small negative product into a large positive product, so we need to track both.\n\nPython version:\ndef max_product_subarray(nums):\n    if not nums:\n        return 0  # or raise an exception if preferred\n\n    curr_max = curr_min = best = nums[0]\n    for x in nums[1:]:\n        if x < 0:\n            curr_max, curr_min = curr_min, curr_max\n        curr_max = max(x, curr_max * x)\n        curr_min = min(x, curr_min * x)\n        best = max(best, curr_max)\n    return best\n\nIf you\u2019d like implementations in other languages:\n\nJavaScript\nfunction maxProductSubarray(nums) {\n  if (!nums.length) return 0;\n  let maxProd = nums[0], minProd = nums[0], ans = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    const x = nums[i];\n    if (x < 0) [maxProd, minProd] = [minProd, maxProd];\n    maxProd = Math.max(x, maxProd * x);\n    minProd = Math.min(x, minProd * x);\n    ans = Math.max(ans, maxProd);\n  }\n  return ans;\n}\n\nJava\npublic int maxProduct(int[] nums) {\n    int maxProd = nums[0], minProd = nums[0], ans = nums[0];\n    for (int i = 1; i < nums.length; i++) {\n        int x = nums[i];\n        if (x < 0) {\n            int tmp = maxProd;\n            maxProd = minProd;\n            minProd = tmp;\n        }\n        maxProd = Math.max(x, maxProd * x);\n        minProd = Math.min(x, minProd * x);\n        ans = Math.max(ans, maxProd);\n    }\n    return ans;\n}\n\nC++\nlong long maxProductSubarray(const std::vector<int>& nums) {\n    long long maxProd = nums[0], minProd = nums[0], ans = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        long long x = nums[i];\n        if (x < 0) std::swap(maxProd, minProd);\n        maxProd = std::max(x, maxProd * x);\n        minProd = std::min(x, minProd * x);\n        ans = std::max(ans, maxProd);\n    }\n    return ans;\n}\n\nNotes:\n- Handles zeros correctly: when an element is zero, both curr_max and curr_min get reset via the max/min comparisons.\n- Works for arrays with negative numbers, positives, and mixtures.\n- Time complexity: O(n); Space complexity: O(1)."}
{"task_id": "Mbpp/477", "completion": "Here's a simple Python function that converts a given string to lowercase:\n\ndef to_lower(s: str) -> str:\n    return s.lower()\n\n# Example:\n# to_lower(\"Hello World!\") -> \"hello world!\"\n\nIf you want a version that gracefully handles non-string inputs (or None) by converting to string first:\n\ndef to_lower_any(x):\n    if x is None:\n        return None\n    return str(x).lower()\n\n# Examples:\n# to_lower_any(\"Hello\") -> \"hello\"\n# to_lower_any(123) -> \"123\""}
{"task_id": "Mbpp/473", "completion": "Here's a Python function that finds the common elements across a list of tuples, ignoring the order within each tuple. It returns a tuple of the common elements (unique, and order is deterministic if possible).\n\n```python\ndef tuple_intersection_of_tuples(tuple_list):\n    \"\"\"\n    Given a list of tuples, return a tuple containing elements that are common to all tuples.\n    - Order inside each tuple is irrelevant (treated as a set of elements).\n    - Result is a tuple of unique common elements. If no common elements, returns ().\n    \"\"\"\n    if not tuple_list:\n        return tuple()\n\n    # Start with the first tuple's unique elements\n    common = set(tuple_list[0])\n\n    # Intersect with the rest\n    for t in tuple_list[1:]:\n        common &= set(t)\n        if not common:\n            return tuple()\n\n    # Return as a deterministic tuple (sorted if possible)\n    try:\n        return tuple(sorted(common))\n    except TypeError:\n        return tuple(common)\n\n# Examples:\nprint(tuple_intersection_of_tuples([(1, 2, 3), (3, 2, 4), (2, 3, 5)]))  # (2, 3)\nprint(tuple_intersection_of_tuples([(1, 'a'), ('a', 2), ('a', 3)]))    # ('a',)\nprint(tuple_intersection_of_tuples([(1, 2), (3, 4)]))                  # ()\n```\n\nIf you prefer preserving the original input order or avoiding sorting, you can simply return tuple(common) instead of the sorted version."}
{"task_id": "Mbpp/554", "completion": "Here\u2019s a simple function using a list comprehension:\n\ndef odd_numbers(nums: list[int]) -> list[int]:\n    \"\"\"Return only the odd integers from nums.\"\"\"\n    return [n for n in nums if n % 2 != 0]\n\nNotes:\n- This includes negative odd numbers (e.g., -3 is odd).\n- If you're on Python 3.8 or earlier, use typing.List instead of list[int]:\n  from typing import List\n  def odd_numbers(nums: List[int]) -> List[int]:\n      return [n for n in nums if n % 2 != 0]\n\nExample:\nprint(odd_numbers([1, 2, 3, 4, 5]))  # [1, 3, 5]"}
{"task_id": "Mbpp/472", "completion": "Here are two common interpretations and Python implementations. Pick the one that matches what you need (or both).\n\n1) Check if the list\u2019s values can form a consecutive sequence when sorted (duplicates ignored)\n- This answers: do the distinct numbers form a full range of consecutive integers?\n\ndef contains_all_consecutive(nums):\n    \"\"\"\n    Returns True if the distinct numbers in nums form a consecutive sequence\n    (e.g., [1,2,3,4] or [4,2,3,5] -> True; [1,3,5] -> False).\n    \"\"\"\n    if not nums:\n        return False\n    s = set(nums)\n    return max(s) - min(s) + 1 == len(s)\n\n2) Check if there exists at least one pair of consecutive numbers in the list\n- This answers: does the list contain any pair x and x+1?\n\ndef contains_any_consecutive_pair(nums):\n    \"\"\"\n    Returns True if there exists x in nums such that x+1 is also in nums.\n    \"\"\"\n    s = set(nums)\n    for x in s:\n        if (x + 1) in s:\n            return True\n    return False\n\n3) Optional: check if the list is already a consecutive sequence in the given order\n- This answers: are the elements in the list consecutively increasing by 1 in their current order?\n\ndef is_consecutive_in_order(nums):\n    \"\"\"\n    Returns True if nums is like [a, a+1, a+2, ...] in order.\n    \"\"\"\n    if len(nums) < 2:\n        return False\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] != 1:\n            return False\n    return True\n\nUsage examples:\n- contains_all_consecutive([4, 2, 3, 5, 6]) -> True\n- contains_any_consecutive_pair([1, 3, 5, 4]) -> True (because 3 and 4 are consecutive)\n- is_consecutive_in_order([1, 2, 3, 4]) -> True\n- is_consecutive_in_order([4, 1, 2]) -> False\n\nIf you have a specific interpretation in mind, tell me and I\u2019ll tailor the function accordingly."}
{"task_id": "Mbpp/462", "completion": "Here\u2019s a Python function that returns all possible combinations (subsets) of the elements in a list. It includes an option to include or exclude the empty set, and an option to deduplicate results by value (useful if the input has duplicates).\n\nCode:\n\n```python\nimport itertools\n\ndef all_combinations(lst, include_empty=True, deduplicate_by_value=False):\n    \"\"\"\n    Return all combinations (subsets) of elements in lst.\n\n    - include_empty: whether to include the empty subset []\n    - deduplicate_by_value: if True, remove duplicate subsets that have the same values\n      (useful when lst contains duplicates and you want unique value-subsets)\n    \"\"\"\n    # Generate all subsets of all sizes (0 to len(lst))\n    all_parts = []\n    for r in range(0, len(lst) + 1):\n        for comb in itertools.combinations(lst, r):\n            all_parts.append(list(comb))\n\n    if not include_empty:\n        all_parts = [c for c in all_parts if len(c) > 0]\n\n    if deduplicate_by_value:\n        seen = set()\n        uniq = []\n        for c in all_parts:\n            key = tuple(c)\n            if key not in seen:\n                seen.add(key)\n                uniq.append(c)\n        return uniq\n\n    return all_parts\n```\n\nUsage examples:\n\n```python\nlst = [1, 2, 3]\nprint(all_combinations(lst, include_empty=True))\n# Output: [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\nprint(all_combinations(lst, include_empty=False))\n# Output: [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]\n\n# If lst has duplicates and you want unique value-subsets:\nlst2 = [1, 1, 2]\nprint(all_combinations(lst2, include_empty=True, deduplicate_by_value=True))\n# Possible Output (order may vary): [[], [1], [2], [1, 1], [1, 2], [1, 1, 2]]\n```\n\nNotes:\n- This returns all subsets of all sizes (the power set). The number of subsets is 2^n, where n is the length of the list.\n- If you want all permutations of each subset (i.e., different orders), that\u2019s a different problem (it would involve generating permutations for each subset and can explode in size quickly). If you\u2019d like that variant, I can add it."}
{"task_id": "Mbpp/475", "completion": "Here are a few Python options. The idea is to sort by the dictionary\u2019s values (not keys).\n\nOption 1: Return a list of (key, value) pairs (sorted by value)\n- ascending by default\n- can set reverse=True for descending\n\ndef sort_dict_by_value(d, reverse=False):\n    \"\"\"\n    Return a list of (key, value) pairs sorted by value.\n    \"\"\"\n    return sorted(d.items(), key=lambda item: item[1], reverse=reverse)\n\n# Example\nd = {'apple': 3, 'banana': 1, 'cherry': 2}\nprint(sort_dict_by_value(d))\n# [('banana', 1), ('cherry', 2), ('apple', 3)]\nprint(sort_dict_by_value(d, reverse=True))\n# [('apple', 3), ('cherry', 2), ('banana', 1)]\n\nOption 2: Return a dict preserving the sorted order (Python 3.7+ preserves insertion order)\n- Use a dict comprehension around the sorted items\n\ndef sort_dict_by_value_preserving(d, reverse=False):\n    \"\"\"\n    Return a dict sorted by value (order preserved when iterating).\n    Note: Requires Python 3.7+ where dict preserves insertion order.\n    \"\"\"\n    return {k: v for k, v in sorted(d.items(), key=lambda item: item[1], reverse=reverse)}\n\n# Example\nprint(sort_dict_by_value_preserving(d))\n# {'banana': 1, 'cherry': 2, 'apple': 3}\n\nNotes:\n- Sorting is stable, so equal values preserve their original relative order.\n- If values are not comparable (e.g., mixed types), you\u2019ll get a TypeError; ensure values are comparable. \n\nIf you\u2019d like this in another language (e.g., JavaScript, Java) or need a version that keeps keys sorted by value but returns a specific type (e.g., list of keys only), tell me which language you\u2019re using."}
{"task_id": "Mbpp/459", "completion": "Here\u2019s a simple Python function. It treats \u201cuppercase substrings\u201d as runs of consecutive uppercase letters (A\u2013Z). It removes those runs from the string.\n\nASCII-only version (using regex):\n```python\nimport re\n\ndef remove_uppercase_substrings(s: str) -> str:\n    # Remove runs of one or more uppercase ASCII letters\n    return re.sub(r'[A-Z]+', '', s)\n\n\n# Example\nprint(remove_uppercase_substrings(\"abCD3EFghI\"))  # \"ab3gh\"\n```\n\nUnicode-aware version (per-character, supports non-ASCII uppercase letters as well):\n```python\ndef remove_uppercase_substrings_unicode(s: str) -> str:\n    out = []\n    i = 0\n    while i < len(s):\n        if s[i].isupper():\n            j = i\n            while j < len(s) and s[j].isupper():\n                j += 1\n            i = j  # skip the entire uppercase run\n        else:\n            out.append(s[i])\n            i += 1\n    return ''.join(out)\n\n\n# Example\nprint(remove_uppercase_substrings_unicode(\"abCD3EFghI\"))  # \"ab3gh\"\n```\n\nOptional variant: remove only uppercase runs of length at least min_len\n```python\ndef remove_uppercase_runs_of_min_len(s: str, min_len: int) -> str:\n    import re\n    return re.sub(rf'[A-Z]{{{min_len},}}', '', s)\n\n# Example (removes \"CD\" and \"EF\" but keeps \"I\")\nprint(remove_uppercase_runs_of_min_len(\"abCD3EFghI\", 2))  # \"ab3ghI\"\n```\n\nIf you want a specific behavior (e.g., preserve single uppercase letters, or support only ASCII vs Unicode), tell me and I\u2019ll tailor the function."}
{"task_id": "Mbpp/555", "completion": "Here is a concise Python function using the closed-form formulas for sums:\n\n```python\ndef diff_sum_cubes_and_numbers(n: int) -> int:\n    \"\"\"\n    Returns (sum of cubes of 1..n) - (sum of 1..n).\n    sum of 1..n = n(n+1)/2\n    sum of cubes 1..n = [n(n+1)/2]^2\n    Therefore difference = [n(n+1)/2]^2 - [n(n+1)/2]\n    \"\"\"\n    s = n * (n + 1) // 2\n    return s * s - s  # or: return s * (s - 1)\n```\n\nExample:\n- diff_sum_cubes_and_numbers(5) returns 210, since (1^3 + ... + 5^3) - (1 + ... + 5) = 225 - 15 = 210."}
{"task_id": "Mbpp/476", "completion": "Here\u2019s a simple, efficient Python function that returns the sum of the smallest and largest values in an array (or any iterable of numbers). It runs in O(n) time and O(1) extra space.\n\ndef sum_of_largest_and_smallest(arr):\n    \"\"\"\n    Return the sum of the smallest and largest elements in arr.\n    arr must be a non-empty iterable of comparable numbers.\n    \"\"\"\n    if arr is None:\n        raise ValueError(\"Input cannot be None\")\n\n    it = iter(arr)\n    try:\n        first = next(it)\n    except StopIteration:\n        raise ValueError(\"Input array must contain at least one element\")\n\n    mn = mx = first\n    for x in it:\n        if x < mn:\n            mn = x\n        elif x > mx:\n            mx = x\n    return mn + mx\n\nUsage example:\n- sum_of_largest_and_smallest([3, 1, 4, 1, 5])  # returns 8 (1 + 7? Actually 1 + 5 = 6? For this list: min=1, max=5 -> 6)\n- sum_of_largest_and_smallest([-2, -5, 0, 3])  # -5 + 3 = -2\n\nIf you don\u2019t mind two passes, a simpler (but less optimal) alternative is:\n\ndef sum_min_max(arr):\n    if not arr:\n        raise ValueError(\"Input array must contain at least one element\")\n    return min(arr) + max(arr)"}
{"task_id": "Mbpp/465", "completion": "Here is a simple Python function that returns a new dictionary with \u201cempty\u201d items dropped. By default, empty means None, empty strings/bytes, and any empty container (list, tuple, dict, set). If you want to drop all falsy values (0, False, '', etc.), you can enable that with a flag.\n\nCode:\n\ndef drop_empty_items(d: dict, drop_falsy: bool = False) -> dict:\n    \"\"\"\n    Return a new dictionary with empty items removed.\n\n    Empty meaning:\n      - None\n      - empty string or bytes\n      - empty list/tuple/dict/set\n\n    If drop_falsy is True, also drop items with falsy values (0, False, '', etc.).\n    \"\"\"\n    if drop_falsy:\n        return {k: v for k, v in d.items() if v}\n\n    def is_empty(v):\n        if v is None:\n            return True\n        if isinstance(v, (str, bytes)) and len(v) == 0:\n            return True\n        if isinstance(v, (list, tuple, dict, set)) and len(v) == 0:\n            return True\n        return False\n\n    return {k: v for k, v in d.items() if not is_empty(v)}\n\n# Example\nd = {\"a\": 1, \"b\": \"\", \"c\": [], \"d\": None, \"e\": [1, 2], \"f\": 0}\nprint(drop_empty_items(d))          # {'a': 1, 'e': [1, 2], 'f': 0}\nprint(drop_empty_items(d, True))    # {'a': 1, 'e': [1, 2], 'f': 0}\n\nIf you prefer to modify the dictionary in place, you can add a small in-place variant similarly."}
{"task_id": "Mbpp/474", "completion": "Here are simple, robust ways to replace characters in a string. I\u2019ve shown Python and JavaScript versions. They replace characters according to a mapping (one-to-one: old_char -> new_char). If you just need a single character replacement, you can use the same ideas with a trivial mapping.\n\nPython\n\n1) Single replacement:\ndef replace_char(s, old, new):\n    return s.replace(old, new)\n\n2) Multiple replacements (mapping old_char -> new_char):\ndef replace_chars(s, mapping):\n    \"\"\"\n    mapping: dict where keys are characters to replace and values are their replacements.\n    Example: {'h':'H', 'e':'3'}\n    \"\"\"\n    if not mapping:\n        return s\n    return ''.join(mapping.get(ch, ch) for ch in s)\n\n3) Using str.translate (handles many replacements efficiently; supports deletion with None):\ndef replace_chars_translate(s, mapping):\n    \"\"\"\n    mapping: dict where keys are chars to replace and values are replacement chars or None to delete.\n    Example: {'a':'@', 'e':'3', 'i': None}  -> removes 'i'\n    \"\"\"\n    trans = {ord(k): (None if v is None else ord(v)) for k, v in mapping.items()}\n    return s.translate(trans)\n\nUsage:\ns = \"hello world\"\nmapping = {'h':'H','e':'3','l':'1','o':'0'}\nprint(replace_chars(s, mapping))            # H3ll0 w0r1d\nprint(replace_chars_translate(s, mapping))  # H3ll0 w0r1d\nprint(replace_chars_translate(s, {'l': None}))  # heo wod\n\nJavaScript\n\n1) Single replacement (or multiple via a mapping object):\nfunction replaceChars(str, mapping) {\n  if (!mapping) return str;\n  return str.split('').map(ch => (ch in mapping) ? mapping[ch] : ch).join('');\n}\n\nUsage:\nconst s = \"hello world\";\nconsole.log(replaceChars(s, { h: 'H', e: '3', l: '1', o: '0' })); // H3ll0 w0r1d\n\nNotes and tips\n\n- If you only need a single character swap, you can implement it with a direct call (Python: s.replace(old, new); JavaScript: replace via a simple map with one entry).\n- If you need to remove characters, use a mapping value of None (Python) or undefined/null (JS) and adjust accordingly (Python translate supports None to delete).\n- If you want to replace substrings (not just single characters), you should use string replacement functions that operate on substrings (e.g., Python: s.replace(\"old\", \"new\"); JavaScript: str.split(old).join(new) or a loop with indexOf/replaceAll).\n- Time complexity is O(n) for processing the string of length n, with additional space for the result.\n\nIf you tell me your language preference and whether you want character-by-character replacements or substring replacements, I can tailor the function precisely."}
{"task_id": "Mbpp/559", "completion": "Here's a simple Python implementation using Kadane's algorithm to find the sum of the largest contiguous subarray. It assumes a non-empty list of integers. If the input can be empty, you can decide how you want to handle it (e.g., raise an error or return 0).\n\ndef max_subarray_sum(nums):\n    if not nums:\n        raise ValueError(\"Input list must be non-empty\")\n    current = best = nums[0]\n    for x in nums[1:]:\n        current = max(x, current + x)\n        best = max(best, current)\n    return best\n\n# Examples:\n# max_subarray_sum([1, -2, 3, 4, -1, 2, 1]) -> 9\n# max_subarray_sum([-3, -2, -5]) -> -2\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(1)\n- If you want to allow empty input and return 0 in that case, you can add a guard and/or use a variant that initializes current and best to 0 and handles negatives differently."}
{"task_id": "Mbpp/479", "completion": "Here\u2019s a simple Python function that returns the most significant (first) digit of an integer, ignoring its sign.\n\n```python\ndef first_digit(n):\n    \"\"\"\n    Return the most significant digit of an integer n (ignoring sign).\n    For n = 0, returns 0.\n    \"\"\"\n    n = abs(int(n))\n    if n == 0:\n        return 0\n    while n >= 10:\n        n //= 10\n    return n\n\n# Examples:\n# first_digit(12345) -> 1\n# first_digit(-9876) -> 9\n# first_digit(0) -> 0\n```\n\nIf you prefer a concise approach using string representation:\n\n```python\ndef first_digit_str(n):\n    s = str(abs(int(n)))\n    return int(s[0])\n```"}
{"task_id": "Mbpp/560", "completion": "Here's a simple Python function that takes two tuples, computes the union of their elements (i.e., unique elements from both), and returns them in sorted order.\n\n```python\ndef union_of_tuples(t1, t2, as_tuple=False):\n    \"\"\"\n    Return the sorted union of elements from two tuples.\n    Parameters:\n      t1, t2: input tuples\n      as_tuple: if True, return a tuple; otherwise return a list\n    \"\"\"\n    uniq = set(t1) | set(t2)\n    try:\n        sorted_list = sorted(uniq)\n    except TypeError:\n        # Fallback if elements are not directly comparable (e.g., mixed types)\n        sorted_list = sorted(uniq, key=lambda x: str(x))\n    return tuple(sorted_list) if as_tuple else sorted_list\n```\n\nUsage examples:\n\n```python\nt1 = (1, 3, 5, 3)\nt2 = (2, 3, 4)\n\nprint(union_of_tuples(t1, t2))              # [1, 2, 3, 4, 5]\nprint(union_of_tuples(t1, t2, as_tuple=True))  # (1, 2, 3, 4, 5)\n```\n\nNotes:\n- Duplicates are removed since we use a set.\n- The result is sorted. If elements can be of incompatible types for direct comparison, the function falls back to sorting by string representation."}
{"task_id": "Mbpp/556", "completion": "Here\u2019s a concise Python function. An XOR result is odd exactly when the two numbers have different parity (one even, one odd), so the count of such pairs is even_count * odd_count.\n\n```python\ndef count_odd_xor_pairs(arr):\n    even = 0\n    odd = 0\n    for x in arr:\n        if x & 1:       # odd\n            odd += 1\n        else:             # even\n            even += 1\n    return even * odd\n```\n\nUsage example:\n- arr = [1, 2, 3, 4]\n- count_odd_xor_pairs(arr) -> 4\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(1)\n- This counts unordered pairs (i < j). If you need ordered pairs (i, j) with i != j, multiply the result by 2: 2 * even * odd."}
{"task_id": "Mbpp/564", "completion": "Here's a concise Python function that counts unordered pairs with unequal elements:\n\n```python\nfrom collections import Counter\n\ndef count_unequal_pairs(arr):\n    \"\"\"\n    Count the number of unordered pairs (i, j) with i < j such that arr[i] != arr[j].\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    total_pairs = n * (n - 1) // 2  # C(n, 2)\n    freq = Counter(arr)\n    equal_pairs = sum(v * (v - 1) // 2 for v in freq.values())  # sum C(freq[v], 2)\n\n    return total_pairs - equal_pairs\n```\n\nExplanation:\n- Total unordered pairs from n elements is C(n, 2).\n- Pairs where both elements are equal are counted as sum over values of C(freq[v], 2).\n- Subtract to get the number of pairs with unequal elements.\n\nExample:\n- count_unequal_pairs([1, 1, 2, 3]) -> 3 pairs total, 1 equal pair (1,1), result 2.\n- count_unequal_pairs([1, 1, 2, 2]) -> 6 total, 2 equal pairs, result 4."}
{"task_id": "Mbpp/565", "completion": "Here\u2019s a simple Python function that splits a string into its individual characters and returns them as a list.\n\nfrom typing import List\n\ndef split_string_into_characters(s: str) -> List[str]:\n    \"\"\"\n    Split a string into its individual characters and return as a list.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return list(s)\n\nUsage:\nsplit_string_into_characters(\"hello\")  # ['h', 'e', 'l', 'l', 'o']"}
{"task_id": "Mbpp/568", "completion": "Here\u2019s a Python function that creates a list of N distinct, empty dictionaries:\n\n```python\ndef make_dicts(n):\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return [{} for _ in range(n)]\n```\n\nNotes:\n- Uses [ {} for _ in range(n) ] to ensure each dictionary is distinct.\n- make_dicts(0) returns an empty list [].\n- Do not use [{}] * n, as that would create references to the same dictionary.\n\nExample:\n- make_dicts(4) -> [{}, {}, {}, {}]\n\nIf you want it in another language, I can provide equivalent code (e.g., JavaScript, Java)."}
{"task_id": "Mbpp/562", "completion": "Here\u2019s a simple function that returns the length of the longest inner sublist. It only considers elements that are lists or tuples.\n\n```python\nfrom typing import List, Any\n\ndef longest_sublist_length(data: List[Any]) -> int:\n    \"\"\"\n    data: a list whose elements are sublists (e.g., [[1,2], [3,4,5], []])\n    Returns the length of the longest sublist. If there are no sublists, returns 0.\n    \"\"\"\n    max_len = 0\n    for sub in data:\n        if isinstance(sub, (list, tuple)):\n            max_len = max(max_len, len(sub))\n    return max_len\n\n# Example\nprint(longest_sublist_length([[1, 2], [3, 4, 5], [], [6]]))  # Output: 3\n```\n\nIf you want to allow any iterable sublist (not just lists/tuples), you can adapt it slightly:\n\n```python\ndef longest_sublist_length_any(data: List[Any]) -> int:\n    max_len = 0\n    for sub in data:\n        try:\n            max_len = max(max_len, len(sub))\n        except TypeError:\n            pass  # ignore non-iterables\n    return max_len\n```\n\nChoose the version that best fits how your data is structured."}
{"task_id": "Mbpp/558", "completion": "Here's a simple Python function that computes the sum of the absolute differences of corresponding digits, aligning by least significant digit (pads shorter numbers with leading zeros conceptually):\n\n```python\ndef sum_per_digit_difference(a, b):\n    \"\"\"\n    Return the sum of absolute differences between corresponding digits of a and b.\n    Digits are compared from least significant to most significant; shorter number is padded with zeros.\n    Works for non-negative integers (uses absolute values of inputs if negatives are provided).\n    \"\"\"\n    a = abs(int(a))\n    b = abs(int(b))\n    total = 0\n    while a > 0 or b > 0:\n        total += abs((a % 10) - (b % 10))\n        a //= 10\n        b //= 10\n    return total\n```\n\nExamples:\n- sum_per_digit_difference(1234, 567) returns 10\n  (digits: 4 vs 7 -> 3, 3 vs 6 -> 3, 2 vs 5 -> 3, 1 vs 0 -> 1; total 10)\n- sum_per_digit_difference(123, 45) returns 5\n  (3 vs 5 -> 2, 2 vs 4 -> 2, 1 vs 0 -> 1; total 5)\n\nIf you want to treat negatives differently (e.g., take sign into account per digit), you can adjust accordingly."}
{"task_id": "Mbpp/478", "completion": "Here\u2019s a simple interpretation: remove every contiguous substring consisting of ASCII lowercase letters (a-z). This leaves all non-lowercase characters (uppercase letters, digits, punctuation, etc.).\n\nPython\n- Uses a regex to drop any [a-z]+ sequence.\n- If you want to remove single lowercase letters as well, this already does that.\n\nimport re\n\ndef remove_lowercase_substrings(s: str) -> str:\n    return re.sub(r'[a-z]+', '', s)\n\n# Example\n# input:  \"aBcDeF123!\"\n# output: \"BDF123!\"\n\nJavaScript\nfunction removeLowercaseSubstrings(s) {\n  return s.replace(/[a-z]+/g, '');\n}\n\n// Example\n// removeLowercaseSubstrings(\"aBcDeF123!\") -> \"BDF123!\"\n\nJava\npublic static String removeLowercaseSubstrings(String s) {\n    return s.replaceAll(\"[a-z]+\", \"\");\n}\n\n// Example:\n// removeLowercaseSubstrings(\"aBcDeF123!\") -> \"BDF123!\"\n\nC#\nusing System.Text.RegularExpressions;\n\nstring RemoveLowercaseSubstrings(string s) {\n    return Regex.Replace(s, \"[a-z]+\", \"\");\n}\n\n// Example:\n// RemoveLowercaseSubstrings(\"aBcDeF123!\") -> \"BDF123!\"\n\nC++\n#include <string>\n#include <regex>\n\nstd::string removeLowercaseSubstrings(const std::string& s) {\n    static const std::regex re(\"[a-z]+\");\n    return std::regex_replace(s, re, \"\");\n}\n\n// Example:\n// removeLowercaseSubstrings(\"aBcDeF123!\") -> \"BDF123!\"\n\nNotes:\n- These examples target ASCII lowercase letters a\u2013z. If you need Unicode-aware lowercase removal, you may need language-specific options (e.g., Unicode-aware character classes) or a regex engine that supports \\p{Ll} or equivalent.\n- If you only want to remove single lowercase characters (not contiguous runs), you can use [a-z] instead of [a-z]+ in the regex."}
{"task_id": "Mbpp/567", "completion": "Here\u2019s a simple Python function that checks whether a list is sorted. It supports ascending or descending order and can enforce strict (no duplicates) or non-strict sorting.\n\ndef is_sorted(lst, mode='ascending', strict=False):\n    \"\"\"\n    Check if the list is sorted.\n\n    Parameters:\n    - lst: list of comparable elements\n    - mode: 'ascending' or 'descending'\n    - strict: True for strictly increasing/decreasing, False for non-strict\n\n    Returns:\n    - True if sorted according to the specified mode and strictness, else False\n    \"\"\"\n    n = len(lst)\n    if n < 2:\n        return True  # empty or single-element lists are sorted\n\n    if mode == 'ascending':\n        if strict:\n            return all(lst[i] < lst[i+1] for i in range(n - 1))\n        else:\n            return all(lst[i] <= lst[i+1] for i in range(n - 1))\n    elif mode == 'descending':\n        if strict:\n            return all(lst[i] > lst[i+1] for i in range(n - 1))\n        else:\n            return all(lst[i] >= lst[i+1] for i in range(n - 1))\n    else:\n        raise ValueError(\"mode must be 'ascending' or 'descending'\")\n\nUsage examples:\n- is_sorted([1, 2, 3, 3, 4]) -> True\n- is_sorted([3, 2, 1], mode='descending') -> True\n- is_sorted([1, 2, 2, 1], mode='ascending') -> False\n- is_sorted([1, 2, 3], mode='ascending', strict=True) -> False\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(1)\n- Empty lists or single-element lists are considered sorted."}
{"task_id": "Mbpp/566", "completion": "Here are simple implementations to compute the sum of digits of a non-negative integer in a few common languages. If you want a different language or want a purely functional version, tell me.\n\nPython (numeric, iterative)\ndef sum_digits(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    s = 0\n    while n:\n        s += n % 10\n        n //= 10\n    return s\n\nPython (string-based)\ndef sum_digits(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return sum(int(ch) for ch in str(n))\n\nJavaScript\nfunction sumDigits(n) {\n  if (n < 0 || !Number.isInteger(n)) {\n    throw new Error(\"n must be a non-negative integer\");\n  }\n  let sum = 0;\n  if (n === 0) return 0;\n  while (n > 0) {\n    sum += n % 10;\n    n = Math.floor(n / 10);\n  }\n  return sum;\n}\n\nJava\npublic static int sumDigits(int n) {\n    if (n < 0) throw new IllegalArgumentException(\"n must be non-negative\");\n    int sum = 0;\n    while (n > 0) {\n        sum += n % 10;\n        n /= 10;\n    }\n    return sum;\n}\n\nC (unsigned int)\nunsigned int sum_digits(unsigned int n) {\n    unsigned int sum = 0;\n    do {\n        sum += n % 10;\n        n /= 10;\n    } while (n != 0);\n    return sum;\n}\n\nNotes:\n- Time complexity is O(d), where d is the number of digits.\n- Handles 0 correctly (returns 0).\n- If you want a version without input validation, I can provide that as well. Also tell me your preferred language if you want a single snippet."}
{"task_id": "Mbpp/468", "completion": "Here's a Python function that finds the maximum product formed by multiplying numbers of an increasing subsequence (strictly increasing by value) of the given array.\n\nIdea:\n- For each index i, keep two values:\n  - dpMax[i]: maximum product of an increasing subsequence that ends at i (including a[i]).\n  - dpMin[i]: minimum product of an increasing subsequence that ends at i (including a[i]).\n- Initialize both with a[i].\n- For every j < i with a[j] < a[i], extend subsequences ending at j by a[i]:\n  - candMax = max(dpMax[j] * a[i], dpMin[j] * a[i])\n  - candMin = min(dpMax[j] * a[i], dpMin[j] * a[i])\n  - Update dpMax[i] and dpMin[i] accordingly.\n- The answer is the maximum of dpMax[i] over all i.\n\nTime complexity: O(n^2)\nSpace complexity: O(n)\n\nCode (Python):\n\n```python\ndef max_product_increasing_subsequence(arr):\n    \"\"\"\n    Returns the maximum product obtainable by multiplying numbers\n    of an increasing subsequence (strictly increasing by value) of arr.\n    If arr is empty, returns 0.\n    \"\"\"\n    n = len(arr)\n    if n == 0:\n        return 0\n\n    dpMax = arr[:]  # max product ending at i\n    dpMin = arr[:]  # min product ending at i\n    ans = arr[0]\n\n    for i in range(n):\n        for j in range(i):\n            if arr[j] < arr[i]:\n                prodMax = dpMax[j] * arr[i]\n                prodMin = dpMin[j] * arr[i]\n                candMax = max(prodMax, prodMin)\n                candMin = min(prodMax, prodMin)\n                if candMax > dpMax[i]:\n                    dpMax[i] = candMax\n                if candMin < dpMin[i]:\n                    dpMin[i] = candMin\n        if dpMax[i] > ans:\n            ans = dpMax[i]\n\n    return ans\n```\n\nExamples:\n- max_product_increasing_subsequence([3, 4, 2, 5]) returns 60 (subsequence [3, 4, 5]).\n- max_product_increasing_subsequence([-1, -2, -3, 4]) returns 4 (subsequence [4] or [-1, 4] gives  -4 though; best is 4).\n- max_product_increasing_subsequence([]) returns 0."}
{"task_id": "Mbpp/577", "completion": "Here's a simple Python function. It uses the fact that for n >= 5, n! ends with 0, so the last digit is 0. For smaller n, it computes the last digit directly.\n\n```python\ndef last_digit_of_factorial(n: int) -> int:\n    \"\"\"\n    Return the last decimal digit of n! (n factorial).\n    Works for non-negative integers n. For n >= 5, the last digit is 0.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    if n >= 5:\n        return 0\n    res = 1\n    for i in range(2, n + 1):\n        res = (res * i) % 10\n    return res\n\n# Examples\nprint(last_digit_of_factorial(0))  # 1\nprint(last_digit_of_factorial(3))  # 6\nprint(last_digit_of_factorial(5))  # 0\n```"}
{"task_id": "Mbpp/576", "completion": "Here\u2019s a simple function to check if one list is a contiguous sublist (i.e., a subsequence that appears as a consecutive block) inside another list.\n\nCode:\n\ndef is_sublist(sub, main):\n    \"\"\"\n    Return True if 'sub' is a contiguous sublist of 'main'.\n    Empty 'sub' is considered a sublist of any list.\n    \"\"\"\n    if not isinstance(sub, list) or not isinstance(main, list):\n        raise TypeError(\"Both arguments must be lists\")\n    if not sub:\n        return True\n    if len(sub) > len(main):\n        return False\n\n    m = len(sub)\n    for i in range(len(main) - m + 1):\n        if main[i:i+m] == sub:\n            return True\n    return False\n\nUsage examples:\n- is_sublist([2, 3], [1, 2, 3, 4]) -> True\n- is_sublist([2, 4], [1, 2, 3, 4]) -> False\n- is_sublist([], [1, 2, 3]) -> True\n\nIf you instead want to check for a non-contiguous subsequence (i.e., the elements appear in order but not necessarily contiguously), you can use this version:\n\ndef is_subsequence(sub, main):\n    \"\"\"\n    Return True if 'sub' is a non-contiguous subsequence of 'main' (order matters).\n    \"\"\"\n    if not sub:\n        return True\n    it = iter(main)\n    for x in sub:\n        found = False\n        for y in it:\n            if y == x:\n                found = True\n                break\n        if not found:\n            return False\n    return True\n\nThis checks for the same order but allows gaps."}
{"task_id": "Mbpp/569", "completion": "Here's a simple Python function that sorts each sublist of strings and returns a new list (without mutating the original):\n\ndef sort_sublists_of_strings(list_of_lists, reverse=False):\n    \"\"\"\n    Given a list of lists of strings, return a new list\n    where each sublist is sorted lexicographically.\n\n    Parameters:\n    - list_of_lists: List[List[str]]\n    - reverse: bool (optional) to sort in reverse order\n\n    Returns:\n    - List[List[str]]\n    \"\"\"\n    return [sorted(sub, reverse=reverse) for sub in list_of_lists]\n\nExample:\nlst = [[\"banana\", \"apple\", \"cherry\"], [\"dog\", \"cat\"], [], [\"zebra\", \"yak\"]]\nprint(sort_sublists_of_strings(lst))\n# Output: [['apple', 'banana', 'cherry'], ['cat', 'dog'], [], ['yak', 'zebra']]\n\nIf you prefer to sort the sublists in place (modifying the original lists), you can use:\n\ndef sort_sublists_in_place(list_of_lists, reverse=False):\n    \"\"\"\n    Sort each sublist in place (mutates the input).\n\n    Parameters:\n    - list_of_lists: List[List[str]]\n    - reverse: bool (optional) to sort in reverse order\n    \"\"\"\n    for sub in list_of_lists:\n        sub.sort(reverse=reverse)\n\nExample:\nlst = [[\"banana\", \"apple\", \"cherry\"], [\"dog\", \"cat\"]]\nsort_sublists_in_place(lst)\nprint(lst)\n# Output: [['apple', 'banana', 'cherry'], ['cat', 'dog']]\n\nNotes:\n- These assume each sublist contains strings. If needed, you can adapt the key function (e.g., case-insensitive sort with key=str.lower) by passing a key to sorted/subsort."}
{"task_id": "Mbpp/578", "completion": "Here\u2019s a concise Python function that interleaves three lists of the same length into a flat list.\n\n```python\ndef interleave3(a, b, c):\n    if not (len(a) == len(b) == len(c)):\n        raise ValueError(\"All input lists must have the same length.\")\n    return [x for t in zip(a, b, c) for x in t]\n```\n\nExample:\n- a = [1, 2, 3]\n- b = [10, 20, 30]\n- c = [100, 200, 300]\n\ninterleave3(a, b, c) -> [1, 10, 100, 2, 20, 200, 3, 30, 300]\n\nNotes:\n- Time complexity: O(n)\n- Space complexity: O(n)\n- If you prefer, you can implement it with itertools.chain: return list(chain.from_iterable(zip(a, b, c))) after the same length check."}
{"task_id": "Mbpp/581", "completion": "Here's a simple Python function to compute the surface area of a square pyramid given the base edge (b) and the vertical height (h).\n\n```python\nimport math\n\ndef square_pyramid_surface_area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid.\n\n    Parameters:\n    - base_edge: length of the square base edge (b)\n    - height: vertical height from base to apex (h)\n\n    Returns:\n    - Total surface area: base area + lateral area\n    \"\"\"\n    if base_edge <= 0 or height <= 0:\n        raise ValueError(\"base_edge and height must be positive numbers.\")\n\n    # Slant height: l = sqrt(h^2 + (b/2)^2)\n    slant_height = math.sqrt(height**2 + (base_edge / 2.0) ** 2)\n\n    # Base area: b^2\n    # Lateral area: 4 * (1/2 * b * l) = 2 * b * l\n    surface_area = base_edge ** 2 + 2.0 * base_edge * slant_height\n    return surface_area\n```\n\nExample usage:\n- square_pyramid_surface_area(4, 6)  # returns the total surface area for base edge 4 and height 6."}
{"task_id": "Mbpp/563", "completion": "Sure. A quick clarification would help, but here are ready-to-use implementations in two common languages. Both extract the text inside single or double quotes and handle escaped quotes.\n\nPython (robust, handles escapes, both ' and \"):\ndef extract_quoted_values(s):\n    \"\"\"\n    Return a list of strings found inside single or double quotes in s.\n    Escaped quotes (e.g., \\\" or \\') are treated as literal characters.\n    \"\"\"\n    results = []\n    i = 0\n    n = len(s)\n    while i < n:\n        ch = s[i]\n        if ch == '\"' or ch == \"'\":\n            quote = ch\n            i += 1\n            cur = []\n            while i < n:\n                c = s[i]\n                if c == '\\\\':\n                    if i + 1 < n:\n                        # take the next char as the escaped character\n                        cur.append(s[i + 1])\n                        i += 2\n                        continue\n                    else:\n                        i += 1\n                        continue\n                if c == quote:\n                    i += 1\n                    break\n                cur.append(c)\n                i += 1\n            results.append(''.join(cur))\n        else:\n            i += 1\n    return results\n\nExample:\ns = 'He said \"Hello, \\\\\"world\\\\\"!\" and \\'Bye\\''\nprint(extract_quoted_values(s))\n# ['Hello, \"world\"!', 'Bye']\n\nJavaScript (robust, handles escapes, both ' and \"):\nfunction extractQuotedValues(str) {\n  const results = [];\n  let i = 0;\n  while (i < str.length) {\n    const ch = str[i];\n    if (ch === '\"' || ch === \"'\") {\n      const quote = ch;\n      i++;\n      let current = '';\n      while (i < str.length) {\n        const c = str[i];\n        if (c === '\\\\') {\n          if (i + 1 < str.length) {\n            current += str[i + 1]; // unescape next character\n            i += 2;\n            continue;\n          } else {\n            i++;\n            continue;\n          }\n        }\n        if (c === quote) {\n          i++;\n          break;\n        }\n        current += c;\n        i++;\n      }\n      results.push(current);\n    } else {\n      i++;\n    }\n  }\n  return results;\n}\n\nExample:\nconst s = 'He said \"Hello, \\\\\"world\\\\\"!\" and \\\\'Bye\\\\'';\nconsole.log(extractQuotedValues(s));\n// [\"Hello, \\\"world\\\"!\", \"Bye\"]\n\nIf you just need a quick, simpler solution (no escaping), you can use a regex. Note: this is less robust for escaped quotes.\n\n- Python simple (double quotes only, no escapes):\nimport re\ndef extract_quoted_values_simple(s):\n    return re.findall(r'\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"', s)\n\n- JavaScript simple (double quotes only, no escapes):\nfunction extractQuotedSimple(s) {\n  const m = [];\n  const re = /\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\"/g;\n  let match;\n  while ((match = re.exec(s)) !== null) m.push(match[1]);\n  return m;\n}\n\nIf you tell me your preferred language and any edge cases (e.g., only double quotes, or nested quotes, or handling of escapes), I can tailor the function precisely."}
{"task_id": "Mbpp/587", "completion": "Here\u2019s a simple Python function that converts a list to a tuple:\n\ndef list_to_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n    \"\"\"\n    return tuple(lst)\n\nNotes:\n- tuple(lst) converts any iterable (not just lists) to a tuple.\n- This is a shallow conversion: if the list contains mutable objects, they are not deep-copied.\n\nExamples:\n- list_to_tuple([1, 2, 3]) -> (1, 2, 3)\n- list_to_tuple(['a', 'b', 'c']) -> ('a', 'b', 'c')"}
{"task_id": "Mbpp/583", "completion": "Here are two Python implementations to return the nth Catalan number (n >= 0).\n\n1) O(n^2) dynamic programming (easy to understand)\ndef catalan_dp(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    cat = [0] * (n + 1)\n    cat[0] = 1\n    for i in range(1, n + 1):\n        s = 0\n        for j in range(i):\n            s += cat[j] * cat[i - 1 - j]\n        cat[i] = s\n    return cat[n]\n\n2) O(n) using the binomial coefficient (more efficient for large n)\ndef catalan(n: int) -> int:\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    c = 1  # binomial(2n, n)\n    for i in range(1, n + 1):\n        c = c * (n + i) // i\n    return c // (n + 1)\n\nExamples:\n- catalan_dp(5) -> 42\n- catalan(5) -> 42\n- catalan(0) -> 1\n\nIf you tell me your preferred language, I can provide a version in that language too."}
{"task_id": "Mbpp/573", "completion": "Here are two interpretations and corresponding implementations. Choose the one that matches your meaning of \u201cunique\u201d.\n\n1) Product of distinct (unique by value) numbers in the list\n- Duplicates are ignored; multiply each distinct value once.\n\ndef product_of_unique_numbers(numbers):\n    \"\"\"\n    Return the product of the distinct values in 'numbers'.\n    If 'numbers' is empty, returns 1.\n    \"\"\"\n    if numbers is None:\n        raise ValueError(\"numbers must be an iterable of numbers\")\n\n    unique_vals = set(numbers)  # distinct values\n    prod = 1\n    for v in unique_vals:\n        prod *= v\n    return prod\n\n2) Product of numbers that appear exactly once in the list\n- Only those values with frequency 1 are multiplied.\n\ndef product_of_numbers_with_single_occurrence(numbers):\n    \"\"\"\n    Return the product of numbers that occur exactly once in the list.\n    If none occur exactly once, returns 1 (empty product).\n    \"\"\"\n    from collections import Counter\n\n    counts = Counter(numbers)\n    prod = 1\n    for val, cnt in counts.items():\n        if cnt == 1:\n            prod *= val\n    return prod\n\nNotes:\n- Both functions assume the input is a list/iterable of hashable numbers (ints, floats, etc.). If non-hashable elements are included, the first function will raise a TypeError when creating the set."}
{"task_id": "Mbpp/588", "completion": "Here\u2019s a simple Python function that returns the difference between the largest and smallest values in a list. It raises an error if the list is empty.\n\n```python\ndef diff_max_min(nums):\n    if nums is None or len(nums) == 0:\n        raise ValueError(\"Input list must contain at least one number\")\n    \n    min_val = max_val = nums[0]\n    for x in nums[1:]:\n        if x < min_val:\n            min_val = x\n        elif x > max_val:\n            max_val = x\n    return max_val - min_val\n```\n\nExample:\n- diff_max_min([3, 7, 2, 9]) -> 9 - 2 = 7\n- diff_max_min([5, 5, 5]) -> 0\n\nIf you prefer a shorter version using built-ins (no explicit empty-checking), you can do:\n\n```python\ndef diff_max_min_simple(nums):\n    if not nums:\n        raise ValueError(\"Input list must contain at least one number\")\n    return max(nums) - min(nums)\n```"}
{"task_id": "Mbpp/572", "completion": "Here\u2019s a Python function that removes duplicates from multiple lists. It supports two modes:\n\n- per_list: remove duplicates inside each sublist independently (preserves order).\n- across: remove duplicates globally across all sublists (preserves the first occurrence order and applies per sublist structure).\n\nNote: elements must be hashable (numbers work fine).\n\nCode:\n\n```python\ndef remove_duplicates_from_lists(lists, mode='per_list'):\n    \"\"\"\n    Remove duplicates from a list of lists.\n\n    Args:\n        lists: Iterable of iterables (list of lists) containing hashable numbers.\n        mode: 'per_list' to dedupe within each sublist independently,\n              'across' to dedupe across all sublists while preserving per-sublist structure.\n\n    Returns:\n        A new list of lists with duplicates removed according to mode.\n    \"\"\"\n    if mode == 'per_list':\n        # Deduplicate each sublist individually, preserving order\n        return [list(dict.fromkeys(sub)) for sub in lists]\n    elif mode == 'across':\n        # Deduplicate globally, preserving first-time appearances across all sublists\n        seen = set()\n        result = []\n        for sub in lists:\n            new_sub = []\n            for x in sub:\n                if x not in seen:\n                    seen.add(x)\n                    new_sub.append(x)\n            result.append(new_sub)\n        return result\n    else:\n        raise ValueError(\"mode must be 'per_list' or 'across'\")\n\n# Example usage\nif __name__ == \"__main__\":\n    lists = [[1, 2, 2, 3], [3, 4, 4, 5], [5, 6, 6]]\n    print(remove_duplicates_from_lists(lists, mode='per_list'))  # [[1, 2, 3], [3, 4, 5], [5, 6]]\n    print(remove_duplicates_from_lists(lists, mode='across'))    # [[1, 2, 3], [4, 5], [6]]\n```\n\nIf you have a different interpretation (e.g., you want to flatten all numbers and then deduplicate or you want to preserve the total count of lists but with globally removed duplicates), tell me and I\u2019ll tailor the function."}
{"task_id": "Mbpp/557", "completion": "Here are simple implementations in a few common languages. The idea is to swap uppercase to lowercase and vice versa; non-letter characters are left unchanged.\n\nPython\n- Using the built-in swapcase (handles Unicode robustly)\ndef toggle_case(s: str) -> str:\n    return s.swapcase()\n\nprint(toggle_case(\"Hello, World! 123\"))  # hELLO, wORLD! 123\n\nJavaScript (ASCII-safe version)\n- Only swaps A-Za-z, leaving other characters unchanged\nfunction toggleCase(str) {\n  let out = '';\n  for (let ch of str) {\n    if (ch >= 'a' && ch <= 'z') {\n      out += ch.toUpperCase();\n    } else if (ch >= 'A' && ch <= 'Z') {\n      out += ch.toLowerCase();\n    } else {\n      out += ch;\n    }\n  }\n  return out;\n}\n\nconsole.log(toggleCase(\"Hello, World! 123\")); // hELLO, wORLD! 123\n\nGo\npackage main\n\nimport (\n  \"fmt\"\n  \"unicode\"\n)\n\nfunc ToggleCase(s string) string {\n  var r []rune\n  for _, ch := range s {\n    if unicode.IsUpper(ch) {\n      r = append(r, unicode.ToLower(ch))\n    } else if unicode.IsLower(ch) {\n      r = append(r, unicode.ToUpper(ch))\n    } else {\n      r = append(r, ch)\n    }\n  }\n  return string(r)\n}\n\nfunc main() {\n  fmt.Println(ToggleCase(\"Hello, \u4e16\u754c\")) // hELLO, \u4e16\u754c\n}\n\nJava\npublic static String toggleCase(String s) {\n  StringBuilder sb = new StringBuilder(s.length());\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    if (Character.isUpperCase(c)) {\n      sb.append(Character.toLowerCase(c));\n    } else if (Character.isLowerCase(c)) {\n      sb.append(Character.toUpperCase(c));\n    } else {\n      sb.append(c);\n    }\n  }\n  return sb.toString();\n}\n\nTime complexity: O(n) time, O(n) extra space, where n is the length of the string."}
{"task_id": "Mbpp/591", "completion": "Here are two common approaches.\n\nIn-place version (mutates the input list):\ndef swap_first_last_inplace(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if len(lst) < 2:\n        return\n    lst[0], lst[-1] = lst[-1], lst[0]\n\nNon-destructive version (returns a new list):\ndef interchange_first_last(lst):\n    \"\"\"\n    Return a new list with the first and last elements swapped.\n    If the list has fewer than 2 elements, return a shallow copy.\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if len(lst) < 2:\n        return lst.copy()\n    new_list = lst.copy()\n    new_list[0], new_list[-1] = new_list[-1], new_list[0]\n    return new_list\n\nExample:\nlst = [1, 2, 3, 4]\nprint(interchange_first_last(lst))  # [4, 2, 3, 1]\nswap_first_last_inplace(lst)\nprint(lst)  # [4, 2, 3, 1]"}
{"task_id": "Mbpp/589", "completion": "Here's a Python function that finds all perfect squares in the inclusive range [a, b]. It handles any order of a and b and works even if the range includes negative numbers (since negative numbers can\u2019t be perfect squares, only non-negative squares are returned).\n\n```python\nimport math\n\ndef perfect_squares_in_range(a, b):\n    \"\"\"\n    Return a list of all perfect squares in the inclusive range [a, b].\n    Assumes a and b are integers. If a > b, the function swaps them.\n    \"\"\"\n    if a > b:\n        a, b = b, a\n    if b < 0:\n        return []\n\n    start = math.ceil(math.sqrt(max(a, 0)))\n    end = math.floor(math.sqrt(b))\n\n    if end < start:\n        return []\n\n    return [i * i for i in range(start, end + 1)]\n```\n\nExamples:\n- perfect_squares_in_range(3, 50) -> [4, 9, 16, 25, 36, 49]\n- perfect_squares_in_range(-10, 5) -> [0, 1, 4]\n- perfect_squares_in_range(25, 25) -> [25]\n\nNotes:\n- Complexity: O(sqrt(b)) time and O(1) extra space (besides the output list).\n- If you want to lazily iterate, you can convert the return into a generator using yield."}
{"task_id": "Mbpp/590", "completion": "Here are simple implementations in a few popular languages. The core idea is x = r * cos(theta) and y = r * sin(theta). Theta is assumed to be in radians by default; set degrees=True (or the equivalent) if your angle is in degrees.\n\n- Python\n  - Code:\n    import math\n\n    def polar_to_cartesian(r, theta, degrees=False):\n        \"\"\"\n        Convert polar (r, theta) to Cartesian (x, y).\n        theta is in radians by default. If degrees=True, theta is in degrees.\n        Returns a tuple (x, y).\n        \"\"\"\n        if degrees:\n            theta = math.radians(theta)\n        x = r * math.cos(theta)\n        y = r * math.sin(theta)\n        return x, y\n\n- JavaScript\n  - Code:\n    function polarToCartesian(r, theta, degrees = false) {\n        if (degrees) {\n            theta = theta * Math.PI / 180;\n        }\n        const x = r * Math.cos(theta);\n        const y = r * Math.sin(theta);\n        return { x, y };\n    }\n\n- C++\n  - Code:\n    #include <cmath>\n    #include <utility>\n\n    std::pair<double, double> polarToCartesian(double r, double theta, bool degrees = false) {\n        if (degrees) theta = theta * M_PI / 180.0;\n        double x = r * std::cos(theta);\n        double y = r * std::sin(theta);\n        return std::make_pair(x, y);\n    }\n\nNotes:\n- Negative r values are handled naturally: x = r cos(theta), y = r sin(theta).\n- If your theta is already in radians, you can omit the degrees parameter or set it to false. If using degrees, convert with a radians helper as shown."}
{"task_id": "Mbpp/602", "completion": "Here's a simple Python function that returns the first character that repeats when scanning the string from left to right. If no character repeats, it returns None.\n\n```python\ndef first_repeated_character(s: str):\n    \"\"\"\n    Return the first character that repeats in s when scanned left-to-right.\n    If no repetition exists, return None.\n    \"\"\"\n    seen = set()\n    for ch in s:\n        if ch in seen:\n            return ch\n        seen.add(ch)\n    return None\n```\n\nExamples:\n- first_repeated_character(\"abcbd\") -> 'b'\n- first_repeated_character(\"abcdef\") -> None"}
{"task_id": "Mbpp/596", "completion": "Here\u2019s a Python approach that returns the total memory footprint in bytes for a given tuple, including the memory used by its contents (recursively). Note that sys.getsizeof(obj) only reports the size of the object itself, not the objects it contains, so we walk the structure.\n\nCode:\n\nimport sys\n\ndef total_size(obj, seen=None):\n    if seen is None:\n        seen = set()\n    obj_id = id(obj)\n    if obj_id in seen:\n        return 0\n    seen.add(obj_id)\n\n    size = sys.getsizeof(obj)\n\n    if isinstance(obj, dict):\n        for k, v in obj.items():\n            size += total_size(k, seen)\n            size += total_size(v, seen)\n    elif isinstance(obj, (list, tuple, set, frozenset)):\n        for item in obj:\n            size += total_size(item, seen)\n    return size\n\ndef size_of_tuple(t):\n    if not isinstance(t, tuple):\n        raise TypeError(\"size_of_tuple expects a tuple\")\n    return total_size(t)\n\nUsage:\n\nt = (1, \"hello\", [2, 3], (4, 5))\nprint(size_of_tuple(t))  # total size in bytes, including contents\n\nNotes:\n- If you only want the size of the tuple object itself (not its contents), use sys.getsizeof(t).\n- This function handles nested structures and avoids double-counting via a seen set. It can still be imperfect for extremely complex graphs or if you need exact platform-specific memory accounting, but it works well for common cases."}
{"task_id": "Mbpp/586", "completion": "Here's a simple Python function that splits a list at index n and moves the first part to the end (i.e., a left rotation by n). It clamps n to the range [0, len(lst)].\n\ndef rotate_split(lst, n):\n    \"\"\"\n    Split the list at index n and move the first n elements to the end.\n    Returns a new list.\n    - lst: list to operate on\n    - n: index at which to split (0 <= n <= len(lst); values outside are clamped)\n    \"\"\"\n    if not isinstance(lst, list):\n        raise TypeError(\"lst must be a list\")\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if n < 0:\n        n = 0\n    if n > len(lst):\n        n = len(lst)\n    return lst[n:] + lst[:n]\n\n# Examples\nprint(rotate_split([1, 2, 3, 4, 5], 2))  # [3, 4, 5, 1, 2]\nprint(rotate_split(['a', 'b', 'c'], 0))   # ['a', 'b', 'c']\nprint(rotate_split([1, 2, 3], 3))         # [1, 2, 3]\n\nNote: n is 0-based. If you want a 1-based split, you can call rotate_split(lst, max(0, min(n-1, len(lst)))) or adjust the logic accordingly."}
{"task_id": "Mbpp/600", "completion": "Here's a simple Python function to check if a number is even:\n\n```python\ndef is_even(n: int) -> bool:\n    \"\"\"Return True if n is even, False otherwise. n must be an integer.\"\"\"\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    return n % 2 == 0\n\n# Examples\nprint(is_even(4))  # True\nprint(is_even(7))  # False\nprint(is_even(-2)) # True\n```\n\nNotes:\n- It returns True for even numbers (including 0 and negative even numbers) and False for odd numbers.\n- It raises a TypeError if a non-integer is passed. If you want a more flexible version, you can relax the type check."}
{"task_id": "Mbpp/593", "completion": "Here is a simple IPv4-only implementation that strips leading zeros from each octet.\n\nPython version:\n```python\ndef remove_leading_zeros_ipv4(ip: str) -> str:\n    ip = ip.strip()\n    parts = ip.split('.')\n    if len(parts) != 4:\n        raise ValueError(\"Invalid IPv4 address\")\n    cleaned = []\n    for part in parts:\n        if part == \"\" or not part.isdigit():\n            raise ValueError(\"Invalid IPv4 octet\")\n        cleaned.append(str(int(part)))  # int() removes leading zeros\n    return '.'.join(cleaned)\n\n# Examples:\n# remove_leading_zeros_ipv4(\"192.168.001.001\") -> \"192.168.1.1\"\n# remove_leading_zeros_ipv4(\"000.000.000.000\") -> \"0.0.0.0\"\n```\n\nJavaScript version (ECMAScript 2015+):\n```javascript\nfunction removeLeadingZerosIPv4(ip) {\n  const parts = ip.trim().split('.');\n  if (parts.length !== 4) {\n    throw new Error('Invalid IPv4 address');\n  }\n  const cleaned = parts.map(p => {\n    if (!/^\\d+$/.test(p)) throw new Error('Invalid octet');\n    return String(parseInt(p, 10)); // parses as decimal, removes leading zeros\n  });\n  return cleaned.join('.');\n}\n\n// Examples:\n // removeLeadingZerosIPv4(\"192.168.001.001\") -> \"192.168.1.1\"\n // removeLeadingZerosIPv4(\"000.000.000.000\") -> \"0.0.0.0\"\n```\n\nNotes:\n- This targets IPv4 addresses. For IPv6, a similar approach would remove leading zeros from each hextet, but canonical IPv6 forms often use zero compression.\n- If input validation should be relaxed (e.g., return the original string on invalid input), you can modify the function to return ip on error instead of raising."}
{"task_id": "Mbpp/598", "completion": "An Armstrong (narcissistic) number is a number that is the sum of its own digits each raised to the power of the number of digits.\n\nHere\u2019s a simple Python function:\n\ndef is_armstrong(n):\n    if n < 0:\n        return False  # Armstrong numbers are non-negative\n    s = str(n)\n    k = len(s)\n    total = sum(int(ch) ** k for ch in s)\n    return total == n\n\n# Examples\nprint(is_armstrong(153))  # True  -> 1^3 + 5^3 + 3^3 = 153\nprint(is_armstrong(9474)) # True  -> 9^4 + 4^4 + 7^4 + 4^4 = 9474\nprint(is_armstrong(123))  # False\nprint(is_armstrong(0))    # True  -> 0^1 = 0\n\nNotes:\n- Works for non-negative integers; negative numbers return False.\n- Time complexity is O(d), where d is the number of digits."}
{"task_id": "Mbpp/594", "completion": "Here\u2019s a simple Python function that returns the difference between the first even and the first odd number in a list. It returns None if the list doesn\u2019t contain both an even and an odd number. It also supports returning the absolute difference if you prefer.\n\n```python\nfrom typing import List, Optional\n\ndef first_even_odd_difference(nums: List[int], absolute: bool = False) -> Optional[int]:\n    \"\"\"\n    Returns the difference between the first even and the first odd number in nums.\n    - If absolute is False (default): returns first_even - first_odd.\n    - If absolute is True: returns abs(first_even - first_odd).\n    - If there is no even or no odd number, returns None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n\n    for x in nums:\n        if first_even is None and x % 2 == 0:\n            first_even = x\n        if first_odd is None and x % 2 != 0:\n            first_odd = x\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is None or first_odd is None:\n        return None\n\n    diff = first_even - first_odd\n    return abs(diff) if absolute else diff\n```\n\nUsage examples:\n- first_even_odd_difference([3, 4, 7, 8]) -> 1\n- first_even_odd_difference([3, 4, 7, 8], absolute=True) -> 1\n- first_even_odd_difference([2, 4, 6]) -> None\n\nIf you\u2019d like this in another language (e.g., JavaScript, Java, C++), tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/599", "completion": "Here\u2019s a simple function idea using the closed-form formulas:\n- Sum of first n natural numbers: sum = n*(n+1)/2\n- Average: average = sum / n = (n+1)/2\n\nPython\ndef sum_and_avg_first_n(n):\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    s = n * (n + 1) // 2\n    avg = s / n\n    return s, avg  # returns (sum, average)\n\nJavaScript\nfunction sumAndAvgFirstN(n) {\n  if (!Number.isInteger(n) || n < 1) {\n    throw new Error(\"n must be a positive integer\");\n  }\n  const sum = (n * (n + 1)) / 2;\n  const avg = sum / n;\n  return { sum, average: avg };\n}\n\nJava\npublic class SumAvg {\n  public static class Result {\n    public final long sum;\n    public final double average;\n    public Result(long sum, double average) { this.sum = sum; this.average = average; }\n  }\n\n  public static Result sumAndAvgFirstN(int n) {\n    if (n < 1) throw new IllegalArgumentException(\"n must be >= 1\");\n    long sum = (long) n * (n + 1) / 2;\n    double avg = sum / (double) n;\n    return new Result(sum, avg);\n  }\n}\n\nC++\n#include <utility>\n#include <stdexcept>\n\nstd::pair<long long, double> sumAndAvgFirstN(long long n) {\n    if (n < 1) throw std::invalid_argument(\"n must be >= 1\");\n    long long sum = n * (n + 1) / 2;\n    double avg = static_cast<double>(sum) / n;\n    return std::make_pair(sum, avg);\n}\n\nNotes\n- All versions assume n >= 1 (first n natural numbers). If you need to handle n <= 0 differently, adjust accordingly.\n- For large n, use 64-bit integers (long long / Python int) to avoid overflow."}
{"task_id": "Mbpp/604", "completion": "Here\u2019s a simple approach assuming you want the words in reverse order (not reversing each word) and you want to treat one or more spaces as separators.\n\nPython version:\n- Reverses the word order and collapses multiple spaces into a single space.\n\ndef reverse_words(s):\n    return ' '.join(s.split()[::-1])\n\nIf you want to preserve the original spacing, or handle only single spaces as separators, let me know and I can adjust.\n\nJavaScript version:\nfunction reverseWords(str) {\n  return str.trim().split(/\\s+/).reverse().join(' ');\n}\n\nIf you\u2019d like examples in another language (Java, C++, etc.), tell me which one you prefer."}
{"task_id": "Mbpp/597", "completion": "Here is a Python function that finds the k-th smallest element from two sorted arrays without merging them. It uses a binary-search-like approach to discard parts of the arrays, giving O(log k) time and O(1) extra space.\n\ndef kth_of_two_sorted(A, B, k):\n    \"\"\"\n    Return the k-th smallest element (1-based) in the merged sorted array of A and B\n    without merging. A and B are sorted in non-decreasing order.\n    \"\"\"\n    if k < 1 or k > len(A) + len(B):\n        raise ValueError(\"k out of bounds\")\n\n    ia, ib = 0, 0  # current starts in A and B\n\n    while True:\n        # If A is exhausted, return from B\n        if ia >= len(A):\n            return B[ib + k - 1]\n        # If B is exhausted, return from A\n        if ib >= len(B):\n            return A[ia + k - 1]\n        # If k is 1, return the minimum of current elements\n        if k == 1:\n            return min(A[ia], B[ib])\n\n        # Discard roughly k/2 elements from one of the arrays\n        step = k // 2\n        new_ia = min(ia + step, len(A)) - 1\n        new_ib = min(ib + step, len(B)) - 1\n\n        if A[new_ia] <= B[new_ib]:\n            # Discard A[ia .. new_ia]\n            k -= (new_ia - ia + 1)\n            ia = new_ia + 1\n        else:\n            # Discard B[ib .. new_ib]\n            k -= (new_ib - ib + 1)\n            ib = new_ib + 1\n\nExample usage:\nA = [1, 3, 5, 7, 9]\nB = [2, 4, 6, 8, 10]\nprint(kth_of_two_sorted(A, B, 5))  # 5\nprint(kth_of_two_sorted(A, B, 1))  # 1\nprint(kth_of_two_sorted(A, B, 10)) # 10\n\nNotes:\n- k is 1-based (k = 1 means the smallest element).\n- Works with duplicates and negative numbers.\n- Time complexity: O(log k) which is O(log(m+n)) in the worst case.\n- Space complexity: O(1) extra space."}
{"task_id": "Mbpp/605", "completion": "Here are simple prime-checking functions in a few common languages. The idea is to return false for numbers <= 1, handle small primes, and test divisors up to the square root of n (using the 6k \u00b1 1 optimization).\n\nPython\ndef is_prime(n: int) -> bool:\n    \"\"\"Return True if n is a prime number, else False.\"\"\"\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nJavaScript\nfunction isPrime(n) {\n  if (n <= 1) return false;\n  if (n <= 3) return true;\n  if (n % 2 === 0 || n % 3 === 0) return false;\n  for (let i = 5; i * i <= n; i += 6) {\n    if (n % i === 0 || n % (i + 2) === 0) return false;\n  }\n  return true;\n}\n\nJava\npublic static boolean isPrime(long n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (long i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    }\n    return true;\n}\n\nNotes\n- Handles negatives, 0, and 1 as non-prime.\n- Runs in O(sqrt(n)) time and O(1) extra space.\n- If you need to handle very large numbers, you might switch to a deterministic Miller-Rabin test for your target range. If you tell me the language and the expected range of n, I can tailor the implementation."}
{"task_id": "Mbpp/579", "completion": "Here are a few ways to interpret \"dissimilar elements\" between two tuples and corresponding Python functions.\n\n1) Treat as sets (ignore duplicates): elements that appear in exactly one of the tuples.\nCode:\ndef dissimilar_set(a, b):\n    return tuple(set(a) ^ set(b))\n\n# Example\na = (1, 2, 2, 3)\nb = (2, 3, 4)\nprint(dissimilar_set(a, b))  # e.g., (1, 4)\n\n2) Treat as multisets (respect counts): elements that differ in count between the tuples.\nCode:\nfrom collections import Counter\n\ndef dissimilar_multiset(a, b):\n    ca, cb = Counter(a), Counter(b)\n    diff = (ca - cb) + (cb - ca)  # counts of elements with unequal occurrences\n    res = []\n    for val, cnt in diff.items():\n        res.extend([val] * cnt)\n    return tuple(res)\n\n# Example\na = (1, 2, 2, 3)\nb = (2, 3, 4)\nprint(dissimilar_multiset(a, b))  # (1, 2, 4)\n\n3) Preserve original order (ordered symmetric difference, with counts)\nCode:\ndef dissimilar_ordered(a, b):\n    from collections import Counter\n    ca, cb = Counter(a), Counter(b)\n    diff = (ca - cb) + (cb - ca)\n    res = []\n    # first pass: keep elements from a in their original order\n    for x in a:\n        if diff.get(x, 0) > 0:\n            res.append(x)\n            diff[x] -= 1\n    # second pass: include remaining elements from b in their original order\n    for x in b:\n        if diff.get(x, 0) > 0:\n            res.append(x)\n            diff[x] -= 1\n    return tuple(res)\n\n# Example\na = (1, 2, 2, 3)\nb = (2, 3, 4)\nprint(dissimilar_ordered(a, b))  # (1, 2, 4)\n\nNotes:\n- If you only care about elements that are not common, the set-based version is simplest but ignores duplicates.\n- If duplicates matter (multiset behavior), use the multiset or ordered version.\n- All functions assume elements are hashable (so they can be placed in sets or Counters)."}
{"task_id": "Mbpp/606", "completion": "Here\u2019s the basic formula: radians = degrees \u00d7 \u03c0 / 180.\n\nExamples in common languages:\n\n- Python\n  import math\n  def deg_to_rad(deg):\n      return deg * math.pi / 180.0\n\n  # Alternatively: use built-in\n  # radians = math.radians(deg)\n\n- JavaScript\n  function degToRad(deg) {\n      return deg * Math.PI / 180;\n  }\n\n- Java\n  public static double degToRad(double deg) {\n      return deg * Math.PI / 180.0;\n  }\n\n- C++\n  #include <cmath>\n  double degToRad(double deg) {\n      return deg * std::acos(-1.0) / 180.0; // or use M_PI if available\n  }\n\n- C#\n  double DegToRad(double deg) {\n      return deg * Math.PI / 180.0;\n  }\n\nIf you tell me your preferred language (and whether you want to handle arrays/vectors), I can tailor the function precisely."}
{"task_id": "Mbpp/585", "completion": "Here are simple, practical implementations to get the n most expensive items from a dataset. The idea is to sort by price (or use a key function) and take the top n. I include both Python and JavaScript versions, plus notes on complexity and edge cases.\n\nPython version (works with list of dicts or objects; supply a key to extract price)\nCode:\nimport heapq\nfrom typing import Iterable, List, Any, Callable, Optional\n\ndef top_n_expensive(items: Iterable[Any], n: int, key: Optional[Callable[[Any], float]] = None) -> List[Any]:\n    \"\"\"\n    Return the top-n most expensive items from items.\n    - items: iterable of items (dicts or objects)\n    - key: a function that, given an item, returns its price. If None, items are assumed to be numeric prices.\n    \"\"\"\n    if n <= 0:\n        return []\n    if key is None:\n        # Assume items themselves are numeric prices\n        return heapq.nlargest(n, items)\n    # Use the provided key to extract price\n    return heapq.nlargest(n, items, key=key)\n\n# Example usage:\ndata = [\n    {\"id\": 1, \"name\": \"Widget\", \"price\": 19.99},\n    {\"id\": 2, \"name\": \"Gadget\", \"price\": 29.99},\n    {\"id\": 3, \"name\": \"Thingamajig\", \"price\": 9.99},\n    {\"id\": 4, \"name\": \"Doohickey\", \"price\": 29.99},\n]\n\ntop3 = top_n_expensive(data, 3, key=lambda x: x[\"price\"])\nprint(top3)\n# May print the three items with price 29.99, 29.99, and 19.99 (order for ties may vary)\n\nNotes:\n- If n > len(items), you'll simply get all items sorted by price.\n- If you need deterministic tie-breaking, add a secondary key (e.g., item id) in the key function.\n\nAlternative Python variant (simple sort, straightforward)\ndef top_n_expensive_sort(items, n, key=None):\n    if n <= 0:\n        return []\n    return sorted(items, key=key, reverse=True)[:n]\n\nJavaScript version (works with array of objects; supply a key by price name)\nCode:\nfunction topNExpensive(items, n, key = 'price') {\n  // Helper to extract price from an item\n  const getPrice = (item) => {\n    if (item && typeof item === 'object' && key in item) {\n      return item[key];\n    }\n    return 0;\n  };\n\n  // If n <= 0, return empty array\n  if (n <= 0) return [];\n\n  // Create a copy, sort by price descending, and take top n\n  return items\n    .slice()\n    .sort((a, b) => getPrice(b) - getPrice(a))\n    .slice(0, n);\n}\n\nExample usage:\nconst data = [\n  { id: 1, name: 'Widget', price: 19.99 },\n  { id: 2, name: 'Gadget', price: 29.99 },\n  { id: 3, name: 'Thingamajig', price: 9.99 },\n  { id: 4, name: 'Doohickey', price: 29.99 },\n];\n\nconst top3 = topNExpensive(data, 3);\nconsole.log(top3);\n\nNotes:\n- This sorts the entire dataset, which is simple and fast for moderate sizes. For very large datasets or streaming data, a min-heap approach (keeping only n items) is more memory- and time-efficient.\n\nOptional: streaming approach (memory-efficient for large datasets)\nPython (min-heap of size n):\ndef top_n_expensive_stream(items, n, key):\n    import heapq\n    heap = []  # will store (price, item)\n    for item in items:\n        price = key(item) if key else item\n        if len(heap) < n:\n            heapq.heappush(heap, (price, item))\n        else:\n            if price > heap[0][0]:\n                heapq.heapreplace(heap, (price, item))\n    # Return items sorted by price descending\n    return [it for (_, it) in sorted(heap, key=lambda x: x[0], reverse=True)]\n\nIf you share your dataset format and preferred language, I can tailor the function to your exact structure and provide additional options (e.g., stable tie-breaking, error handling)."}
{"task_id": "Mbpp/592", "completion": "Here's a Python function to compute the sum of the products of consecutive binomial coefficients for a given n.\n\nObservation: sum_{k=0}^{n-1} C(n, k) * C(n, k+1) = C(2n, n-1) for n >= 1.\n\nCode (with a safe fallback for factorial-based comb if math.comb isn\u2019t available):\n\n```python\n# Try to use the fast built-in comb (Python 3.8+); otherwise define a fallback\ntry:\n    from math import comb\nexcept ImportError:\n    from math import factorial\n    def comb(n, k):\n        if k < 0 or k > n:\n            return 0\n        return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef sum_consecutive_binomial_products(n):\n    \"\"\"\n    Return sum_{k=0}^{n-1} C(n, k) * C(n, k+1).\n    For n >= 1, this equals C(2n, n-1).\n    \"\"\"\n    if n <= 0:\n        return 0\n    return comb(2 * n, n - 1)\n\n# Optional: a loop-based version (for demonstration)\ndef sum_consecutive_binomial_products_loop(n):\n    if n <= 0:\n        return 0\n    s = 0\n    for k in range(n):\n        s += comb(n, k) * comb(n, k + 1)\n    return s\n\n# Example usage\nif __name__ == \"__main__\":\n    for n in range(1, 6):\n        print(n, sum_consecutive_binomial_products(n), \"loop=\", sum_consecutive_binomial_products_loop(n))\n```\n\nExample outputs:\n- n=1 -> 1\n- n=2 -> 4\n- n=3 -> 15\n- n=4 -> 56\n- n=5 -> 210\n\nThese values equal C(2n, n-1)."}
{"task_id": "Mbpp/580", "completion": "Here\u2019s a Python function that removes odd integers from a nested mixed tuple, preserving the structure. It recursively traverses tuples and filters out odd numbers. Non-integer elements are kept. By default, empty sub-tuples produced after filtering are dropped.\n\ndef remove_uneven(t, drop_empty=True):\n    \"\"\"\n    Remove odd integers from a nested tuple while preserving structure.\n    - Non-integer elements are kept.\n    - If a sub-tuple becomes empty after filtering, it can be dropped (default True).\n    Returns a new tuple.\n    \"\"\"\n    result = []\n    for item in t:\n        if isinstance(item, tuple):\n            inner = remove_uneven(item, drop_empty=drop_empty)\n            if inner or not drop_empty:\n                result.append(inner)\n        elif isinstance(item, int) and item % 2 != 0:\n            # skip odd integers\n            continue\n        else:\n            result.append(item)\n    return tuple(result)\n\nUsage examples:\n\nt = (1, 2, (3, 4, (5, 6), 7), \"a\", (8, 9.0, (11, 12)))\nprint(remove_uneven(t))\n# Output: (2, (4, (6)), 'a', (8, 9.0, (12)))\n\n# If you want to keep empty sub-tuples instead of dropping them:\nprint(remove_uneven(t, drop_empty=False))\n# Output may include empty sub-tuples depending on the data structure\n\nNotes:\n- Odd integers are removed (e.g., 1, 3, 5, ...). If you want to define \u201cuneven\u201d differently (e.g., also removing odd floats that are whole numbers), you can adjust the condition.\n- If a nested sub-tuple ends up empty after filtering and drop_empty is True (default), that sub-tuple is dropped from its parent. Set drop_empty to False to keep empty sub-tuples."}
{"task_id": "Mbpp/607", "completion": "Here are small, language-specific examples. They return a tuple/object with:\n- the matching substring\n- the start index (inclusive)\n- the end index (exclusive)\n\nPython (Python 3)\n\ndef search_regex(s, pattern, flags=0):\n    import re\n    m = re.search(pattern, s, flags)\n    if not m:\n        return None  # or (None, None, None)\n    start, end = m.start(), m.end()  # end is exclusive\n    return s[start:end], start, end\n\n# Example:\n# search_regex(\"hello 1234 world\", r\"\\d+\")\n# -> ('1234', 8, 12)\n\nJavaScript (ES2020+)\n\nfunction searchRegex(str, pattern) {\n  const re = new RegExp(pattern);\n  const m = re.exec(str);\n  if (!m) return null;\n  const start = m.index;\n  const end = start + m[0].length; // end is exclusive\n  return { substring: m[0], start, end };\n}\n\n# Example:\n# searchRegex(\"hello 1234 world\", \"\\\\d+\")\n# -> { substring: '1234', start: 8, end: 12 }\n\nIf you want this in another language (Java, C#, etc.) or you want the end index to be inclusive instead of exclusive, tell me and I\u2019ll tailor it."}
{"task_id": "Mbpp/615", "completion": "Here\u2019s a simple Python function that does that. It raises a ValueError if any inner tuple is empty.\n\ndef average_values(tuples_of_tuples):\n    \"\"\"\n    Given a tuple of tuples of numbers, return a list with the average of each inner tuple.\n    \"\"\"\n    result = []\n    for inner in tuples_of_tuples:\n        if len(inner) == 0:\n            raise ValueError(\"Inner tuple is empty.\")\n        result.append(sum(inner) / len(inner))\n    return result\n\n# Example:\n# average_values(((1, 2, 3), (4, 5), (6,)))\n# -> [2.0, 4.5, 6.0]"}
{"task_id": "Mbpp/612", "completion": "Here's a simple function that unzips a list of 2-element lists into two lists (one for the first elements, one for the second elements):\n\n```python\nfrom typing import List, Any\n\ndef unzip_pairs(pairs: List[List[Any]]) -> List[List[Any]]:\n    if not pairs:\n        return [[], []]\n    firsts, seconds = zip(*pairs)\n    return [list(firsts), list(seconds)]\n```\n\nExample:\n- unzip_pairs([[1, 2], [3, 4], [5, 6]]) -> [[1, 3, 5], [2, 4, 6]]"}
{"task_id": "Mbpp/610", "completion": "Here\u2019s a simple function that returns a new list with the k-th element removed. It uses 1-based indexing by default (k=1 removes the first element). You can set one_based=False to use 0-based indexing.\n\n```python\ndef remove_kth(lst, k, one_based=True):\n    \"\"\"\n    Return a new list with the k-th element removed.\n    - one_based=True (default): k is 1-based (k=1 removes the first element)\n    - one_based=False: k is 0-based\n    \"\"\"\n    idx = k - 1 if one_based else k\n    if idx < 0 or idx >= len(lst):\n        raise IndexError(\"k is out of range\")\n    return lst[:idx] + lst[idx+1:]\n```\n\nExample:\n- remove_kth([1, 2, 3, 4], 3) -> [1, 2, 4]\n- remove_kth([1, 2, 3, 4], 2, one_based=False) -> [1, 3, 4]"}
{"task_id": "Mbpp/614", "completion": "Here are two Python utilities assuming you have a list of tuples where each tuple contains numeric values.\n\n- cumulative_sums: returns the running (cumulative) sums across all values in order.\n- total_sum: returns the final total sum of all values.\n\nCode:\n\ndef cumulative_sums(tuple_list):\n    \"\"\"\n    Given a list of tuples containing numbers, return a list of running totals\n    as you traverse all values in order.\n    Example: [(1, 2), (3, 4)] -> [1, 3, 6, 10]\n    \"\"\"\n    result = []\n    running = 0\n    for tup in tuple_list:\n        for val in tup:\n            if not isinstance(val, (int, float)):\n                raise TypeError(\"All values must be numeric (int or float).\")\n            running += val\n            result.append(running)\n    return result\n\ndef total_sum(tuple_list):\n    \"\"\"\n    Return the total sum of all numeric values in the list of tuples.\n    Example: [(1, 2), (3, 4)] -> 10\n    \"\"\"\n    total = 0\n    for tup in tuple_list:\n        for val in tup:\n            if not isinstance(val, (int, float)):\n                raise TypeError(\"All values must be numeric (int or float).\")\n            total += val\n    return total\n\n# Example usage:\ntuples_list = [(1, 2, 3), (4, 5), (6,)]\nprint(cumulative_sums(tuples_list))  # [1, 3, 6, 10, 15, 21]\nprint(total_sum(tuples_list))        # 21\n\nIf your tuples may contain nested structures or non-numeric items, you can adjust the function to flatten deeper or to skip non-numeric values as needed."}
{"task_id": "Mbpp/608", "completion": "Here's a straightforward Python function using the Bell triangle (dynamic programming) to compute the nth Bell number (0-indexed).\n\ndef bell_number(n):\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    row = [1]  # row 0 of Bell triangle\n    for i in range(1, n + 1):\n        new_row = [row[-1]]  # first element of the new row\n        for j in range(1, i + 1):\n            new_row.append(new_row[-1] + row[j - 1])\n        row = new_row\n    return row[0]\n\n# Example usage:\n# print(bell_number(0))  # 1\n# print(bell_number(1))  # 1\n# print(bell_number(5))  # 52\n# print([bell_number(i) for i in range(10)])  # first few Bell numbers\n"}
{"task_id": "Mbpp/624", "completion": "Here's a simple Python function that converts a given string to uppercase using the built-in upper() method. It includes a type check to ensure the input is a string.\n\ndef to_uppercase(s: str) -> str:\n    \"\"\"\n    Convert a string to uppercase.\n\n    Parameters:\n    - s: input string\n\n    Returns:\n    - Uppercase version of s\n\n    Raises:\n    - TypeError if s is not a string\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return s.upper()\n\n# Example usage:\n# print(to_uppercase(\"Hello World\"))  # HELLO WORLD"}
{"task_id": "Mbpp/616", "completion": "Here's a simple Python function that does element-wise modulo for two equal-length tuples. It validates the inputs and raises clear errors if lengths differ or if modulo by zero is attempted.\n\ndef elementwise_mod(a: tuple[int, ...], b: tuple[int, ...]) -> tuple[int, ...]:\n    \"\"\"\n    Return a tuple where each element is a_i % b_i for corresponding elements in a and b.\n    Both inputs must be tuples of the same length. Modulo by zero raises ZeroDivisionError.\n    \"\"\"\n    if not isinstance(a, tuple) or not isinstance(b, tuple):\n        raise TypeError(\"Both arguments must be tuples.\")\n    if len(a) != len(b):\n        raise ValueError(\"Tuples must have the same length.\")\n    result = []\n    for x, y in zip(a, b):\n        if y == 0:\n            raise ZeroDivisionError(\"Modulo by zero encountered at position {}\".format(len(result)))\n        result.append(x % y)\n    return tuple(result)\n\n# Example:\n# a = (10, 20, 30)\n# b = (3, 4, 5)\n# elementwise_mod(a, b) -> (1, 0, 0)"}
{"task_id": "Mbpp/623", "completion": "Here\u2019s a simple Python function that computes the n-th power of each number in a list.\n\n```python\nfrom typing import List, Union\n\nNumber = Union[int, float]\n\ndef nth_powers(nums: List[Number], n: int) -> List[Number]:\n    if not isinstance(n, int):\n        raise TypeError(\"n must be an integer\")\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list\")\n\n    # This will work for ints and floats; negative n yields floats\n    return [x ** n for x in nums]\n\n# Example\n# nums = [1, 2, 3, 0, -2]\n# n = 3\n# print(nth_powers(nums, n))  # [1, 8, 27, 0, -8]\n```\n\nIf you\u2019d like support for other iterables (tuples, generators) or to preserve input type, I can adapt it accordingly. Also, if you\u2019re using NumPy, you can vectorize it with numpy.power for arrays."}
{"task_id": "Mbpp/632", "completion": "Here\u2019s an in-place solution that moves all zeros to the end while preserving the order of non-zero elements.\n\n```python\ndef move_zeroes_to_end(nums):\n    \"\"\"\n    Move all zeros to the end of the list in-place.\n    Returns the modified list for convenience.\n    \"\"\"\n    last_non_zero = 0  # index to place the next non-zero element\n\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[last_non_zero], nums[i] = nums[i], nums[last_non_zero]\n            last_non_zero += 1\n\n    return nums\n```\n\nExample:\n```python\nlst = [0, 1, 0, 3, 12]\nprint(move_zeroes_to_end(lst))  # [1, 3, 12, 0, 0]\n```\n\nIf you prefer a version that returns a new list (not in-place and uses extra space):\n\n```python\ndef move_zeroes_to_end_copy(nums):\n    non_zero = [x for x in nums if x != 0]\n    zeros = [0] * (len(nums) - len(non_zero))\n    return non_zero + zeros\n```\n\nTime complexity: O(n)  \nSpace complexity: O(1) (in-place version) or O(n) (copy version)."}
{"task_id": "Mbpp/618", "completion": "Here\u2019s a simple Python function that divides two lists element-wise. It requires the lists to have the same length and will raise an error if any corresponding pair tries to divide by zero.\n\ndef elementwise_divide(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length.\")\n    return [x / y for x, y in zip(a, b)]\n\nExample:\na = [6, 9, 12]\nb = [2, 3, 4]\nprint(elementwise_divide(a, b))  # [3.0, 3.0, 3.0]\n\nNotes and variants:\n- If you want to allow different lengths and just use up to the shortest length:\n  def elementwise_divide_truncate(a, b):\n      return [x / y for x, y in zip(a, b)]\n- If you\u2019re using NumPy, you can do it directly (handles many shapes and returns a NumPy array):\n  import numpy as np\n  def elementwise_divide_numpy(a, b):\n      return np.divide(a, b).tolist()\n- If a zero division should be handled gracefully (instead of raising), you can customize it, e.g.:\n  def elementwise_divide_handling_zero(a, b, fill_value=None):\n      if len(a) != len(b):\n          raise ValueError(\"Lists must have the same length.\")\n      result = []\n      for x, y in zip(a, b):\n          if y == 0:\n              if fill_value is None:\n                  raise ZeroDivisionError(\"Division by zero at element with index {}\".format(len(result)))\n              result.append(fill_value)\n          else:\n              result.append(x / y)\n      return result\n\nIf you tell me your preferred language or any particular behavior (strict length check, how to handle zeros, etc.), I can tailor the function accordingly."}
{"task_id": "Mbpp/611", "completion": "Here are two Python options for a matrix given as a list of lists.\n\n1) Simple version (assumes all rows have at least n+1 elements)\n- Uses 0-based column indexing.\n\ndef max_in_column(matrix, n):\n    \"\"\"\n    Return the maximum value in the nth column (0-based) of a rectangular matrix.\n    Assumes every row has at least n+1 elements.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"empty matrix\")\n    return max(row[n] for row in matrix)\n\n2) Robust version (handles ragged rows by skipping rows that are too short)\n- Optional: set require_all=True to raise if any row is missing the column.\n\ndef max_in_column_robust(matrix, n, require_all=False):\n    \"\"\"\n    Return the maximum value in the nth column (0-based) of a potentially ragged matrix.\n    - If require_all is False (default): ignore rows that don't have the nth column.\n    - If require_all is True: raise IndexError if any row is too short.\n    \"\"\"\n    if not matrix:\n        raise ValueError(\"empty matrix\")\n\n    max_val = None\n    found = False\n\n    for row in matrix:\n        if n < len(row):\n            val = row[n]\n            if not found or val > max_val:\n                max_val = val\n                found = True\n        else:\n            if require_all:\n                raise IndexError(\"Row is too short for column {}\".format(n))\n\n    if not found:\n        raise ValueError(\"No elements found in column {}\".format(n))\n\n    return max_val\n\nExamples:\n- For a rectangular matrix\n  m = [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\n  max_in_column(m, 1)            # 6\n- For a ragged matrix\n  m2 = [[1, 4], [2], [3, 6, 9]]\n  max_in_column_robust(m2, 1)    # 6\n  max_in_column_robust(m2, 1, require_all=True)  # raises IndexError since the second row is too short\n\nNote:\n- Column index n is 0-based. If you want 1-based indexing, call the function with n-1 (or wrap a small adapter)."}
{"task_id": "Mbpp/629", "completion": "Here\u2019s a simple function that returns the even numbers from a list (integers only):\n\ndef find_evens(numbers):\n    \"\"\"Return a list of even integers from 'numbers'.\"\"\"\n    return [n for n in numbers if isinstance(n, int) and n % 2 == 0]\n\nUsage example:\nnums = [1, 2, 3, 4, 5, 6]\nprint(find_evens(nums))  # [2, 4, 6]\n\nIf you prefer a generator (memory-efficient for large lists):\n\ndef evens_generator(numbers):\n    \"\"\"Yield even integers from 'numbers' one by one.\"\"\"\n    for n in numbers:\n        if isinstance(n, int) and n % 2 == 0:\n            yield n\n\nExample:\nfor e in evens_generator(nums):\n    print(e)\n\nNotes:\n- This version only considers integers. If you want to include numeric values like 2.0, you\u2019d need to adapt the condition."}
{"task_id": "Mbpp/603", "completion": "Could you clarify what you mean by \u201clucid numbers\u201d? Common possibilities are:\n- Lucas numbers (sequence: 2, 1, 3, 4, 7, 11, 18, \u2026)\n- Lucky numbers (sieve-generated sequence: 1, 3, 7, 9, 13, 15, 21, \u2026)\n- or a different definition\n\nIf you want a generic approach, here\u2019s a Python example that returns all numbers up to n that satisfy a given predicate is_lucid(x). You can plug in your own definition.\n\nPython (generic)\n- Function that returns all lucids up to n using a predicate\ndef get_all_lucid_numbers(n, is_lucid):\n    return [x for x in range(0, n + 1) if is_lucid(x)]\n\n# Example 1: Lucas numbers (up to n)\ndef lucid_numbers_lucas(n):\n    res = []\n    a, b = 2, 1  # L0 = 2, L1 = 1\n    while a <= n:\n        res.append(a)\n        a, b = b, a + b\n    return res\n\n# Example predicate: check if x is a Lucas number (membership test)\ndef is_lucid_lucas(x):\n    a, b = 2, 1\n    if x == a:\n        return True\n    while b <= x:\n        a, b = b, a + b\n        if a == x:\n            return True\n    return False\n\n# Usage:\n# get_all_lucid_numbers(100, is_lucid_lucas)\n# lucid_numbers_lucas(100)\n\nJavaScript version (generic)\nfunction getAllLucidNumbers(n, isLucid) {\n  const res = [];\n  for (let i = 0; i <= n; i++) {\n    if (isLucid(i)) res.push(i);\n  }\n  return res;\n}\n\n// Lucas numbers up to n\nfunction lucidNumbersLucas(n) {\n  const res = [];\n  let a = 2, b = 1; // L0 = 2, L1 = 1\n  while (a <= n) {\n    res.push(a);\n    const next = a + b;\n    a = b;\n    b = next;\n  }\n  return res;\n}\n\n// Example predicate to test Lucas membership\nfunction isLucidLucas(x) {\n  let a = 2, b = 1;\n  if (x === a) return true;\n  while (b <= x) {\n    a = b;\n    b = a + b; // careful with order; ensure you\u2019re computing next correctly\n  }\n  // simpler: re-run until a equals x\n  a = 2; b = 1;\n  if (x === a) return true;\n  while (a <= x) {\n    const next = a + b;\n    a = b;\n    b = next;\n    if (a === x) return true;\n  }\n  return false;\n}\n\n// Usage:\n// getAllLucidNumbers(100, isLucidLucas)\nconsole.log(lucidNumbersLucas(100)); // Lucas numbers <= 100\n\nIf you confirm which definition you want (Lucas, Lucky, or another), I can tailor the exact function (and language) you prefer, and handle edge cases like n < 0, etc."}
{"task_id": "Mbpp/641", "completion": "The nth nonagonal number is given by the formula:\nN(n) = (7n^2 - 5n) / 2, for n >= 1.\n\nPython function (uses integer arithmetic):\n\ndef nth_nonagonal(n):\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    return (7 * n * n - 5 * n) // 2\n\n# Example\nfor i in range(1, 7):\n    print(i, nth_nonagonal(i))\n\nNotes:\n- Time complexity: O(1)\n- Space complexity: O(1)\n- The formula yields integers for all positive integers n. If you want the function in another language, I can provide that too."}
{"task_id": "Mbpp/628", "completion": "Here are simple implementations in a few common languages. Each replaces spaces with \"%20\".\n\n- Python\n  def urlify(s: str) -> str:\n      return s.replace(' ', '%20')\n\n- JavaScript\n  function urlify(s) {\n      return s.split(' ').join('%20');\n  }\n\n- Java\n  public static String urlify(String s) {\n      return s.replace(\" \", \"%20\");\n  }\n\n- C++\n  #include <string>\n  #include <algorithm>\n\n  std::string urlify(const std::string& s) {\n      std::string res;\n      res.reserve(s.size() + 2 * std::count(s.begin(), s.end(), ' '));\n      for (char c : s) {\n          if (c == ' ')\n              res += \"%20\";\n          else\n              res += c;\n      }\n      return res;\n  }\n\n- C (dynamic allocation; returns a newly allocated string)\n  #include <stdlib.h>\n  #include <string.h>\n\n  char* urlify(const char* s) {\n      if (!s) return NULL;\n      size_t len = strlen(s);\n      size_t spaces = 0;\n      for (size_t i = 0; i < len; ++i) if (s[i] == ' ') ++spaces;\n      size_t new_len = len + 2 * spaces;\n      char* out = (char*)malloc(new_len + 1);\n      if (!out) return NULL;\n      char* p = out;\n      for (size_t i = 0; i < len; ++i) {\n          if (s[i] == ' ') {\n              memcpy(p, \"%20\", 3);\n              p += 3;\n          } else {\n              *p++ = s[i];\n          }\n      }\n      *p = '\\0';\n      return out;\n  }\n\nIf you have a specific language or constraints (in-place with extra capacity, streaming input, etc.), tell me and I can tailor the solution."}
{"task_id": "Mbpp/633", "completion": "Here's a Python function that computes the sum of XOR for all unordered pairs (i < j) in a list of non-negative integers using a bitwise counting approach.\n\n```python\ndef sum_pairwise_xor(arr):\n    \"\"\"\n    Return the sum of XOR of all unordered pairs (i < j) from the list 'arr'.\n    Assumes non-negative integers. For negative numbers, behavior is not defined here.\n    \"\"\"\n    n = len(arr)\n    if n < 2:\n        return 0\n\n    max_val = max(arr)\n    max_bit = max_val.bit_length()  # number of bits needed for max value\n\n    total = 0\n    for bit in range(max_bit):\n        ones = sum((x >> bit) & 1 for x in arr)\n        zeros = n - ones\n        total += ones * zeros * (1 << bit)\n\n    return total\n\n# Example:\n# arr = [1, 2, 3]\n# print(sum_pairwise_xor(arr))  # Output: 6\n```\n\nNotes:\n- The function counts, for each bit, how many numbers have that bit set (ones) and how many do not (zeros). Each such mixed pair contributes 1 at that bit to the XOR, so total contribution is ones * zeros * 2^bit.\n- Time complexity: O(n * B), where B is the number of bits in the maximum value (roughly O(n log M)).\n- If you need to handle signed integers (e.g., 32-bit), you can mask to a fixed width (e.g., 32 bits) and run the same logic."}
{"task_id": "Mbpp/630", "completion": "Here's a simple Python function that returns all adjacent coordinates for a given 2D coordinate tuple. It supports 4-neighborhood (no diagonals) or 8-neighborhood (including diagonals), and can enforce grid bounds if you provide rows and cols.\n\nCode:\n\ndef adjacent_coords(coord, rows=None, cols=None, diagonals=True):\n    \"\"\"\n    Get adjacent coordinates around a given (row, col).\n\n    - coord: tuple (r, c)\n    - rows, cols: grid dimensions (number of rows and columns). If provided, results are\n      kept within 0 <= r < rows and 0 <= c < cols.\n    - diagonals: if True, include diagonal neighbors (8-neighborhood); else only\n      4-neighborhood (N, S, E, W).\n    \"\"\"\n    r, c = coord\n    # 4-neighborhood\n    deltas = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    if diagonals:\n        # add diagonals for 8-neighborhood\n        deltas += [(-1, -1), (-1, 1), (1, -1), (1, 1)]\n\n    neighbors = []\n    for dr, dc in deltas:\n        nr, nc = r + dr, c + dc\n        if rows is not None and cols is not None:\n            if 0 <= nr < rows and 0 <= nc < cols:\n                neighbors.append((nr, nc))\n        else:\n            neighbors.append((nr, nc))\n\n    return neighbors\n\nUsage examples:\n\n- 8-neighborhood with bounds (e.g., a 6x6 grid):\n  adjacent_coords((2, 3), rows=6, cols=6) \n  -> [(1, 3), (3, 3), (2, 2), (2, 4), (1, 2), (1, 4), (3, 2), (3, 4)]\n\n- 4-neighborhood with bounds:\n  adjacent_coords((0, 0), rows=6, cols=6, diagonals=False)\n  -> [(1, 0), (0, 1)]\n\n- Without bounds (coordinates outside the grid are included if you don\u2019t pass rows/cols):\n  adjacent_coords((0, 0), diagonals=True)\n  -> [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\nIf you want a generator instead of a list, you can easily adapt by yielding inside the loop."}
{"task_id": "Mbpp/619", "completion": "Here\u2019s a simple Python function that moves every digit to the end of the string, preserving the order of non-digit characters and the digits themselves.\n\n- Python (digits moved individually)\n\ndef move_numbers_to_end(s):\n    \"\"\"\n    Move every digit to the end of the string, preserving the order of non-digits and digits.\n    \"\"\"\n    non_digits = []\n    digits = []\n    for ch in s:\n        if ch.isdigit():\n            digits.append(ch)\n        else:\n            non_digits.append(ch)\n    return ''.join(non_digits + digits)\n\n# Examples\nprint(move_numbers_to_end(\"a1b2c3\"))  # \"abc123\"\nprint(move_numbers_to_end(\"12abc\"))    # \"abc12\"\nprint(move_numbers_to_end(\"a1!b2@3\"))   # \"a!b@a? wait\" -> \"a!b@123\" (digits at end)\n\nIf you intend to move numeric substrings (treat numbers as tokens, e.g., \"12\" and \"3\" as chunks) to the end, you can use this variant:\n\n- Python (move numeric substrings as tokens)\n\nimport re\n\ndef move_number_tokens_to_end(s):\n    tokens = re.findall(r'\\d+', s)  # numeric substrings\n    without = re.sub(r'\\d+', '', s)  # remove numeric substrings\n    return without + ''.join(tokens)\n\n# Examples\nprint(move_number_tokens_to_end(\"a12bc3\"))   # \"abca12 3\" -> \"abc123\" (tokens \"12\" and \"3\" moved to end)\nprint(move_number_tokens_to_end(\"a 12 b 34\")) # \"a  b  1234\"\n\nIf you\u2019d like this in another language (JavaScript, Java, C++, etc.), tell me which one and I\u2019ll provide it."}
{"task_id": "Mbpp/643", "completion": "Here are simple implementations to check if a string contains the letter 'z' somewhere other than at the start or end.\n\nPython (case-sensitive)\ndef contains_z_inside(s: str) -> bool:\n    return 'z' in s[1:-1]\n\nPython (case-insensitive)\ndef contains_z_inside_ci(s: str) -> bool:\n    return 'z' in s[1:-1].lower()\n\nJavaScript (case-sensitive)\nfunction containsZInside(str) {\n  return str.length > 2 && str.substring(1, str.length - 1).includes('z');\n}\n\nJavaScript (case-insensitive)\nfunction containsZInsideCI(str) {\n  const inner = str.substring(1, str.length - 1).toLowerCase();\n  return inner.includes('z');\n}\n\nExamples:\n- contains_z_inside(\"azbzc\") -> True\n- contains_z_inside(\"zaz\") -> False (interior is \"a\")\n- containsZInside(\"zebra\") -> false (interior is \"ebr\" with no 'z')"}
{"task_id": "Mbpp/626", "completion": "Here's a simple Python function. The maximum area is R^2, achieved when the base is the diameter and the third vertex is at the top of the semicircle.\n\n```python\ndef max_area_semicircle_triangle(radius):\n    \"\"\"\n    Return the area of the largest triangle inscribed in a semicircle of given radius.\n    The maximum area is radius^2, achieved by a triangle with the diameter as the base\n    and the opposite point at the top of the semicircle.\n    \"\"\"\n    if radius <= 0:\n        raise ValueError(\"radius must be positive\")\n    return radius * radius\n\n# Example usage:\nr = 5.0\nprint(max_area_semicircle_triangle(r))  # Output: 25.0\n```"}
{"task_id": "Mbpp/637", "completion": "If you mean a break-even check (no profit and no loss), you just need to see if the selling price equals the cost price.\n\nHere are simple implementations in a few common languages. Feel free to tell me your preferred language if you want a different one.\n\nPython\ndef is_break_even(cost_price, selling_price):\n    \"\"\"\n    Returns True if there is no profit and no loss (break-even), else False.\n    \"\"\"\n    return selling_price == cost_price\n\n# Example\nprint(is_break_even(100, 100))  # True\nprint(is_break_even(100, 120))  # False\n\n\nJavaScript\nfunction isBreakEven(costPrice, sellingPrice) {\n  return sellingPrice === costPrice;\n}\n\nconsole.log(isBreakEven(100, 100)); // true\nconsole.log(isBreakEven(100, 120)); // false\n\n\nJava\npublic class Main {\n    public static boolean isBreakEven(double costPrice, double sellingPrice) {\n        return sellingPrice == costPrice;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(isBreakEven(100, 100)); // true\n        System.out.println(isBreakEven(100, 120)); // false\n    }\n}\n\n\nC++\nbool isBreakEven(double costPrice, double sellingPrice) {\n    return sellingPrice == costPrice;\n}\n\n// usage\n#include <iostream>\nint main() {\n    std::cout << std::boolalpha << isBreakEven(100.0, 100.0) << std::endl; // true\n    std::cout << isBreakEven(100.0, 120.0) << std::endl; // false\n    return 0;\n}\n\nNotes:\n- If you\u2019re dealing with floating-point numbers, consider using a tolerance to avoid precision issues:\n  - Python: abs(selling_price - cost_price) < 1e-9\n  - Other languages: similar approach with a small epsilon\n- If your definition of \u201cno profit and no loss\u201d involves more than a single transaction (e.g., multiple items), you\u2019d sum profits across items and check if the total is zero. If you share more context, I can tailor the function."}
{"task_id": "Mbpp/720", "completion": "Here\u2019s a simple Python function that appends a dictionary to a tuple and returns a new tuple (tuples are immutable, so it creates a new one):\n\ndef add_dict_to_tuple(t, d):\n    if not isinstance(t, tuple):\n        raise TypeError(\"First argument must be a tuple\")\n    if not isinstance(d, dict):\n        raise TypeError(\"Second argument must be a dict\")\n    return t + (d,)\n\n# Example\nt = (1, 2, 3)\nd = {'a': 1}\nresult = add_dict_to_tuple(t, d)\nprint(result)  # (1, 2, 3, {'a': 1})"}
{"task_id": "Mbpp/644", "completion": "Here's a simple in-place Python function that reverses the elements of an array (list) from index 0 up to a given position pos (inclusive). If pos is negative, it does nothing. If pos is beyond the end, it reverses the whole array.\n\n```python\ndef reverse_upto(arr, pos):\n    \"\"\"\n    Reverse elements of arr from index 0 to pos (inclusive) in place.\n    - If pos < 0: do nothing\n    - If pos >= len(arr) - 1: reverse the entire array\n    Returns the modified array for convenience.\n    \"\"\"\n    if pos < 0:\n        return arr\n    end = min(pos, len(arr) - 1)\n    i, j = 0, end\n    while i < j:\n        arr[i], arr[j] = arr[j], arr[i]\n        i += 1\n        j -= 1\n    return arr\n\n# Example:\nlst = [1, 2, 3, 4, 5]\nprint(reverse_upto(lst, 2))  # [3, 2, 1, 4, 5]\n```\n\nIf you prefer not to mutate the original list and instead return a new list, you can use slicing:\n\n```python\ndef reversed_prefix_copy(arr, pos):\n    if pos < 0:\n        return arr[:]\n    end = min(pos, len(arr) - 1)\n    return arr[:end+1][::-1] + arr[end+1:]\n\n# Example:\nlst = [1, 2, 3, 4, 5]\nprint(reversed_prefix_copy(lst, 2))  # [3, 2, 1, 4, 5]\n```"}
{"task_id": "Mbpp/639", "completion": "Here is a Python function that sums the lengths of names after removing any that start with a lowercase letter. It safely handles empty strings as well.\n\ndef sum_lengths_after_filter(names):\n    \"\"\"\n    Sum lengths of names that do not start with a lowercase letter.\n    Empty strings are included (length 0).\n    \"\"\"\n    return sum(len(n) for n in names if not (n and n[0].islower()))\n\n# Example\nnames = [\"Alice\", \"bob\", \"Charlie\", \"david\", \"Eve\", \"3John\", \"Mary Jane\", \"\"]\nprint(sum_lengths_after_filter(names))  # Output: 29\n\nIf you prefer a more explicit loop:\n\ndef sum_lengths(names):\n    total = 0\n    for n in names:\n        if n and n[0].islower():\n            continue\n        total += len(n)\n    return total\n\nWould you like this in another language (e.g., JavaScript) as well?"}
{"task_id": "Mbpp/723", "completion": "Here is a simple Python function that counts the indices where two lists of the same length have equal values.\n\n```python\nfrom typing import Sequence, Any\n\ndef count_matching_indices(a: Sequence[Any], b: Sequence[Any]) -> int:\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length\")\n    return sum(1 for x, y in zip(a, b) if x == y)\n\n# Example\n# a = [1, 2, 3, 4]\n# b = [1, 0, 3, 5]\n# count_matching_indices(a, b) -> 2\n```\n\nNotes:\n- Time complexity: O(n), where n is the length of the lists.\n- If you\u2019re sure the inputs are always of the same length, you can omit the length check."}
{"task_id": "Mbpp/722", "completion": "Here's a simple function that filters the dictionary to include only students whose height and weight are strictly above the given minimums.\n\ndef filter_students_by_minimum(students, min_height, min_weight):\n    \"\"\"\n    Filter students whose height > min_height and weight > min_weight.\n\n    - students: dict where key is student name and value is a tuple (height, weight)\n    - min_height: float\n    - min_weight: float\n\n    Returns a new dict with the filtered students.\n    \"\"\"\n    return {name: (h, w) for name, (h, w) in students.items() if h > min_height and w > min_weight}\n\n# Example usage:\nstudents = {\n    'Alice': (165.0, 60.0),\n    'Bob': (170.0, 75.0),\n    'Carol': (160.0, 55.0)\n}\nmin_height = 162.0\nmin_weight = 65.0\n\nfiltered = filter_students_by_minimum(students, min_height, min_weight)\nprint(filtered)\n# Output: {'Bob': (170.0, 75.0)}\n\nNote: If you want to include those equal to the minimums as well, replace > with >= in the condition."}
{"task_id": "Mbpp/635", "completion": "Here\u2019s a simple Python example. It sorts a list in ascending order by default and supports an optional key function and reverse flag.\n\n- Using the built-in sorted (returns a new list)\ndef sort_list(lst, key=None, reverse=False):\n    \"\"\"\n    Return a new list containing the elements of lst sorted.\n    - key: optional function mapping elements to a value to compare\n    - reverse: if True, sort in descending order\n    \"\"\"\n    return sorted(lst, key=key, reverse=reverse)\n\n- In-place sort (sorts the list itself)\ndef sort_inplace(lst, key=None, reverse=False):\n    \"\"\"\n    Sort the list in place and return it.\n    \"\"\"\n    lst.sort(key=key, reverse=reverse)\n    return lst\n\nOptional: a simple quicksort implementation (educational, not as fast as built-ins)\ndef quicksort(lst, key=None, reverse=False):\n    \"\"\"\n    Return a new list sorted using quicksort.\n    - key: optional function for comparison\n    - reverse: if True, sort in descending order\n    \"\"\"\n    if len(lst) <= 1:\n        return lst[:]\n    k = key if key is not None else (lambda x: x)\n    pivot = lst[len(lst) // 2]\n    pivot_key = k(pivot)\n    left = [x for x in lst if k(x) < pivot_key]\n    middle = [x for x in lst if k(x) == pivot_key]\n    right = [x for x in lst if k(x) > pivot_key]\n    if reverse:\n        return quicksort(right, key=key, reverse=reverse) + middle + quicksort(left, key=key, reverse=reverse)\n    else:\n        return quicksort(left, key=key, reverse=reverse) + middle + quicksort(right, key=key, reverse=reverse)\n\nIf you\u2019d like, tell me your preferred language (Python, JavaScript, Java, C++, etc.) or any constraints (stability, handling non-list inputs, custom comparators), and I\u2019ll tailor the function."}
{"task_id": "Mbpp/631", "completion": "Here\u2019s a function that swaps spaces and underscores in a string: spaces become underscores and underscores become spaces. Other characters are left unchanged.\n\nPython\n- One-liner using translate (does both swaps in one pass):\ndef swap_spaces_and_underscores(s: str) -> str:\n    trans = {ord(' '): '_', ord('_'): ' '}\n    return s.translate(trans)\n\n# Example\nprint(swap_spaces_and_underscores(\"a b_c\"))  # \"a_b c\"\n\nJavaScript\nfunction swapSpacesAndUnderscores(s) {\n  return Array.from(s, ch => ch === ' ' ? '_' : ch === '_' ? ' ' : ch).join('');\n}\n\n// Example\nconsole.log(swapSpacesAndUnderscores(\"a b_c\")); // \"a_b c\"\n\nJava\npublic static String swapSpacesAndUnderscores(String s) {\n    StringBuilder sb = new StringBuilder(s.length());\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        if (c == ' ') sb.append('_');\n        else if (c == '_') sb.append(' ');\n        else sb.append(c);\n    }\n    return sb.toString();\n}\n\nC++\n#include <string>\n\nstd::string swapSpacesUnderscores(const std::string& s) {\n    std::string t = s;\n    for (char& c : t) {\n        if (c == ' ') c = '_';\n        else if (c == '_') c = ' ';\n    }\n    return t;\n}\n\nNote:\n- These implementations swap only the space character ' ' and the underscore '_'. If you want to swap all whitespace characters (like tabs or newlines) with underscores, or vice versa, let me know the exact behavior and I can adjust the implementation."}
{"task_id": "Mbpp/721", "completion": "Since every path from the top-left to bottom-right (moving only right or down) visits the same number of cells, maximizing the average cost along the path is the same as maximizing the total cost along the path.\n\nAlgorithm (dynamic programming):\n- Let grid be an N x N matrix (list of lists).\n- dp[i][j] = maximum total cost to reach cell (i, j) from (0, 0) using only right/down moves.\n- Recurrence:\n  - dp[0][0] = grid[0][0]\n  - dp[i][0] = dp[i-1][0] + grid[i][0]\n  - dp[0][j] = dp[0][j-1] + grid[0][j]\n  - dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) for i, j > 0\n- The maximum total cost is dp[N-1][N-1].\n- Since path length is fixed (2N-1 cells), the maximum average is dp[N-1][N-1] / (2N-1).\n- To get the path, backtrack from (N-1, N-1) choosing the predecessor that contributed to the max at each step.\n\nTime/space:\n- Time: O(N^2)\n- Space: O(N^2) (can be reduced to O(N) with a rolling array and a separate predecessor table if you only need the path)\n\nPython example:\n\n```python\ndef max_avg_path(grid):\n    n = len(grid)\n    if n == 0: \n        return [], 0\n\n    # dp[i][j] = max total cost to (i, j)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = grid[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1])\n\n    # Reconstruct path\n    path = []\n    i, j = n-1, n-1\n    while True:\n        path.append((i, j))\n        if i == 0 and j == 0:\n            break\n        if i == 0:\n            j -= 1\n        elif j == 0:\n            i -= 1\n        else:\n            if dp[i-1][j] >= dp[i][j-1]:\n                i -= 1\n            else:\n                j -= 1\n    path.reverse()\n\n    total = dp[n-1][n-1]\n    avg = total / (2 * n - 1)\n    return path, avg\n```\n\nUsage:\n- Input: grid as a list of lists of costs.\n- Output: a path (as a list of coordinates) and the maximum average cost along that path.\n\nNotes:\n- If paths somehow had different lengths (not the case here), maximizing average would require a fractional programming approach (e.g., binary search on the average with a transformed grid), but for this NxN right/down path, the DP above suffices."}
{"task_id": "Mbpp/726", "completion": "Here is a simple Python function that does this:\n\ndef adjacent_products(t: tuple) -> tuple:\n    if len(t) < 2:\n        raise ValueError(\"Input tuple must have at least two elements.\")\n    return tuple(a * b for a, b in zip(t, t[1:]))\n\nExample:\n- Input: (1, 2, 3, 4)\n- Output: (2, 6, 12)\n\nNotes:\n- The input should be a tuple of length N+1, and the output is a tuple of length N.\n- Time complexity: O(N), where N is the length of the input tuple.\n- If you prefer to avoid raising an error for short inputs, you could return an empty tuple for len(t) < 2."}
{"task_id": "Mbpp/730", "completion": "Here\u2019s a simple function to remove consecutive duplicates from a list (compressing runs of equal elements to a single element).\n\nPython (iterative, clear)\ndef remove_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = [lst[0]]\n    for x in lst[1:]:\n        if x != result[-1]:\n            result.append(x)\n    return result\n\n# Example\n# remove_consecutive_duplicates([1, 1, 2, 3, 3, 3, 2]) -> [1, 2, 3, 2]\n\nPython (using itertools.groupby)\nfrom itertools import groupby\n\ndef remove_consecutive_duplicates(lst):\n    return [key for key, _ in groupby(lst)]\n\n# Example\n# remove_consecutive_duplicates([1, 1, 2, 3, 3, 3, 2]) -> [1, 2, 3, 2]\n\nIf you want this in another language, tell me which one and I\u2019ll adapt it (JavaScript, Java, etc.)."}
{"task_id": "Mbpp/741", "completion": "Here are a couple of simple Python functions to check if all characters in a string are the same.\n\nOption 1: Using a set (concise)\n- Time complexity: O(n)\n- Handles empty string as True\n\n```python\ndef all_chars_same(s: str) -> bool:\n    \"\"\"Return True if all characters in s are the same, else False.\"\"\"\n    if s == \"\":\n        return True\n    return len(set(s)) == 1\n```\n\nOption 2: Iterative check (explicit)\n```python\ndef all_chars_same_iter(s: str) -> bool:\n    \"\"\"Return True if all characters in s are the same, else False.\"\"\"\n    if not s:\n        return True\n    first = s[0]\n    for ch in s[1:]:\n        if ch != first:\n            return False\n    return True\n```\n\nUsage:\n```python\nprint(all_chars_same(\"aaaa\"))  # True\nprint(all_chars_same(\"aaab\"))  # False\nprint(all_chars_same(\"\"))       # True (by design)\n```"}
{"task_id": "Mbpp/638", "completion": "Here is a Python function that computes the wind chill index using the standard Canadian formula (works with wind speed in km/h and temperature in \u00b0C). It rounds the result up to the next integer (ceiling). If the inputs are outside the valid range (T > 10\u00b0C or V \u2264 4.8 km/h), it returns the air temperature as an approximation.\n\n- Formula used (valid for T \u2264 10\u00b0C and V > 4.8 km/h):\n  WCI = 13.12 + 0.6215*T - 11.37*(V^0.16) + 0.3965*T*(V^0.16)\n\nPython code:\n\nimport math\n\ndef wind_chill_kmh(temp_c, wind_kmh):\n    \"\"\"\n    Calculate wind chill index (WCI) in Celsius, for given temperature (\u00b0C)\n    and wind speed (km/h). Returns the WCI rounded up to the next integer.\n    Uses the Canadian wind chill formula when valid; otherwise returns the\n    air temperature as an approximation.\n    \"\"\"\n    # Use real wind chill only for valid range; otherwise approximate with air temperature\n    if wind_kmh <= 4.8 or temp_c > 10:\n        wci = temp_c\n    else:\n        v16 = wind_kmh ** 0.16\n        wci = 13.12 + 0.6215 * temp_c - 11.37 * v16 + 0.3965 * temp_c * v16\n    return math.ceil(wci)\n\nExample:\nprint(wind_chill_kmh(-5.0, 20.0))  # might print something like -11"}
{"task_id": "Mbpp/724", "completion": "Here's a simple Python function that computes base^power and then sums the digits of the result. It handles non-negative integer exponents.\n\ndef sum_digits_of_power(base, power):\n    if not isinstance(base, int) or not isinstance(power, int):\n        raise TypeError(\"base and power must be integers\")\n    if power < 0:\n        raise ValueError(\"power must be non-negative\")\n\n    value = pow(base, power)  # Python's big integers handle large results\n    total = 0\n    if value == 0:\n        return 0\n    while value:\n        total += value % 10\n        value //= 10\n    return total\n\n# Examples\nprint(sum_digits_of_power(12, 3))  # 12^3 = 1728 -> 1+7+2+8 = 18\nprint(sum_digits_of_power(2, 10))   # 2^10 = 1024 -> 1+0+2+4 = 7\n\nNotes:\n- If you prefer a shorter version, you can sum digits via string conversion: sum(int(ch) for ch in str(pow(base, power))).\n- This approach works well in Python due to its arbitrary-precision integers. For other languages, you may need a big-integer library."}
{"task_id": "Mbpp/733", "completion": "Here's a binary-search-based function to find the index of the first (leftmost) occurrence of a target in a sorted array. Returns -1 if the target is not present.\n\nPython version:\n\n```python\ndef first_occurrence(arr, x):\n    left, right = 0, len(arr)  # right is exclusive\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < x:\n            left = mid + 1\n        else:\n            right = mid\n    # left is the first position where arr[left] >= x\n    if left < len(arr) and arr[left] == x:\n        return left\n    return -1\n```\n\nUsage example:\n- arr = [1, 2, 2, 2, 3, 4]\n- first_occurrence(arr, 2) -> 1\n- first_occurrence(arr, 5) -> -1\n\nNotes:\n- Time complexity: O(log n)\n- Space complexity: O(1)\n\nAlternative in Python using bisect (standard library):\n\n```python\nimport bisect\n\ndef first_occurrence_bisect(arr, x):\n    i = bisect.bisect_left(arr, x)\n    return i if i < len(arr) and arr[i] == x else -1\n```\n\nIf you\u2019d like the function in another language (Java, C++, etc.), I can provide that too."}
{"task_id": "Mbpp/620", "completion": "Here's a Python function that finds the size of the largest subset where every pair is divisible (i.e., a largest divisible subset). It handles positive integers and also accounts for zeros by allowing at most one zero in the subset.\n\nExplanation (brief):\n- Sort positives.\n- Use dynamic programming: dp[i] is the length of the longest divisible subset that ends with positives[i].\n- For every i, check all j < i; if positives[i] % positives[j] == 0, you can extend the subset ending at j by i.\n- The answer is max(dp) plus one if there is at least one zero in the input (you can add a single zero to any subset of positives).\n\nCode:\n\ndef largest_divisible_subset_size(nums):\n    if not nums:\n        return 0\n\n    # Separate zeros and positives\n    zero_count = sum(1 for x in nums if x == 0)\n    positives = [x for x in nums if x > 0]\n\n    if not positives:\n        # Only zeros (or empty)\n        return 1 if zero_count > 0 else 0\n\n    positives.sort()\n    n = len(positives)\n    dp = [1] * n\n    max_len = 1\n\n    for i in range(n):\n        for j in range(i):\n            if positives[i] % positives[j] == 0:\n                if dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n        if dp[i] > max_len:\n            max_len = dp[i]\n\n    # Can add at most one zero to the subset\n    if zero_count > 0:\n        max_len += 1\n\n    return max_len\n\nExamples:\n- largest_divisible_subset_size([1, 2, 3, 4, 8]) returns 4 (subset like [1, 2, 4, 8])\n- largest_divisible_subset_size([5, 9, 3, 6, 12]) returns 3 (subset [3, 6, 12])\n- largest_divisible_subset_size([0, 0, 1, 2, 4]) returns 4 (subset [0, 1, 2, 4] or [0, 0, 0] is not allowed, so max is 4)\n\nIf you expect only positive integers (no zeros), you can simplify by removing the zero handling."}
{"task_id": "Mbpp/731", "completion": "A cone\u2019s lateral surface area is L = \u03c0 r l, where l is the slant height: l = sqrt(r^2 + h^2). So L = \u03c0 r sqrt(r^2 + h^2).\n\nPython:\ndef lateral_surface_area_cone(r, h):\n    \"\"\"\n    Return the lateral surface area of a right circular cone with radius r and height h.\n    r, h should be non-negative.\n    \"\"\"\n    import math\n    if r < 0 or h < 0:\n        raise ValueError(\"r and h must be non-negative.\")\n    l = math.hypot(r, h)  # sqrt(r*r + h*h)\n    return math.pi * r * l\n\nJavaScript:\nfunction lateralSurfaceAreaCone(r, h) {\n    if (r < 0 || h < 0) throw new Error(\"r and h must be non-negative\");\n    const l = Math.hypot(r, h);\n    return Math.PI * r * l;\n}\n\nJava:\npublic static double lateralSurfaceAreaCone(double r, double h) {\n    if (r < 0 || h < 0) throw new IllegalArgumentException(\"r and h must be non-negative\");\n    double l = Math.hypot(r, h);\n    return Math.PI * r * l;\n}\n\nC++:\n#include <cmath>\n#include <stdexcept>\n\ndouble lateralSurfaceAreaCone(double r, double h) {\n    if (r < 0 || h < 0) throw std::invalid_argument(\"r and h must be non-negative\");\n    double l = std::hypot(r, h);\n    return M_PI * r * l;\n}\n\nIf you prefer, you can also compute directly with L = \u03c0 r sqrt(r^2 + h^2) without using l:\n- Python: return math.pi * r * math.sqrt(r*r + h*h)\n- JavaScript/Java/C++: use Math.sqrt or std::sqrt / std::hypot as shown above."}
{"task_id": "Mbpp/736", "completion": "Here are two Python approaches to find the left insertion point (the index of the first element that is not less than the value, i.e., the insertion point to keep the list sorted).\n\nOption A: use the built-in bisect module (recommended)\n- This returns the leftmost insertion point for x in a sorted list a.\n\nCode:\nimport bisect\n\ndef left_insertion_point(a, x):\n    return bisect.bisect_left(a, x)\n\n# Example\narr = [1, 2, 4, 4, 4, 5, 7]\nprint(left_insertion_point(arr, 4))  # 2\nprint(left_insertion_point(arr, 6))  # 6\nprint(left_insertion_point(arr, 0))  # 0\n\n- Time complexity: O(log n)\n\nOption B: implement a manual binary search (no extra imports)\n- This also returns the index of the first element >= x.\n\nCode:\ndef left_insertion_point_manual(a, x):\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if a[mid] < x:\n            lo = mid + 1\n        else:\n            hi = mid\n    return lo\n\n# Example\narr = [1, 2, 4, 4, 4, 5, 7]\nprint(left_insertion_point_manual(arr, 4))  # 2\nprint(left_insertion_point_manual(arr, 6))  # 6\nprint(left_insertion_point_manual(arr, 0))  # 0\n\nNotes:\n- If x is smaller than all elements, the result is 0.\n- If x is larger than all elements, the result is len(a).\n- If x exists in the list, the result is the index of the first occurrence of x (leftmost)."}
{"task_id": "Mbpp/737", "completion": "Here are simple regex-based functions in Python and JavaScript. They check if the string starts with a vowel (a, e, i, o, u), case-insensitive. If you want to ignore leading whitespace, use the ignore-leading-whitespace variant.\n\nPython\n- Strict (first character must be a vowel)\n- With optional leading whitespace\n\n```python\nimport re\n\ndef starts_with_vowel(s: str, ignore_leading_ws: bool = False) -> bool:\n    pattern = r'^\\s*[aeiou]' if ignore_leading_ws else r'^[aeiou]'\n    return bool(re.match(pattern, s, re.IGNORECASE))\n```\n\nJavaScript\n- Strict (first character must be a vowel)\n- With optional leading whitespace\n\n```js\nfunction startsWithVowel(str, ignoreLeadingWhitespace = false) {\n  const pattern = ignoreLeadingWhitespace ? /^[\\s]*[aeiou]/i : /^[aeiou]/i;\n  return pattern.test(str);\n}\n```\n\nUsage examples\n\nPython:\n- starts_with_vowel(\"Apple\") -> True\n- starts_with_vowel(\" banana\", True) -> True\n- starts_with_vowel(\"banana\") -> False\n\nJavaScript:\n- startsWithVowel(\"Apple\") -> true\n- startsWithVowel(\" banana\", true) -> true\n- startsWithVowel(\"banana\") -> false\n\nIf you tell me your preferred language, I can tailor the function accordingly. Also, let me know if you want to treat strings like \"\" (empty) as False (the examples above return False)."}
{"task_id": "Mbpp/744", "completion": "Here's a simple Python function to check if a given tuple contains any None value (using identity check):\n\ndef has_none(t: tuple) -> bool:\n    if not isinstance(t, tuple):\n        raise TypeError(\"Input must be a tuple\")\n    return any(x is None for x in t)\n\n# Examples\nprint(has_none((1, 2, 3)))        # False\nprint(has_none((1, None, 3)))     # True\n\nIf you want a version that works with any iterable (not just tuples), you can drop the type check:\n\ndef has_none_iterable(it) -> bool:\n    return any(x is None for x in it)"}
{"task_id": "Mbpp/728", "completion": "Here are simple implementations in a few popular languages. Each assumes the input lists have the same length and raises an error if they don\u2019t.\n\nPython\ndef add_lists(a, b):\n    if len(a) != len(b):\n        raise ValueError(\"Lists must have the same length\")\n    return [ai + bi for ai, bi in zip(a, b)]\n\nJavaScript (ES6+)\nfunction addLists(a, b) {\n  if (a.length !== b.length) {\n    throw new Error(\"Arrays must have the same length\");\n  }\n  return a.map((ai, i) => ai + b[i]);\n}\n\nJava\nimport java.util.*;\n\npublic static List<Integer> addLists(List<Integer> a, List<Integer> b) {\n    if (a.size() != b.size()) {\n        throw new IllegalArgumentException(\"Lists must have the same size\");\n    }\n    List<Integer> result = new ArrayList<>(a.size());\n    for (int i = 0; i < a.size(); i++) {\n        result.add(a.get(i) + b.get(i));\n    }\n    return result;\n}\n\nC++ (C++11+)\n#include <vector>\n#include <stdexcept>\n\ntemplate <typename T>\nstd::vector<T> addLists(const std::vector<T>& a, const std::vector<T>& b) {\n    if (a.size() != b.size()) {\n        throw std::invalid_argument(\"Size mismatch\");\n    }\n    std::vector<T> c(a.size());\n    for (size_t i = 0; i < a.size(); ++i) c[i] = a[i] + b[i];\n    return c;\n}\n\nIf you don\u2019t want to enforce equal lengths, you can simply use zip-like behavior (ignoring extra elements) in Python:\ndef add_lists_lenient(a, b):\n    return [ai + bi for ai, bi in zip(a, b)]"}
{"task_id": "Mbpp/734", "completion": "Here\u2019s a Python function for the common interpretation: sum of products of all contiguous subarrays (subarrays). It runs in O(n) time and O(1) extra space.\n\nFunction (contiguous subarrays):\n- Idea: keep end_here as the sum of products of subarrays that end at the current index. For element x, any subarray ending here is either just x or some subarray ending at previous index extended by x. So end_here = x * (1 + end_here). Accumulate into total.\n\ndef sum_of_products_subarrays(arr):\n    \"\"\"\n    Returns the sum of products of all contiguous subarrays of arr.\n    If arr is empty, returns 0.\n    \"\"\"\n    if not arr:\n        return 0\n    total = 0\n    end_here = 0\n    for x in arr:\n        end_here = x * (1 + end_here)\n        total += end_here\n    return total\n\n# Example\narr = [1, 2, 3]\nprint(sum_of_products_subarrays(arr))  # Output: 20\n# Subarrays: [1], [2], [3], [1,2], [2,3], [1,2,3] -> products 1,2,3,2,6,6 -> sum 20\n\nIf you actually meant all non-contiguous subsets (i.e., every subset of the list, taking products of its elements), use this:\n\ndef sum_of_products_subsets(arr):\n    \"\"\"\n    Returns the sum of products of all non-empty subsets (not necessarily contiguous).\n    For empty input, returns 0.\n    \"\"\"\n    if not arr:\n        return 0\n    prod = 1\n    for a in arr:\n        prod *= (1 + a)\n    return prod - 1\n\n# Example\n# arr = [1, 2, 3]\n# sum_of_products_subsets(arr) -> 23\n# Subsets: [1]=1, [2]=2, [3]=3, [1,2]=2, [1,3]=3, [2,3]=6, [1,2,3]=6; sum = 23\n\nIf you meant something else by \u201csublists,\u201d tell me and I\u2019ll adjust the solution."}
{"task_id": "Mbpp/732", "completion": "Here are simple implementations in a few popular languages. Each function replaces every space (' '), comma (','), or dot ('.') with a colon (':').\n\n- Python\ndef replace_with_colon(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')\n\n# or using translate\ndef replace_with_colon(s):\n    return s.translate(str.maketrans({' ': ':', ',': ':', '.': ':'}))\n\n- JavaScript\nfunction replaceWithColon(s) {\n  return s.replace(/[ ,.]/g, ':');\n}\n\n- Java\npublic static String replaceWithColon(String s) {\n    return s.replaceAll(\"[ ,.]\", \":\");\n}\n\n- C#\nusing System.Text.RegularExpressions;\n\nstring ReplaceWithColon(string s) {\n    return Regex.Replace(s, \"[ ,.]\", \":\");\n}\n\nNotes:\n- If you want to replace any whitespace (not just the space character), use a regex like /[\\s,.]/g in JavaScript and the equivalent in other languages.\n- The methods shown preserve existing characters other than spaces, commas, and dots; consecutive instances will yield consecutive colons (e.g., \"a ,b.c\" -> \"a::b:c\")."}
{"task_id": "Mbpp/735", "completion": "Here\u2019s a simple Python function that toggles all bits of a non-negative integer except the most significant (first) and least significant (last) bits.\n\n- Idea: build a mask with 1s in all middle bit positions and 0s at the ends, then XOR the number with that mask.\n- Mask construction: let bits = n.bit_length(). The mask is ((1 << (bits - 2)) - 1) << 1.\n\nCode:\n\ndef toggle_middle_bits(n):\n    \"\"\"\n    Toggle all bits of n except the most significant and least significant bits.\n    Works for non-negative integers. If there are no middle bits (n <= 3), returns n.\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n <= 3:\n        return n  # no middle bits to toggle\n\n    bits = n.bit_length()\n    mask = ((1 << (bits - 2)) - 1) << 1\n    return n ^ mask\n\n# Examples\nprint(toggle_middle_bits(4))   # 6  -> 100 -> middle bit toggled -> 110\nprint(toggle_middle_bits(5))   # 7  -> 101 -> middle bit toggled -> 111\nprint(toggle_middle_bits(8))   # 14 -> 1000 -> middle bits toggled -> 1110\nprint(toggle_middle_bits(21))  # 27 -> 10101 -> middle bits toggled -> 11011\n\nNotes:\n- If n <= 3, there are no middle bits to toggle, so the function returns n.\n- For negative inputs, the function raises a ValueError.\n- Time complexity: O(1) (bit operations), Space: O(1)."}
{"task_id": "Mbpp/725", "completion": "Here are simple implementations to extract all values between double quotes in a string, handling escaped quotes as content (e.g., \\\" becomes a literal quote inside a value).\n\nPython version (robust to escaped quotes):\n- Returns a list of strings found between unescaped double quotes.\n- Escaped quotes inside a value are preserved as quotes.\n\ndef extract_quoted_values(s):\n    results = []\n    i = 0\n    in_quotes = False\n    current = []\n    while i < len(s):\n        ch = s[i]\n        if not in_quotes:\n            if ch == '\"':\n                in_quotes = True\n                current = []\n        else:\n            if ch == '\\\\' and i + 1 < len(s):\n                current.append(s[i + 1])  # take the escaped character\n                i += 2\n                continue\n            elif ch == '\"':\n                results.append(''.join(current))\n                in_quotes = False\n            else:\n                current.append(ch)\n        i += 1\n    return results\n\n# Example\ntext = 'A \"first\" and \"second with \\\\\"escaped\\\\\" quotes\"'\nprint(extract_quoted_values(text))\n# Output: ['first', 'second with \"escaped\" quotes']\n\nJavaScript version (same behavior):\nfunction extractQuotedValues(str) {\n  const results = [];\n  let inQuotes = false;\n  let current = [];\n  for (let i = 0; i < str.length; i++) {\n    const ch = str[i];\n    if (!inQuotes) {\n      if (ch === '\"') {\n        inQuotes = true;\n        current = [];\n      }\n    } else {\n      if (ch === '\\\\' && i + 1 < str.length) {\n        current.push(str[i + 1]); // include escaped character\n        i++;\n      } else if (ch === '\"') {\n        results.push(current.join(''));\n        inQuotes = false;\n      } else {\n        current.push(ch);\n      }\n    }\n  }\n  return results;\n}\n\n// Example\nconsole.log(extractQuotedValues('A \"first\" and \"second with \\\\\"escaped\\\\\" quotes\"'));\n// [\"first\",\"second with \\\"escaped\\\" quotes\"]\n\nNotes:\n- This extracts values between unescaped double quotes.\n- Escaped quotes inside a value are treated as literal characters (e.g., \\\" becomes \" inside the result).\n- If you only need non-escaped content and don\u2019t want to handle escapes, a simple regex like /\"([^\"]*)\"/g can be used, but it won\u2019t handle escaped quotes inside values."}
{"task_id": "Mbpp/750", "completion": "Here are a few Python options.\n\n1) Append the tuple to the list (as a single element, mutating the original list)\ndef add_tuple_to_list(lst, tpl):\n    lst.append(tpl)\n    return lst\n\n# Example\nmy_list = [1, 2, 3]\nmy_tuple = (4, 5)\nadd_tuple_to_list(my_list, my_tuple)  # [1, 2, 3, (4, 5)]\n\n2) Return a new list (without mutating the original)\ndef add_tuple_to_list_copy(lst, tpl):\n    return lst + [tpl]\n\n# Example\nnew_list = add_tuple_to_list_copy([1, 2, 3], (4, 5))  # [1, 2, 3, (4, 5)]\n\n3) If you want to extend by the tuple\u2019s elements (not the tuple itself)\ndef extend_list_with_tuple(lst, tpl):\n    lst.extend(tpl)\n    return lst\n\n# Example\nextend_list_with_tuple([1, 2, 3], (4, 5))  # [1, 2, 3, 4, 5]\n\nChoose the variant that fits whether you want to keep the tuple as a single element or merge its items into the list."}
{"task_id": "Mbpp/754", "completion": "Here's a Python function that finds elements that are common to all three lists at the same index (i.e., l1[i] == l2[i] == l3[i]). It automatically handles lists of different lengths by stopping at the shortest one.\n\ndef common_elements_at_same_index(l1, l2, l3):\n    result = []\n    for a, b, c in zip(l1, l2, l3):\n        if a == b == c:\n            result.append(a)\n    return result\n\n# Example\nl1 = [1, 2, 3, 4]\nl2 = [9, 2, 3, 0]\nl3 = [7, 2, 3, 5]\nprint(common_elements_at_same_index(l1, l2, l3))  # Output: [2, 3]\n\nNotes:\n- It uses zip, so it stops at the shortest list length.\n- Time complexity: O(n) where n is the length of the shortest list.\n- Returns a list of the common elements at matching indices."}
{"task_id": "Mbpp/749", "completion": "Here\u2019s a simple Python function to sort a list of strings that represent numbers, numerically.\n\n- Core idea: use the numeric value as the sort key (key=int).\n\nCode:\n\ndef sort_numeric_strings(strings):\n    \"\"\"\n    Return a new list with the given numeric strings sorted by their numeric value.\n    Assumes each string represents an integer (can include a leading +/- sign or leading zeros).\n    \"\"\"\n    return sorted(strings, key=int)\n\n# Example usage\nif __name__ == \"__main__\":\n    nums = [\"10\", \"1\", \"2\", \"-3\", \"20\", \"001\", \"0\"]\n    print(sort_numeric_strings(nums))\n    # Output: ['-3', '0', '1', '001', '2', '10', '20']\n\nNotes:\n- The sort is stable, so equal numeric values preserve their original relative order.\n- If you want to sort in-place, you can use: lst.sort(key=int)\n- If there might be non-numeric strings, you may want to handle exceptions, e.g.:\n  def sort_numeric_strings_safe(strings):\n      def to_int(s):\n          try:\n              return int(s)\n          except ValueError:\n              return float('inf')  # or raise, or handle differently\n      return sorted(strings, key=to_int)"}
{"task_id": "Mbpp/740", "completion": "Here are a couple of Python functions to convert a tuple into a dictionary by pairing adjacent elements as key-value pairs.\n\nOption 1: Simple (drops last key if the tuple length is odd)\n- Pairs (t[0], t[1]), (t[2], t[3]), ...\n\ndef tuple_to_adjacent_dict(tup):\n    \"\"\"\n    Convert a flat tuple into a dict by pairing adjacent elements as key-value.\n    If the tuple has odd length, the last key is dropped.\n    \"\"\"\n    return dict(zip(tup[0::2], tup[1::2]))\n\nExample:\nt = (1, 'a', 2, 'b', 3)\nprint(tuple_to_adjacent_dict(t))  # {1: 'a', 2: 'b'}\n\nOption 2: With a fill value for a missing value (handles odd length)\n- If the last key has no corresponding value, it uses fill_value (default None).\n\ndef tuple_to_adjacent_dict_with_fill(tup, fill_value=None):\n    \"\"\"\n    Convert a flat tuple into a dict by pairing adjacent elements as key-value.\n    If the tuple has odd length, the last key gets fill_value.\n    \"\"\"\n    d = {}\n    it = iter(tup)\n    for key in it:\n        value = next(it, fill_value)\n        d[key] = value\n    return d\n\nExample:\nt = (1, 'a', 2, 'b', 3)\nprint(tuple_to_adjacent_dict_with_fill(t))  # {1: 'a', 2: 'b', 3: None}\n\nNotes:\n- Keys must be hashable (numbers, strings, etc.).\n- If you don\u2019t care about odd-length tuples, Option 1 is the simplest. If you want to handle the last key gracefully, use Option 2."}
{"task_id": "Mbpp/743", "completion": "Here are a few Python options to rotate a list to the right by n positions.\n\n1) Simple, returns a new list (uses slicing)\ndef rotate_right(lst, k):\n    \"\"\"\n    Rotate a list to the right by k positions and return a new list.\n    Example: rotate_right([1, 2, 3, 4, 5], 2) -> [4, 5, 1, 2, 3]\n    \"\"\"\n    n = len(lst)\n    if n == 0:\n        return []\n    k %= n\n    if k == 0:\n        return lst[:]\n    return lst[-k:] + lst[:-k]\n\n2) In-place rotation (no extra list, O(1) space)\ndef rotate_right_inplace(lst, k):\n    \"\"\"\n    Rotate a list to the right by k positions in place.\n    \"\"\"\n    n = len(lst)\n    if n <= 1:\n        return\n    k %= n\n    if k == 0:\n        return\n\n    def reverse(a, i, j):\n        while i < j:\n            a[i], a[j] = a[j], a[i]\n            i += 1\n            j -= 1\n\n    # Reverse entire list, then first k elements, then the rest\n    reverse(lst, 0, n - 1)\n    reverse(lst, 0, k - 1)\n    reverse(lst, k, n - 1)\n\n3) Using deque (built-in, straightforward)\nfrom collections import deque\n\ndef rotate_right_deque(lst, k):\n    \"\"\"\n    Rotate a list to the right by k positions using deque.\n    \"\"\"\n    d = deque(lst)\n    d.rotate(k)  # positive k rotates right\n    return list(d)\n\nExamples:\n- rotate_right([1, 2, 3, 4, 5], 2) -> [4, 5, 1, 2, 3]\n- a = [1, 2, 3, 4, 5]; rotate_right_inplace(a, 2) -> a becomes [4, 5, 1, 2, 3]\n- rotate_right_deque([1, 2, 3, 4, 5], 2) -> [4, 5, 1, 2, 3]\n\nChoose the option that best fits your needs (simple return, in-place modification, or using deque)."}
{"task_id": "Mbpp/745", "completion": "Here's a Python function that finds numbers in the range [startnum, endnum] where every non-zero digit divides the number. If a number contains 0, it\u2019s automatically excluded.\n\n```python\ndef self_dividing_in_range(startnum, endnum):\n    \"\"\"\n    Return a list of numbers in [startnum, endnum] such that\n    each non-zero digit of the number divides the number itself.\n    Numbers containing '0' are excluded.\n    \"\"\"\n    return list(filter(\n        lambda n: all(ch != '0' and n % int(ch) == 0 for ch in str(n)),\n        range(startnum, endnum + 1)\n    ))\n\n# Example usage\nprint(self_dividing_in_range(1, 100))\n# Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99]\n```\n\nNotes:\n- The function excludes numbers containing 0 (since division by zero is undefined).\n- It uses a lambda with filter to align with the lambda-based approach in the linked exercise. You can adapt it to a regular function if you prefer."}
{"task_id": "Mbpp/752", "completion": "Jacobsthal numbers satisfy:\n- J0 = 0, J1 = 1\n- Jn = Jn-1 + 2 * Jn-2\n\nA convenient closed-form (O(1)) is:\n- Jn = (2^n \u2212 (\u22121)^n) / 3\n\nHere are two Python implementations.\n\n1) Simple iterative (O(n)) dynamic approach\ndef jacobsthal_iter(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    a, b = 0, 1  # a = J0, b = J1\n    for _ in range(2, n + 1):\n        a, b = b, b + 2 * a  # Jn = Jn-1 + 2*Jn-2\n    return b\n\n2) Closed-form (O(1))\ndef jacobsthal(n):\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    return (2**n - (-1)**n) // 3\n\nExamples:\n- jacobsthal(0) -> 0\n- jacobsthal(1) -> 1\n- jacobsthal(2) -> 1\n- jacobsthal(3) -> 3\n- jacobsthal(4) -> 5\n- jacobsthal(5) -> 11\n- jacobsthal(13) -> 2731\n\nIf you\u2019d like, I can provide versions in another language (JavaScript, C++, etc.)."}
{"task_id": "Mbpp/764", "completion": "Here's a simple Python function to count the number of digit characters in a given string:\n\n```python\ndef count_digits(s: str) -> int:\n    \"\"\"\n    Return the number of digit characters in the string s.\n    Digits are characters for which str.isdigit() is True.\n    \"\"\"\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    return sum(ch.isdigit() for ch in s)\n\n# Example\nprint(count_digits(\"Hello 12345!\"))  # Output: 5\n```\n\nNotes:\n- Uses str.isdigit() to count any Unicode digit characters as digits.\n- Time complexity: O(n), where n is the length of the string.\n- Space complexity: O(1) beyond the input string."}
{"task_id": "Mbpp/742", "completion": "Here\u2019s a Python function to compute the surface area (sum of the four triangular faces) of a tetrahedron from its four 3D vertices. If you instead have the edge lengths, I\u2019ve included a variant below.\n\nOption 1: from vertex coordinates (A, B, C, D)\n- A, B, C, D are 3D points: each is a sequence of three numbers.\n\ndef tetrahedron_surface_area_by_coords(verts):\n    \"\"\"\n    verts: iterable of four 3D points (each a sequence of 3 numbers)\n    Returns the total surface area of the tetrahedron.\n    \"\"\"\n    import math\n\n    def sub(u, v):\n        return (u[0] - v[0], u[1] - v[1], u[2] - v[2])\n\n    def cross(u, v):\n        return (\n            u[1]*v[2] - u[2]*v[1],\n            u[2]*v[0] - u[0]*v[2],\n            u[0]*v[1] - u[1]*v[0],\n        )\n\n    def norm(u):\n        return math.sqrt(u[0]**2 + u[1]**2 + u[2]**2)\n\n    def tri_area(p, q, r):\n        return 0.5 * norm(cross(sub(q, p), sub(r, p)))\n\n    A, B, C, D = verts\n    area_ABC = tri_area(A, B, C)\n    area_ABD = tri_area(A, B, D)\n    area_ACD = tri_area(A, C, D)\n    area_BCD = tri_area(B, C, D)\n\n    return area_ABC + area_ABD + area_ACD + area_BCD\n\nExample:\npoints = [(0,0,0), (1,0,0), (0,1,0), (0,0,1)]\nprint(tetrahedron_surface_area_by_coords(points))\n# Output \u2248 2.3660\n\n\nOption 2: from edge lengths (AB, AC, AD, BC, BD, CD)\n- If you know the six edge lengths with the faces AB-AC-BC, AB-AD-BD, AC-AD-CD, BC-BD-CD, you can use Heron's formula for each face.\n\nimport math\n\ndef tetrahedron_surface_area_by_edges(AB, AC, AD, BC, BD, CD):\n    def heron(a, b, c):\n        s = 0.5 * (a + b + c)\n        val = s * (s - a) * (s - b) * (s - c)\n        return math.sqrt(val) if val > 0 else 0.0\n\n    area_ABC = heron(AB, AC, BC)\n    area_ABD = heron(AB, AD, BD)\n    area_ACD = heron(AC, AD, CD)\n    area_BCD = heron(BC, BD, CD)\n\n    return area_ABC + area_ABD + area_ACD + area_BCD\n\nExample:\n# For the same unit-tetrahedron as above, all edge lengths except AB, AC, AD etc. are:\nAB = 1.0; AC = 1.0; AD = 1.0\nBC = math.sqrt(2); BD = math.sqrt(2); CD = math.sqrt(2)\nprint(tetrahedron_surface_area_by_edges(AB, AC, AD, BC, BD, CD))\n# Output \u2248 2.3660\n\nNotes:\n- The coordinate-based function computes the exact surface area from vertex positions and works for any non-degenerate tetrahedron.\n- If you have a degenerate or nearly degenerate tetrahedron (points nearly coplanar or edges with zero length), you may get numerical issues; the code handles non-positive Heron expressions by returning 0 for that face\u2019s area.\n- If you meant volume instead of surface area, I can provide a function for that as well."}
{"task_id": "Mbpp/758", "completion": "Here's a simple function that counts occurrences of lists at the top level of a given list. Each list is converted to a tuple to be hashable, and non-list items are ignored.\n\n```python\ndef count_lists_in_list(lst):\n    counts = {}\n    for item in lst:\n        if isinstance(item, list):\n            key = tuple(item)\n            counts[key] = counts.get(key, 0) + 1\n    return counts\n```\n\nExample:\n```python\nlst = [[1, 2], [3], [1, 2], [4], [2, 3], [3], []]\nprint(count_lists_in_list(lst))\n# Output: {(1, 2): 2, (3,): 2, (4,): 1, (2, 3): 1, (): 1}\n```\n\nNotes:\n- Lists nested inside other lists (i.e., not direct elements of the top-level list) are not counted with this function.\n- If you want to count all lists appearing anywhere inside (recursively), I can adapt it to walk the structure."}
{"task_id": "Mbpp/762", "completion": "Here are simple implementations. The 30-day months are: April (4), June (6), September (9), and November (11).\n\nPython:\ndef has_30_days(month):\n    if not isinstance(month, int) or not (1 <= month <= 12):\n        raise ValueError(\"month must be an integer between 1 and 12\")\n    return month in (4, 6, 9, 11)\n\n# Examples:\n# has_30_days(4) -> True\n# has_30_days(2) -> False\n\nJavaScript:\nfunction has30Days(month) {\n    if (!Number.isInteger(month) || month < 1 || month > 12) {\n        throw new Error(\"month must be an integer between 1 and 12\");\n    }\n    return [4, 6, 9, 11].includes(month);\n}\n\n# Examples:\n# has30Days(4) -> true\n# has30Days(2) -> false\n\nIf you prefer no exceptions, you can return false for invalid input:\nPython (no exceptions):\ndef has_30_days(month):\n    return isinstance(month, int) and 1 <= month <= 12 and month in (4, 6, 9, 11)"}
{"task_id": "Mbpp/751", "completion": "Here's a simple way to check if a given array represents a min-heap (using 0-based indexing). In a min-heap stored in an array, for every index i:\n- left = 2*i + 1\n- right = 2*i + 2\nand we must have arr[i] <= arr[left] and arr[i] <= arr[right] whenever those children exist.\n\nPython version (O(n) time, O(1) extra space):\n\ndef is_min_heap(arr):\n    n = len(arr)\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and arr[i] > arr[left]:\n            return False\n        if right < n and arr[i] > arr[right]:\n            return False\n    return True\n\n# Examples\nprint(is_min_heap([1, 3, 2, 7, 6, 4, 5]))  # True\nprint(is_min_heap([3, 9, 2, 6, 8, 0]))     # False\n\nNotes:\n- Empty array or a single element array is a min-heap by definition.\n- This checks the min-heap property; it does not need an explicit completeness check because the standard array representation already encodes a complete binary tree.\n\nIf you want versions in other languages, here are concise equivalents:\n\nC++ (vector<int> a):\n\nbool isMinHeap(const std::vector<int>& a) {\n    int n = (int)a.size();\n    for (int i = 0; i <= (n - 2) / 2; ++i) {\n        int l = 2*i + 1;\n        int r = 2*i + 2;\n        if (l < n && a[i] > a[l]) return false;\n        if (r < n && a[i] > a[r]) return false;\n    }\n    return true;\n}\n\nJava:\n\npublic static boolean isMinHeap(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i <= (n - 2) / 2; i++) {\n        int l = 2*i + 1;\n        int r = 2*i + 2;\n        if (l < n && arr[i] > arr[l]) return false;\n        if (r < n && arr[i] > arr[r]) return false;\n    }\n    return true;\n}\n\nJavaScript:\n\nfunction isMinHeap(arr) {\n    const n = arr.length;\n    for (let i = 0; i < n; i++) {\n        const left = 2 * i + 1;\n        const right = 2 * i + 2;\n        if (left < n && arr[i] > arr[left]) return false;\n        if (right < n && arr[i] > arr[right]) return false;\n    }\n    return true;\n}\n\nIf you\u2019d like, tell me your preferred language and I\u2019ll tailor the snippet accordingly."}
{"task_id": "Mbpp/763", "completion": "Here's a simple Python function that finds the minimum difference between any two elements in an array by sorting first (the minimum difference will occur between consecutive elements in the sorted order):\n\n```python\ndef min_difference(arr):\n    if arr is None or len(arr) < 2:\n        raise ValueError(\"Array must contain at least two elements.\")\n    \n    # Sort the array (uses O(n log n) time)\n    s = sorted(arr)\n    \n    # Find the minimum difference between consecutive elements\n    min_diff = float('inf')\n    for i in range(1, len(s)):\n        diff = s[i] - s[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            if min_diff == 0:  # can't get smaller than 0\n                break\n    return min_diff\n```\n\nUsage example:\n- min_difference([3, 8, 15, 1]) -> 2\n- min_difference([1, 2, 2, 3]) -> 0\n\nNotes:\n- Time complexity: O(n log n) due to sorting.\n- Space complexity: O(n) if using sorted (a new list); use arr.sort() and accept in-place modification for O(1) extra space (except for the input array)."}
{"task_id": "Mbpp/622", "completion": "Here are two ways to find the median of two sorted lists of the same size (let n be the length of each list).\n\n1) Simple O(n) approach (merge until the two middle elements)\n- Merge the two arrays conceptually using two pointers.\n- The median of the combined 2n elements is the average of the elements at indices n-1 and n (0-based).\n\nPython:\n\ndef median_of_two_sorted_equal_length_merge(A, B):\n    if len(A) != len(B) or len(A) == 0:\n        raise ValueError(\"Lists must be non-empty and of equal length\")\n    n = len(A)\n    i = j = 0\n    m1 = m2 = None\n    count = 0\n    while i < n or j < n:\n        if i < n and (j == n or A[i] <= B[j]):\n            val = A[i]\n            i += 1\n        else:\n            val = B[j]\n            j += 1\n        if count == n - 1:\n            m1 = val\n        if count == n:\n            m2 = val\n            break\n        count += 1\n    return (m1 + m2) / 2.0\n\n2) Optimal O(log n) approach (recursive reduction using medians)\n- Compare medians m1 of A and m2 of B.\n- If m1 == m2, that's the answer.\n- If m1 < m2, the overall median lies in A's upper half and B's lower half.\n- If m1 > m2, the overall median lies in A's lower half and B's upper half.\n- Recurse with half-size subarrays. Handle base cases n == 1 and n == 2 specially.\n\nPython:\n\ndef median_of_two_sorted_equal_length_log(A, B):\n    if len(A) != len(B) or len(A) == 0:\n        raise ValueError(\"Lists must be non-empty and of equal length\")\n\n    def median_of_sub(arr, low, high):\n        n = high - low + 1\n        if n % 2 == 0:\n            mid = (low + high) // 2\n            return (arr[mid] + arr[mid + 1]) / 2.0\n        else:\n            mid = (low + high) // 2\n            return arr[mid]\n\n    def recurse(aL, aR, bL, bR):\n        n = aR - aL + 1\n        if n == 1:\n            return (A[aL] + B[bL]) / 2.0\n        if n == 2:\n            return (max(A[aL], B[bL]) + min(A[aR], B[bR])) / 2.0\n\n        m1 = median_of_sub(A, aL, aR)\n        m2 = median_of_sub(B, bL, bR)\n\n        if m1 == m2:\n            return m1\n\n        if m1 < m2:\n            if n % 2 == 0:\n                return recurse(aL + n//2 - 1, aR, bL, bL + n//2)\n            else:\n                return recurse(aL + n//2, aR, bL, bL + n//2)\n        else:  # m1 > m2\n            if n % 2 == 0:\n                return recurse(aL, aL + n//2, bL + n//2 - 1, bR)\n            else:\n                return recurse(aL, aL + n//2, bL + n//2, bR)\n\n    return recurse(0, len(A) - 1, 0, len(B) - 1)\n\nNotes:\n- Both arrays must be the same length and non-empty.\n- The O(n) version is simpler to implement and understand; the O(log n) version is faster for large inputs.\n- If you\u2019re unsure about the language, these can be translated to Java, C++, etc. The logic remains the same."}
{"task_id": "Mbpp/766", "completion": "Here's a simple Python function that returns all pairs of consecutive items from a list. It uses zip to pair each item with the next one and returns a list of tuples.\n\n```python\nfrom typing import List, Tuple, TypeVar\n\nT = TypeVar('T')\n\ndef consecutive_pairs(lst: List[T]) -> List[Tuple[T, T]]:\n    return list(zip(lst, lst[1:]))\n```\n\nExample:\n- consecutive_pairs([1, 2, 3, 4]) -> [(1, 2), (2, 3), (3, 4)]\n- consecutive_pairs([a, b]) -> [(a, b)]\n- consecutive_pairs([solo]) -> []\n- consecutive_pairs([]) -> []\n\nIf you prefer the pairs as lists instead of tuples, you can use:\nreturn [list(pair) for pair in zip(lst, lst[1:])]"}
{"task_id": "Mbpp/755", "completion": "Here's a Python function that returns the second smallest distinct number in a list (or None if it doesn't exist):\n\ndef second_smallest(nums):\n    \"\"\"\n    Return the second smallest distinct number in nums, or None if it doesn't exist.\n    \"\"\"\n    first = None\n    second = None\n    for x in nums:\n        if first is None or x < first:\n            second = first\n            first = x\n        elif x != first and (second is None or x < second):\n            second = x\n    return second\n\nNotes:\n- This returns None if there aren\u2019t at least two distinct values (e.g., [1, 1] or []).\n\nIf you prefer a simpler, but less efficient approach (O(n log n) due to sorting), you can use distinct values after deduplication:\n\ndef second_smallest_by_sort(nums):\n    if not nums:\n        return None\n    unique_vals = sorted(set(nums))\n    return unique_vals[1] if len(unique_vals) >= 2 else None\n\nExamples:\n- second_smallest([3, 1, 4, 1, 5, 9]) -> 3\n- second_smallest([1, 1, 2]) -> 2\n- second_smallest([2, 2]) -> None\n\nIf you want the second element by position (counting duplicates), use:\n\ndef second_smallest_by_position(nums):\n    if len(nums) < 2:\n        return None\n    return sorted(nums)[1]"}
{"task_id": "Mbpp/760", "completion": "Here's a simple Python function that checks if a list contains only one distinct element (i.e., all elements are equal). It returns False for an empty list.\n\ndef has_only_one_distinct_element(nums):\n    \"\"\"\n    Return True if all elements in nums are equal (one distinct element).\n    Returns False for an empty list.\n    \"\"\"\n    if not nums:\n        return False\n    first = nums[0]\n    return all(x == first for x in nums)\n\n# Examples\nprint(has_only_one_distinct_element([1, 1, 1]))  # True\nprint(has_only_one_distinct_element([1, 2, 1]))  # False\nprint(has_only_one_distinct_element([]))         # False\n\nauxiliary alternative (concise, uses a set):\ndef has_only_one_distinct_element_set(nums):\n    return len(set(nums)) == 1  # returns False for empty lists as well"}
{"task_id": "Mbpp/767", "completion": "Here\u2019s a simple Python function that counts the number of index pairs (i < j) whose sum equals the given target.\n\ndef count_pairs_with_sum(nums, target):\n    \"\"\"\n    Return the number of pairs (i < j) such that nums[i] + nums[j] == target.\n    \"\"\"\n    seen = {}   # counts of numbers seen so far\n    count = 0\n    for x in nums:\n        comp = target - x\n        if comp in seen:\n            count += seen[comp]\n        seen[x] = seen.get(x, 0) + 1\n    return count\n\nUsage example:\n# Example\nprint(count_pairs_with_sum([1, 5, 7, -1, 5], 6))  # outputs 3\n# Pairs: (1,5), (1,5), (7,-1)\n\nNotes:\n- This counts index-based pairs (i < j). If you want to count unique value pairs (e.g., (a, b) only once regardless of how many times they appear), use a different approach.\n- The function handles negative numbers and duplicates efficiently in O(n) time and O(n) extra space."}
{"task_id": "Mbpp/757", "completion": "Here is a simple Python function that counts the number of pairs of strings where one is the reverse of the other. Each string can be used in at most one pair (disjoint pairing).\n\nCode:\n\nfrom collections import Counter\n\ndef count_reverse_pairs(strings):\n    \"\"\"\n    Count the number of pairs (i, j) such that strings[i] is the reverse of strings[j],\n    with each string used in at most one pair.\n    \"\"\"\n    unmatched = Counter()\n    pairs = 0\n    for s in strings:\n        rev = s[::-1]\n        if unmatched[rev] > 0:\n            unmatched[rev] -= 1\n            pairs += 1\n        else:\n            unmatched[s] += 1\n    return pairs\n\n# Example\nif __name__ == \"__main__\":\n    arr = [\"abc\", \"cba\", \"xyz\", \"zyx\", \"ab\", \"ba\", \"aa\", \"aa\"]\n    print(count_reverse_pairs(arr))  # Output: 4\n\nNotes:\n- Time complexity: O(n * L), where n is the number of strings and L is the average length of a string (due to reversing).\n- It handles duplicates and palindrome strings correctly (e.g., two \"aa\" strings form one pair).\n- If you want to also retrieve the actual pairs, I can provide a version that collects them."}
{"task_id": "Mbpp/753", "completion": "I can\u2019t provide a verbatim copy of the test cases from that page due to copyright. But I can give you an original implementation and your own test cases that exercise the same idea.\n\nHere's a simple Python function to get the minimum k records from a list of tuples. It lets you choose which element of the tuple to compare on via key_index (default is 0).\n\nCode:\n\nimport heapq\n\ndef min_k_records(records, k, key_index=0):\n    \"\"\"\n    Return the k tuples from 'records' with the smallest value at position 'key_index'.\n    - records: list of tuples\n    - k: number of minimum records to return\n    - key_index: index in the tuple to use for comparison (0-based)\n    \"\"\"\n    if records is None:\n        raise ValueError(\"records must be a list of tuples\")\n    if k <= 0:\n        return []\n    # nsmallest returns the k smallest elements according to the key\n    return heapq.nsmallest(k, records, key=lambda t: t[key_index])\n\nExample usage:\n\ntuples = [(5, 'apple'), (1, 'banana'), (3, 'cherry'), (2, 'date')]\nprint(min_k_records(tuples, 2))\n# Output: [(1, 'banana'), (2, 'date')]\n\nIf you want to sort by a different tuple element (e.g., second element), change key_index:\n\ntuples = [(5, 30), (1, 20), (3, 10), (2, 40)]\nprint(min_k_records(tuples, 3, key_index=1))\n# Output: [(3, 10), (1, 20), (5, 30)]\n\nOriginal test cases (created for illustration):\n\n- Test 1: Basic min by first element\n  tuples = [(4, 'a'), (1, 'b'), (3, 'c'), (2, 'd')]\n  min_k_records(tuples, 2)\n  Expected: [(1, 'b'), (2, 'd')]\n\n- Test 2: Min by second element\n  tuples = [(7, 9), (2, 4), (5, 1), (3, 6)]\n  min_k_records(tuples, 3, key_index=1)\n  Expected: [(5, 1), (2, 4), (3, 6)]\n\n- Test 3: k = 0\n  tuples = [(1, 'x'), (2, 'y')]\n  min_k_records(tuples, 0)\n  Expected: []\n\n- Test 4: k > len(records)\n  tuples = [(3, 'a'), (1, 'b'), (2, 'c')]\n  min_k_records(tuples, 5)\n  Expected: All records sorted by the key (defaulting to first element)\n\n- Test 5: Duplicates (ties)\n  tuples = [(2, 'a'), (1, 'b'), (1, 'c'), (3, 'd')]\n  min_k_records(tuples, 2, key_index=0)\n  Expected: [(1, 'b'), (1, 'c')] (order of ties may vary)\n\nNotes:\n- If you need deterministic order for ties, you can introduce a secondary key, e.g., key=lambda t: (t[key_index], t[secondary_index]).\n- Time complexity: O(k log n) for n = len(records) using the heap-based approach; you could also use sorted(records, key=...). If k is close to n, sorting may be simpler to read.\n\nIf you\u2019d like, I can tailor the function for a specific tuple structure you\u2019re using (e.g., records like (id, value, timestamp)) and provide a set of tailored test cases."}
{"task_id": "Mbpp/759", "completion": "Here\u2019s a Python function that checks if a string is a decimal number with a precision of 2 (i.e., up to two digits after the decimal point). You can choose to require exactly two digits after the decimal by setting exactly_two=True.\n\n- If exactly_two=False (default): strings like \"123\", \"123.4\", \"123.45\", \".45\", \"-0.12\" are valid.\n- If exactly_two=True: only numbers with a decimal point and exactly two digits after it are valid (e.g., \"123.45\", \"-.12\").\n\nCode:\n\nimport re\n\ndef is_decimal_number(s: str, exactly_two: bool = False) -> bool:\n    s = s.strip()\n    if not s:\n        return False\n    if exactly_two:\n        pattern = r'^[+-]?(?:\\d+\\.\\d{2}|\\.\\d{2})$'\n    else:\n        pattern = r'^[+-]?(?:\\d+(?:\\.\\d{1,2})?|\\.\\d{1,2})$'\n    return bool(re.fullmatch(pattern, s))\n\n# Examples\nprint(is_decimal_number(\"123\"))           # True\nprint(is_decimal_number(\"123.4\"))         # True\nprint(is_decimal_number(\"123.45\"))        # True\nprint(is_decimal_number(\"123.456\"))       # False\nprint(is_decimal_number(\".45\"))           # True\nprint(is_decimal_number(\"-.45\"))          # True\nprint(is_decimal_number(\"123.45\", exactly_two=True))  # True\nprint(is_decimal_number(\"123.4\", exactly_two=True))   # False\n\nIf you prefer a different interpretation (e.g., always require two digits after the decimal when a decimal point is present, or disallow leading zeros, etc.), tell me and I\u2019ll adjust the regex accordingly."}
{"task_id": "Mbpp/771", "completion": "Here\u2019s a simple, language-agnostic approach: use a stack. Push opening brackets onto the stack; when you see a closing bracket, pop and check that it matches the most recent opening one. If anything mismatches or the stack is empty when a closing bracket appears, the expression is unbalanced. You can ignore non-bracket characters.\n\nPython version:\ndef is_balanced(expr):\n    stack = []\n    pairs = {')': '(', ']': '[', '}': '{'}\n    openings = set(pairs.values())\n    for ch in expr:\n        if ch in openings:\n            stack.append(ch)\n        elif ch in pairs:\n            if not stack or stack[-1] != pairs[ch]:\n                return False\n            stack.pop()\n    return not stack\n\n# Examples\nprint(is_balanced(\"({[]})\"))  # True\nprint(is_balanced(\"([)]\"))    # False\n\nC++ version:\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isBalanced(const string& s) {\n    stack<char> st;\n    auto matches = [](char open, char close) {\n        return (open=='(' && close==')') ||\n               (open=='[' && close==']') ||\n               (open=='{' && close=='}');\n    };\n    for (char c : s) {\n        if (c=='(' || c=='[' || c=='{') {\n            st.push(c);\n        } else if (c==')' || c==']' || c=='}') {\n            if (st.empty() || !matches(st.top(), c)) return false;\n            st.pop();\n        }\n    }\n    return st.empty();\n}\n\nJava version:\npublic class Balanced {\n    public static boolean isBalanced(String s) {\n        java.util.Stack<Character> st = new java.util.Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '[' || c == '{') {\n                st.push(c);\n            } else if (c == ')' || c == ']' || c == '}') {\n                if (st.isEmpty()) return false;\n                char open = st.pop();\n                if (!matches(open, c)) return false;\n            }\n        }\n        return st.isEmpty();\n    }\n\n    private static boolean matches(char open, char close) {\n        return (open == '(' && close == ')') ||\n               (open == '[' && close == ']') ||\n               (open == '{' && close == '}');\n    }\n}\n\nComplexity:\n- Time: O(n) where n is the length of the expression.\n- Space: O(n) in the worst case (if all characters are opening brackets).\n\nIf you want, tell me your preferred language and I\u2019ll tailor the function for you."}
{"task_id": "Mbpp/775", "completion": "Here's a concise Python function that checks whether every element at odd indices (1, 3, 5, ...) is an odd integer. It ignores even indices.\n\n- Using a clean one-liner with all():\n  def all_odd_indices_are_odd(lst):\n      \"\"\"\n      Return True if every element at odd indices of lst is an odd integer.\n      \"\"\"\n      return all(isinstance(x, int) and x % 2 != 0 for x in lst[1::2])\n\n- Example:\n  print(all_odd_indices_are_odd([1, 3, 4, 5]))  # True (indices 1 and 3 have 3 and 5, both odd)\n  print(all_odd_indices_are_odd([1, 2, 4, 5]))  # False (index 1 has 2, even)\n\nNotes:\n- If there are no odd indices (e.g., a list with length 0 or 1), it returns True (vacuously true).\n- Non-integer values at odd indices cause the function to return False."}
{"task_id": "Mbpp/777", "completion": "Here\u2019s a simple Python function that returns the sum of elements that appear exactly once in the list.\n\n```python\nfrom collections import Counter\n\ndef sum_non_repeated(lst):\n    \"\"\"\n    Return the sum of elements that occur exactly once in lst.\n    Assumes elements are hashable (e.g., ints, floats, strings).\n    \"\"\"\n    counts = Counter(lst)\n    return sum(val for val, cnt in counts.items() if cnt == 1)\n```\n\nExample:\n- sum_non_repeated([1, 2, 2, 3, 4, 4, 5]) -> 9\n  (Unique elements are 1, 3, 5; 1+3+5 = 9)\n\nIf you want to handle very large lists without counting all frequencies first, I can share an in-one-pass approach as well."}
{"task_id": "Mbpp/778", "completion": "Here\u2019s a Python function that packs consecutive duplicates of list elements into sublists.\n\nUsing itertools.groupby (concise):\n```python\nfrom itertools import groupby\n\ndef pack_consecutive_duplicates(lst):\n    \"\"\"Pack consecutive duplicates in lst into sublists.\"\"\"\n    return [list(group) for _, group in groupby(lst)]\n```\n\nExample:\n- pack_consecutive_duplicates([1, 1, 2, 3, 3, 3, 4, 4])\n  -> [[1, 1], [2], [3, 3, 3], [4, 4]]\n\nIf you prefer not to use itertools, a manual version:\n\n```python\ndef pack_consecutive_duplicates(lst):\n    \"\"\"Pack consecutive duplicates in lst into sublists (no itertools).\"\"\"\n    if not lst:\n        return []\n    result = []\n    current = [lst[0]]\n    for item in lst[1:]:\n        if item == current[-1]:\n            current.append(item)\n        else:\n            result.append(current)\n            current = [item]\n    result.append(current)\n    return result\n```\n\nNotes:\n- Works with any sequence of hashable/equality-comparable elements.\n- For an empty input, returns an empty list.\n- Time complexity: O(n); Space complexity: O(n) for the resulting groups."}
{"task_id": "Mbpp/781", "completion": "Here\u2019s a concise way using the mathematical fact: the number of divisors of n is odd iff n is a perfect square. So the count is even exactly when n is not a perfect square.\n\ndef is_divisor_count_even(n):\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    root = int(n**0.5)\n    return (root * root) != n\n\n# Examples\nprint(is_divisor_count_even(6))  # True  (divisors: 1,2,3,6 -> 4)\nprint(is_divisor_count_even(9))  # False (divisors: 1,3,9 -> 3)\nprint(is_divisor_count_even(1))  # False (divisors: 1 -> 1)\n\nIf you prefer counting divisors explicitly (not just using the square-root trick), you can implement a loop over sqrt(n) and count pairs, but the above is O(1) time."}
{"task_id": "Mbpp/772", "completion": "Here are simple implementations in a few common languages. The basic idea: split the string into words, filter out those with length equal to k, and join back.\n\nPython\n- Keeps punctuation attached to words (counts toward length).\n- Handles k <= 0 by leaving the string unchanged.\n\ndef remove_k_length_words(s, k):\n    if k <= 0:\n        return s\n    return ' '.join(w for w in s.split() if len(w) != k)\n\n# Example\ns = \"This is a sample sentence with some longword and short words\"\nk = 5\nprint(remove_k_length_words(s, k))\n\nJavaScript\nfunction removeKLengthWords(str, k) {\n  if (k <= 0) return str;\n  return str.split(/\\s+/).filter(w => w.length !== k).join(' ');\n}\n\n// Example\nconsole.log(removeKLengthWords(\"This is a sample sentence with some longword and short words\", 5));\n\nJava\npublic static String removeKLengthWords(String s, int k) {\n    if (k <= 0) return s;\n    String[] parts = s.trim().split(\"\\\\s+\");\n    StringBuilder sb = new StringBuilder();\n    for (String w : parts) {\n        if (w.length() != k) {\n            if (sb.length() > 0) sb.append(' ');\n            sb.append(w);\n        }\n    }\n    return sb.toString();\n}\n\nC++\n#include <string>\n#include <sstream>\n\nstd::string removeKLengthWords(const std::string& s, std::size_t k) {\n    if (k == 0) return s;\n    std::istringstream iss(s);\n    std::string word, result;\n    while (iss >> word) {\n        if (word.length() != k) {\n            if (!result.empty()) result += ' ';\n            result += word;\n        }\n    }\n    return result;\n}\n\nNotes and variations\n- If you want to ignore punctuation and count only alphabetic characters, you can strip punctuation from each word before checking its length, or use a regex-based approach to target words of length k.\n- If you want to preserve spacing exactly (not collapse multiple spaces), you\u2019d need a more advanced tokenization approach that tracks and rebuilds the exact separators.\n\nWould you like a version in a specific language or with punctuation-stripping semantics?"}
{"task_id": "Mbpp/785", "completion": "Here\u2019s a Python function that converts a string representation of a tuple (or a list) of integers into an actual Python tuple of ints. It handles formats like \"(1, 2, 3)\", \"[1, 2, 3]\", \"1, 2, 3\", or even a single number like \"5\".\n\n```python\nimport ast\n\ndef tuple_string_to_int_tuple(s: str) -> tuple:\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string.\")\n    s = s.strip()\n    if not s:\n        return tuple()\n\n    try:\n        val = ast.literal_eval(s)\n    except (SyntaxError, ValueError) as e:\n        raise ValueError(f\"Invalid tuple-like string: {s}\") from e\n\n    def ensure_tuple_of_ints(seq):\n        res = []\n        for item in seq:\n            if isinstance(item, bool):\n                raise ValueError(\"Boolean values are not allowed.\")\n            if not isinstance(item, (int, float)):\n                raise ValueError(\"All items must be numeric (int or float).\")\n            res.append(int(item))\n        return tuple(res)\n\n    if isinstance(val, tuple):\n        return ensure_tuple_of_ints(val)\n    if isinstance(val, list):\n        return ensure_tuple_of_ints(val)\n    if isinstance(val, (int, float)):\n        return (int(val),)\n\n    raise ValueError(\"Input does not represent a tuple or list of integers.\")\n```\n\nUsage examples:\n- tuple_string_to_int_tuple(\"(1, 2, 3)\") -> (1, 2, 3)\n- tuple_string_to_int_tuple(\"[4, 5, 6]\") -> (4, 5, 6)\n- tuple_string_to_int_tuple(\"7, 8, 9\") -> (7, 8, 9)\n- tuple_string_to_int_tuple(\"10\") -> (10,)\n\nNotes:\n- Uses ast.literal_eval for safety to parse the string.\n- Accepts both tuples and lists in the string representation.\n- Converts all elements to int; booleans raise an error. If you want to allow booleans or keep them as-is, adjust the checks accordingly."}
{"task_id": "Mbpp/784", "completion": "Here's a Python function that returns the product of the first even and the first odd numbers in a list. If either is missing, it returns None.\n\ndef product_first_even_and_odd(nums):\n    \"\"\"\n    Return the product of the first even and the first odd numbers in nums.\n    If either is missing, return None.\n    \"\"\"\n    first_even = None\n    first_odd = None\n\n    for n in nums:\n        if first_even is None and n % 2 == 0:\n            first_even = n\n        if first_odd is None and n % 2 != 0:\n            first_odd = n\n        if first_even is not None and first_odd is not None:\n            break\n\n    if first_even is None or first_odd is None:\n        return None\n\n    return first_even * first_odd\n\nExample:\n- product_first_even_and_odd([2, 3, 4, 5]) -> 6 (2 * 3)\n- product_first_even_and_odd([1, 3, 5]) -> None (no even)\n\nNotes:\n- Time complexity: O(n), where n is the length of the list.\n- Space complexity: O(1)."}
{"task_id": "Mbpp/769", "completion": "Here are a few ways to interpret \u201cdifference\u201d between two lists, with Python implementations. I\u2019ll show simple A-B (elements in a not in b) and a multiset version (preserving counts), plus a symmetric-difference (unique elements only).\n\n1) A - B (preserving order, ignoring duplicates in B)\n- Works with hashable items only (since it uses a set for membership).\n\ndef difference(a, b):\n    \"\"\"Return elements in a that are not in b (order preserved).\"\"\"\n    bset = set(b)\n    return [x for x in a if x not in bset]\n\n2) A - B with counts (multiset difference)\n- Preserves the number of occurrences from a after removing what appears in b (based on counts).\n\nfrom collections import Counter\n\ndef multiset_difference(a, b):\n    \"\"\"Return elements in a not in b, considering counts (multiset difference).\"\"\"\n    ca, cb = Counter(a), Counter(b)\n    diff = ca - cb  # remaining counts for each element\n    res = []\n    for x in a:\n        if diff[x] > 0:\n            res.append(x)\n            diff[x] -= 1\n    return res\n\n3) Symmetric difference (unique elements present in exactly one of the lists)\n- Returns unique items that are in either list but not in both.\n\ndef symmetric_difference(a, b):\n    \"\"\"Return unique elements present in exactly one of a or b.\"\"\"\n    return list(set(a) ^ set(b))\n\nUsage examples:\n\na = [1, 2, 2, 3, 4, 4]\nb = [2, 4]\n\nprint(difference(a, b))           # [1, 3]\nprint(multiset_difference(a, b))  # [1, 2, 3, 4]\nprint(symmetric_difference(a, b)) # [1, 3]\n\nNotes:\n- If you need to handle non-hashable items (like lists inside), the set-based approaches won\u2019t work. In that case you\u2019d need a custom comparison (e.g., using a loop and equality checks) instead of set membership.\n- Choose the version based on whether you care about duplicate counts (multiset) or just unique presence (A-B with sets or symmetric difference)."}
{"task_id": "Mbpp/773", "completion": "Here\u2019s a concise Python function that finds all occurrences of each substring inside a text and returns their starting positions. If none of the substrings occur, it returns None.\n\n```python\ndef find_substring_positions(text, substrings, case_sensitive=True, allow_overlap=True):\n    \"\"\"\n    Find occurrences of each substring in text.\n\n    Returns:\n        dict[str, list[int]]: mapping from each input substring to a list of start indices\n                              where that substring occurs in text.\n                              Substrings with at least one match are included.\n        None: if no matches for any substring are found.\n\n    Parameters:\n        text (str): The string to search within.\n        substrings (list[str]): Substrings to search for.\n        case_sensitive (bool): If False, search is case-insensitive.\n        allow_overlap (bool): If True, overlapping occurrences are counted.\n                              If False, occurrences are non-overlapping.\n    \"\"\"\n    if not substrings:\n        return None\n\n    results = {}\n    search_text = text if case_sensitive else text.lower()\n    search_subs = substrings if case_sensitive else [s.lower() for s in substrings]\n\n    for i in range(len(substrings)):\n        orig = substrings[i]\n        sub = search_subs[i]\n        if sub == \"\":\n            continue\n\n        positions = []\n        pos = 0\n        while True:\n            idx = search_text.find(sub, pos)\n            if idx == -1:\n                break\n            positions.append(idx)\n            pos = idx + (1 if allow_overlap else len(sub))\n\n        if positions:\n            results[orig] = positions\n\n    return results if results else None\n```\n\nUsage examples:\n\n- Overlapping search, case-sensitive:\n  - text = \"ababa\"\n  - substrings = [\"aba\", \"ba\"]\n  - find_substring_positions(text, substrings) -> {'aba': [0, 2], 'ba': [1, 3]}\n\n- Case-insensitive search:\n  - text = \"Hello, hELLo!\"\n  - substrings = [\"hello\"]\n  - find_substring_positions(text, substrings, case_sensitive=False) -> {'hello': [0, 7]} (depending on positions)\n\nIf you\u2019d like, I can tailor this to a different language (e.g., JavaScript) or adjust the return format (e.g., include substrings with no matches as empty lists or return a flat list of (substring, index) tuples)."}
{"task_id": "Mbpp/790", "completion": "Here's a concise Python function that checks whether every even index (0-based) holds an even integer. It returns True for an empty list.\n\n```python\ndef all_even_indices_have_even_numbers(lst):\n    \"\"\"\n    Return True if every element at an even index is an even integer.\n    Empty list -> True. Non-integer or odd values at even indices -> False.\n    \"\"\"\n    return all(isinstance(lst[i], int) and lst[i] % 2 == 0 for i in range(0, len(lst), 2))\n```\n\nUsage examples:\n- all_even_indices_have_even_numbers([2, 3, 4, 5]) -> True\n- all_even_indices_have_even_numbers([1, 2, 4]) -> False (index 0 has 1)\n- all_even_indices_have_even_numbers([]) -> True\n- all_even_indices_have_even_numbers([2.0, 3]) -> False (2.0 is not an int)"}
{"task_id": "Mbpp/787", "completion": "Here\u2019s a simple approach using a regex for \u201can a followed by three b\u2019s\u201d (i.e., the substring \"abbb\").\n\n- Regex: ab{3}\n- If you want the substring anywhere in the string, search for ab{3}.\n- If you want the entire string to be exactly \"abbb\", use ^ab{3}$.\n\nExamples (Python and JavaScript):\n\nPython\ndef contains_abbb(s):\n    import re\n    return bool(re.search(r'ab{3}', s))\n\ndef is_only_abbb(s):\n    import re\n    return bool(re.fullmatch(r'ab{3}', s))\n\nJavaScript\nfunction containsAbbb(s) {\n  return /ab{3}/.test(s);\n}\n\nfunction isOnlyAbbb(s) {\n  return /^ab{3}$/.test(s);\n}"}
{"task_id": "Mbpp/780", "completion": "Here\u2019s a Python function that finds all possible sums by picking one element from each tuple in a list of tuples. It uses itertools.product to generate all combinations.\n\nCode:\n\nfrom itertools import product\n\ndef combinations_sums(tuple_list, as_dict=False):\n    \"\"\"\n    Given a list of tuples (or lists) of numbers, return sums of all combinations\n    formed by picking one element from each tuple.\n\n    - If as_dict is False (default), returns a list of sums (one per combination).\n    - If as_dict is True, returns a dict mapping each sum to the list of combinations\n      (tuples) that yield that sum.\n    \"\"\"\n    if not tuple_list:\n        return {} if as_dict else []\n\n    if as_dict:\n        result = {}\n        for combo in product(*tuple_list):\n            s = sum(combo)\n            result.setdefault(s, []).append(combo)\n        return result\n    else:\n        return [sum(combo) for combo in product(*tuple_list)]\n\n# Example usage\ntuples = [(1, 2), (3, 4), (5, 6)]\nprint(combinations_sums(tuples))  # [9, 10, 10, 11, 10, 11, 11, 12]\nprint(combinations_sums(tuples, as_dict=True))\n# {9: [(1, 3, 5)],\n#  10: [(1, 3, 6), (1, 4, 5), (2, 3, 5)],\n#  11: [(1, 4, 6), (2, 3, 6), (2, 4, 5)],\n#  12: [(2, 4, 6)]}\n\nNotes:\n- The number of sums equals the product of the lengths of the input tuples (i.e., total number of combinations).\n- If you\u2019re dealing with large inputs, consider returning a generator instead of materializing all results at once. You can use a generator version by replacing the list comprehensions with yield in a loop."}
{"task_id": "Mbpp/786", "completion": "Here\u2019s a simple binary-search-based function that returns the right insertion point (i.e., the index after any existing elements equal to the value) to keep a list sorted in non-decreasing order.\n\nPython implementation (with optional key function):\ndef insertion_point_right(sorted_list, value, key=None):\n    \"\"\"\n    Return the index where 'value' should be inserted to keep 'sorted_list' sorted.\n    This is the 'right' insertion point: after any existing elements equal to 'value'.\n    If key is provided, comparison is done on key(item).\n    \"\"\"\n    lo, hi = 0, len(sorted_list)\n    if key is None:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if sorted_list[mid] <= value:\n                lo = mid + 1\n            else:\n                hi = mid\n    else:\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if key(sorted_list[mid]) <= value:\n                lo = mid + 1\n            else:\n                hi = mid\n    return lo\n\nUsage examples:\narr = [1, 2, 4, 4, 6]\nprint(insertion_point_right(arr, 4))  # outputs 4\nprint(insertion_point_right(arr, 5))  # outputs 4 (insert before 6)\nprint(insertion_point_right(arr, 0))  # outputs 0\n\nNotes:\n- Time complexity: O(log n)\n- It returns len(sorted_list) if value is greater than all elements.\n- The optional key parameter lets you insert objects based on a projected key (e.g., key=lambda x: x.score)."}
{"task_id": "Mbpp/793", "completion": "Here\u2019s a Python function that finds the last (rightmost) position of a target in a sorted array using binary search. It returns -1 if the target is not found.\n\n```python\ndef last_position(arr, target):\n    left, right = 0, len(arr) - 1\n    last = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] > target:\n            right = mid - 1\n        else:\n            # arr[mid] <= target\n            if arr[mid] == target:\n                last = mid\n            left = mid + 1\n    return last\n\n# Example\n# arr = [1, 2, 2, 2, 3, 4]\n# last_position(arr, 2) -> 3\n# last_position(arr, 5) -> -1\n```\n\nIf you prefer using the standard library:\n\n```python\nimport bisect\n\ndef last_position_bisect(arr, target):\n    idx = bisect.bisect_right(arr, target) - 1\n    return idx if idx >= 0 and arr[idx] == target else -1\n```"}
{"task_id": "Mbpp/739", "completion": "Here's a Python function that returns the index k of the smallest triangular number T_k with exactly n digits.\n\nTriangular numbers: T_k = k*(k+1)/2.\n\nApproach:\n- Let L = 10^(n-1). We want the smallest k such that T_k >= L.\n- Use D = 1 + 8*L and compute s = floor(sqrt(D)) using math.isqrt.\n- Based on whether D is a perfect square and the parity of s, compute k without using floating-point arithmetic.\n- If needed, adjust k upward to ensure T_k has exactly n digits.\n\nCode:\n\n```python\nimport math\n\ndef index_of_smallest_triangular_with_n_digits(n: int) -> int:\n    \"\"\"\n    Return the index k of the smallest triangular number T_k that has exactly n digits.\n\n    T_k = k*(k+1)//2\n    \"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n\n    # Lower bound for n-digit numbers\n    L = 10**(n - 1)\n    D = 1 + 8 * L\n\n    s = math.isqrt(D)  # floor(sqrt(D))\n\n    if s * s == D:\n        k = s // 2\n    else:\n        # If D is not a perfect square\n        if s % 2 == 1:       # s is odd\n            k = (s + 1) // 2\n        else:                  # s is even\n            k = s // 2\n\n    # Ensure T_k >= L\n    Tk = k * (k + 1) // 2\n    while Tk < L:\n        k += 1\n        Tk = k * (k + 1) // 2\n\n    # Sanity check: Tk should be less than 10^n for a valid n-digit number\n    if Tk >= 10**n:\n        raise ValueError(f\"No triangular number with exactly {n} digits\")\n\n    return k\n\n# Example usage:\nif __name__ == \"__main__\":\n    for n in range(1, 6):\n        print(f\"Digits: {n}, Index: {index_of_smallest_triangular_with_n_digits(n)}\")\n```\n\nExpected output:\n- n = 1 -> 1 (T_1 = 1)\n- n = 2 -> 4 (T_4 = 10)\n- n = 3 -> 14 (T_14 = 105)\n- n = 4 -> 45 (T_45 = 1035)\n- n = 5 -> 141 (T_141 = 10011)\n\nThis implementation uses only integer arithmetic (no floating-point) and handles large n efficiently thanks to Python\u2019s big integers and math.isqrt."}
{"task_id": "Mbpp/748", "completion": "Here are a few clean ways to do it. I\u2019ll show Python and JavaScript versions (with both simple and a more robust approach). If you\u2019re using a different language, tell me and I\u2019ll adapt.\n\nPython\n\n- Simple (inserts a space before every uppercase letter except the first; may break with acronyms)\ndef insert_spaces_simple(s):\n    if not s:\n        return s\n    res = []\n    for i, ch in enumerate(s):\n        if i > 0 and ch.isupper():\n            res.append(' ')\n        res.append(ch)\n    return ''.join(res)\n\n- Robust (uses regex to split only when a capital starts a new word, keeps acronyms together like XMLHttpRequest -> \"XML Http Request\")\nimport re\n\ndef insert_spaces_robust(s):\n    # Split before a capital letter that starts a new word, but not at the start\n    # This handles things like \"XMLHttpRequest\" -> \"XML Http Request\"\n    return re.sub(r'(?<!^)(?=[A-Z][a-z])', ' ', s)\n\nExamples:\n- insert_spaces_simple(\"ThisIsATest\") -> \"This Is A Test\"\n- insert_spaces_robust(\"ThisIsATest\") -> \"This Is A Test\"\n- insert_spaces_robust(\"XMLHttpRequest\") -> \"XML Http Request\"\n\nJavaScript\n\n- Simple (inserts a space before every uppercase letter except the first)\nfunction insertSpacesSimple(str) {\n  if (!str) return str;\n  let res = [];\n  for (let i = 0; i < str.length; i++) {\n    const ch = str[i];\n    if (i > 0 && /[A-Z]/.test(ch)) res.push(' ');\n    res.push(ch);\n  }\n  return res.join('');\n}\n\n- Robust (modern browsers with lookbehind)\nfunction insertSpacesRobust(str) {\n  // Splits before a capital letter that starts a new word, not at the start\n  return str.replace(/(?<!^)(?=[A-Z][a-z])/g, ' ');\n}\n\n- Legacy version (no lookbehind; splits only where a lowercase/digit is followed by an uppercase)\nfunction insertSpacesLegacy(str) {\n  return str.replace(/([a-z0-9])([A-Z])/g, '$1 $2');\n}\n\nExamples:\n- insertSpacesSimple(\"ThisIsATest\") -> \"This Is A Test\"\n- insertSpacesRobust(\"ThisIsATest\") -> \"This Is A Test\"\n- insertSpacesRobust(\"XMLHttpRequest\") -> \"XML Http Request\"\n- insertSpacesLegacy(\"XMLHttpRequest\") -> \"XML Http Request\"\n\nIf you share the exact language you\u2019re using and whether you want to preserve acronyms (XML, HTTP, etc.) as single words, I can tailor the solution precisely."}
{"task_id": "Mbpp/788", "completion": "Here are a few common interpretations. Pick the one you want, or tell me your exact requirement and I\u2019ll tailor it.\n\nOption 1: string as a single element, list as a single element\n- Output: (string, list)\n\ndef make_tuple_pair(s, lst):\n    return (s, lst)\n\n# Example\n# make_tuple_pair(\"hello\", [1, 2, 3]) -> (\"hello\", [1, 2, 3])\n\nOption 2: string as a single element, but list items become separate elements\n- Output: (string, item1, item2, ...)\n\ndef make_tuple_elements(s, lst):\n    return (s, *lst)\n\n# Example\n# make_tuple_elements(\"hello\", [1, 2, 3]) -> (\"hello\", 1, 2, 3)\n\nOption 3: string characters expanded, then list items\n- Output: ('h', 'e', 'l', 'l', 'o', 1, 2, 3)\n\ndef make_tuple_flatten(s, lst):\n    return tuple(s) + tuple(lst)\n\n# Example\n# make_tuple_flatten(\"hello\", [1, 2, 3]) -> ('h', 'e', 'l', 'l', 'o', 1, 2, 3)\n\nIf you\u2019d like, tell me exactly how you want the string and list combined (e.g., always treat the string as a single element, or always flatten the string into characters), and I\u2019ll provide a single function for that."}
{"task_id": "Mbpp/770", "completion": "Here's a concise Python function using the closed-form formula:\n\ndef sum_fourth_powers_of_first_n_odds(n: int) -> int:\n    \"\"\"\n    Sum of fourth powers of the first n odd natural numbers:\n    1^4 + 3^4 + ... + (2n-1)^4 = n*(48*n**4 - 40*n**2 + 7) / 15\n    \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return n * (48 * n**4 - 40 * n**2 + 7) // 15\n\n# Example:\n# sum_fourth_powers_of_first_n_odds(3) -> 707\n"}
{"task_id": "Mbpp/765", "completion": "Polite numbers are positive integers that are not powers of two (1, 2, 4, 8, \u2026 are not polite; 3, 5, 6, 7, \u2026 are polite). The n-th polite number is the n-th positive integer that is not a power of two.\n\nA fast way to find it is by binary search:\n- Let countPolite(x) be the count of polite numbers in [1, x].\n- countPolite(x) = x - (number of powers of two <= x).\n- The number of powers of two <= x is floor(log2(x)) + 1, which we can compute efficiently (bit_length in Python, clzll in C++).\n\nThen find the smallest x such that countPolite(x) >= n.\n\nC++ (GNU C++, 64-bit)\n- This uses __builtin_clzll to get the number of powers of two <= x.\n\nlong long nth_polite(long long n) {\n    if (n <= 0) return 0;\n    long long lo = 1, hi = n + 64; // safe upper bound\n    while (lo < hi) {\n        long long mid = lo + (hi - lo) / 2;\n        // number of powers of two <= mid\n        int pow2count = 64 - __builtin_clzll(mid);\n        long long cnt = mid - pow2count; // count of polite numbers <= mid\n        if (cnt >= n) hi = mid;\n        else lo = mid + 1;\n    }\n    return lo;\n}\n\nPython (easy to read)\ndef nth_polite(n):\n    lo, hi = 1, n + 64  # safe upper bound\n    while lo < hi:\n        mid = (lo + hi) // 2\n        # number of powers of two <= mid is mid.bit_length()\n        cnt = mid - mid.bit_length()\n        if cnt >= n:\n            hi = mid\n        else:\n            lo = mid + 1\n    return lo\n\nUsage example:\n- nth_polite(1) -> 3\n- nth_polite(2) -> 5\n- nth_polite(3) -> 6\n\nComplexity:\n- Each countPolite evaluation is O(1) (bit tricks). Binary search over x runs in O(log n) steps.\n- Overall: O(log n) time, O(1) extra space. This handles large n efficiently."}
{"task_id": "Mbpp/792", "completion": "Here are two Python helpers, covering common interpretations:\n\n1) Count how many elements at the top level are lists (in a list of lists)\n2) Count all lists inside a (potentially nested) structure recursively\n\nCode:\n\n- Top-level lists only\ndef count_top_level_lists(container):\n    \"\"\"\n    Count how many elements at the top level of 'container' are lists.\n    \"\"\"\n    return sum(1 for item in container if isinstance(item, list))\n\n# Example\nlst = [1, [2, 3], 'a', [4], [5, 6], {'a': 1}, (7, 8)]\nprint(count_top_level_lists(lst))  # Output: 3\n\n- All lists recursively (counts every list found, including the outermost if it\u2019s a list)\ndef count_all_lists(obj):\n    \"\"\"\n    Recursively count all lists contained in a (potentially nested) structure.\n    Counts each list encountered, including the outermost one if it's a list.\n    \"\"\"\n    count = 0\n    if isinstance(obj, list):\n        count += 1\n        for item in obj:\n            count += count_all_lists(item)\n    elif isinstance(obj, (tuple, set)):\n        for item in obj:\n            count += count_all_lists(item)\n    return count\n\n# Example\nnested = [1, [2, [3, 4], []], (5, [6, []])]\nprint(count_all_lists(nested))  # Output: 7\n\nIf you had a different interpretation in mind, tell me a bit more about the input shape and I can tailor the function."}
{"task_id": "Mbpp/794", "completion": "Here are a few common language options. The core idea is the regex a.*b$ which means: an 'a', then any characters, and the string ends with 'b'.\n\nPython\n- Use the pattern r'a.*b$' with re.search\n\nimport re\n\ndef matches(s: str) -> bool:\n    return bool(re.search(r'a.*b$', s))\n\n# Examples\n# matches(\"ab\") -> True\n# matches(\"a123b\") -> True\n# matches(\"zaaab\") -> True\n# matches(\"ba\") -> False\n# matches(\"a\") -> False\n\nJavaScript\n- Use the same pattern with /a.*b$/\n\nfunction matchesString(s) {\n  return /a.*b$/.test(s);\n}\n\n// Examples\n// matchesString(\"ab\") -> true\n// matchesString(\"a123b\") -> true\n// matchesString(\"ba\") -> false\n\nJava\n- Use Pattern and Matcher\n\nimport java.util.regex.Pattern;\n\npublic class RegexMatcher {\n    private static final Pattern PATTERN = Pattern.compile(\"a.*b$\");\n\n    public static boolean matches(String s) {\n        return PATTERN.matcher(s).find();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(matches(\"ab\"));      // true\n        System.out.println(matches(\"a123b\"));   // true\n        System.out.println(matches(\"ba\"));      // false\n    }\n}\n\nNotes\n- The pattern a.*b$ ensures there is an 'a' somewhere, followed by any characters, and the entire string ends with a 'b'.\n- If you want to require the string to start with 'a' (i.e., begins with 'a' and ends with 'b'), use ^a.*b$.\n- If you want the search to be case-insensitive, add the appropriate flags (e.g., re.IGNORECASE in Python, /i in JavaScript, Pattern.CASE_INSENSITIVE in Java).\n\nIf you tell me your preferred language, I can tailor the exact function accordingly."}
{"task_id": "Mbpp/804", "completion": "Here's a simple Python function. The product is even if any number in the list is even.\n\n```python\ndef is_product_even(numbers):\n    \"\"\"\n    Return True if the product of the numbers is even, otherwise False.\n    Assumes numbers contains integers. An empty list yields False\n    (product is 1, which is odd).\n    \"\"\"\n    return any(n % 2 == 0 for n in numbers)\n```\n\nUsage examples:\n- is_product_even([1, 3, 5]) -> False\n- is_product_even([1, 2, 3]) -> True\n- is_product_even([]) -> False\n\nNotes:\n- A product is even if at least one factor is even.\n- This avoids large product values and runs in O(n) time."}
{"task_id": "Mbpp/797", "completion": "Here\u2019s a Python function that returns the sum of all odd natural numbers in the inclusive range [l, r]. It clamps the range to natural numbers (>= 1) and uses an O(1) formula.\n\n```python\ndef sum_odd_naturals_in_range(l, r):\n    \"\"\"\n    Sum of all odd natural numbers in [l, r] (inclusive).\n    Natural numbers start at 1. If there are no natural odds in the range, returns 0.\n    \"\"\"\n    if l > r:\n        return 0\n\n    start = max(l, 1)\n    if start > r:\n        return 0\n\n    def sum_odds_upto(n):\n        if n < 1:\n            return 0\n        k = (n + 1) // 2  # number of odd numbers in [1, n]\n        return k * k        # sum of first k odd numbers\n\n    return sum_odds_upto(r) - sum_odds_upto(start - 1)\n```\n\nExamples:\n- sum_odd_naturals_in_range(1, 10) -> 25 (1 + 3 + 5 + 7 + 9)\n- sum_odd_naturals_in_range(3, 3)  -> 3\n- sum_odd_naturals_in_range(-5, 9) -> 25\n\nIf you want to sum odds in any integer range (not restricting to natural numbers), we can adjust accordingly."}
{"task_id": "Mbpp/798", "completion": "Here are two simple options.\n\nOption 1: Use Python's built-in sum\n```python\ndef sum_array(arr):\n    \"\"\"Return the sum of numeric elements in arr.\"\"\"\n    return sum(arr)\n```\n\nOption 2: Manual summation (no built-in sum)\n```python\ndef sum_array(arr):\n    \"\"\"Return the sum of numeric elements in arr (manual implementation).\"\"\"\n    total = 0\n    for x in arr:\n        total += x\n    return total\n```\n\nUsage:\n```python\nexample = [1, 2, 3, 4.5]\nprint(sum_array(example))  # 10.5\n```\n\nNotes:\n- Both assume arr is an iterable of numbers (ints/floats). If elements aren\u2019t numeric, you\u2019ll get a TypeError.\n- You can add type hints if you like, e.g., def sum_array(arr: list[float] | list[int]) -> float:."}
{"task_id": "Mbpp/791", "completion": "Here are two common interpretations and corresponding Python functions.\n\n1) Remove only the top-level elements that are tuples (keep the rest)\n- This keeps non-tuple elements and drops any direct tuple elements at the top level.\n\n```python\ndef remove_tuple_elements(tup):\n    \"\"\"Return a new tuple with non-tuple elements from the top level only.\"\"\"\n    return tuple(x for x in tup if not isinstance(x, tuple))\n```\n\nExample:\n- Input: (1, (2, 3), 'a', (4,))\n- Output: (1, 'a')\n\n2) Remove all tuple wrappers and flatten any nested tuples (keep only non-tuple values, in order)\n- This unwraps nested tuples and returns a flat tuple of all non-tuple elements.\n\n```python\ndef flatten_and_remove_tuples(tup):\n    \"\"\"Return a flat tuple containing all non-tuple elements by recursively unwrapping tuples.\"\"\"\n    def unwrap(x):\n        if isinstance(x, tuple):\n            acc = []\n            for y in x:\n                acc.extend(unwrap(y))\n            return acc\n        else:\n            return [x]\n\n    res = []\n    for item in tup:\n        res.extend(unwrap(item))\n    return tuple(res)\n```\n\nExample:\n- Input: (1, (2, 3), 'a', (4, (5, 6)))\n- Output: (1, 2, 3, 'a', 4, 5, 6)\n\nIf you had a different interpretation in mind, tell me and I\u2019ll tailor the function."}
{"task_id": "Mbpp/800", "completion": "Here are simple implementations in several popular languages. They remove all whitespace characters (spaces, tabs, newlines, etc.).\n\n- Python\n  def remove_whitespace(s: str) -> str:\n      return ''.join(s.split())\n\n  # or using regex\n  # import re\n  # def remove_whitespace(s: str) -> str:\n  #     return re.sub(r'\\s+', '', s)\n\n- JavaScript\n  function removeWhitespace(str) {\n      return str.replace(/\\s+/g, '');\n  }\n\n- Java\n  public static String removeWhitespace(String s) {\n      return s.replaceAll(\"\\\\s+\", \"\");\n  }\n\n- C++\n  #include <string>\n  #include <cctype>\n  std::string removeWhitespace(const std::string& s) {\n      std::string r;\n      r.reserve(s.size());\n      for (unsigned char c : s) {\n          if (!std::isspace(c)) r.push_back(static_cast<char>(c));\n      }\n      return r;\n  }\n\n- C#\n  using System.Linq;\n  public static string RemoveWhitespace(string input) {\n      return string.Concat(input.Where(c => !char.IsWhiteSpace(c)));\n  }\n\n- Go\n  import \"unicode\"\n\n  func RemoveWhitespace(s string) string {\n      // Build from runes to correctly handle Unicode whitespace\n      b := make([]rune, 0, len(s))\n      for _, r := range s {\n          if !unicode.IsSpace(r) {\n              b = append(b, r)\n          }\n      }\n      return string(b)\n  }\n\nNotes:\n- These typically run in O(n) time and use O(n) extra space (for the result).\n- If you only want to remove ASCII spaces, you can tailor the logic to exclude only ' ' or '\\t', but the above versions remove all Unicode whitespace."}
{"task_id": "Mbpp/805", "completion": "Here\u2019s a simple Python function that returns the sublist (from a list of lists) whose elements sum to the highest value.\n\ndef max_sum_sublist(list_of_lists):\n    \"\"\"\n    Return the sublist with the highest sum of its elements.\n    If multiple sublists have the same maximum sum, returns the first one.\n    If input is empty, returns None.\n    Assumes all elements are numeric.\n    \"\"\"\n    if not list_of_lists:\n        return None\n    return max(list_of_lists, key=sum)\n\n# Example\ndata = [[1, 2, 3], [4, -1], [2, 2, 2]]\nprint(max_sum_sublist(data))  # Output: [1, 2, 3]\n\nNotes:\n- If you want all sublists that tie for the maximum sum, you can compute the max sum first and then filter:\n# all_ties = [sub for sub in data if sum(sub) == max(sum(s) for s in data)]\n# This would return all sublists with the maximum sum."}
{"task_id": "Mbpp/801", "completion": "Here's a simple function that returns:\n- 3 if all three numbers are equal\n- 2 if exactly two of them are equal\n- 0 if all are distinct\n\ndef count_equal_numbers(a: int, b: int, c: int) -> int:\n    \"\"\"\n    Returns the count of equal numbers among three integers:\n    3 if all equal, 2 if exactly two are equal, 0 if all distinct.\n    \"\"\"\n    if a == b == c:\n        return 3\n    if a == b or b == c or a == c:\n        return 2\n    return 0\n\n# Example usage:\nprint(count_equal_numbers(1, 1, 1))  # 3\nprint(count_equal_numbers(1, 1, 2))  # 2\nprint(count_equal_numbers(1, 2, 3))  # 0"}
{"task_id": "Mbpp/807", "completion": "Here's a simple function to return the first odd number in a list (or None if there is none):\n\n```python\ndef first_odd(nums):\n    \"\"\"\n    Return the first odd number from the list `nums`.\n    If no odd number exists, return None.\n    Assumes the list contains integers.\n    \"\"\"\n    for n in nums:\n        if n % 2 != 0:\n            return n\n    return None\n```\n\nUsage examples:\n- first_odd([2, 4, 6, 7, 9]) -> 7\n- first_odd([2, 4, 6]) -> None\n\nIf you prefer a concise version using a generator:\n\n```python\ndef first_odd(nums):\n    return next((n for n in nums if n % 2 != 0), None)\n```\n\nNote: These assume the list contains integers. If you need to handle non-integer values, you might add type checks."}
{"task_id": "Mbpp/809", "completion": "Here's a simple Python function that checks if every element of the second tuple is smaller than the corresponding element in the first tuple. It requires the tuples to be the same length.\n\n```python\nfrom typing import Tuple, Any\n\ndef all_second_smaller(first: Tuple[Any, ...], second: Tuple[Any, ...]) -> bool:\n    if len(first) != len(second):\n        raise ValueError(\"Tuples must be of the same length.\")\n    return all(s < f for f, s in zip(first, second))\n```\n\nUsage example:\n```python\nt1 = (5, 3, 9)\nt2 = (1, 2, 8)\n\nprint(all_second_smaller(t1, t2))  # True\n\nt3 = (5, 3, 7)\nt4 = (4, 4, 8)\nprint(all_second_smaller(t3, t4))  # False\n```\n\nIf you prefer not to raise an exception on mismatched lengths and just return False, you can use:\n\n```python\ndef all_second_smaller_no_exception(first: Tuple[Any, ...], second: Tuple[Any, ...]) -> bool:\n    if len(first) != len(second):\n        return False\n    return all(s < f for f, s in zip(first, second))\n```"}
{"task_id": "Mbpp/806", "completion": "Here's a Python function that finds the maximum run of consecutive uppercase letters in a string and returns the length, the start index, and the substring itself.\n\n```python\ndef max_upper_run(s: str):\n    \"\"\"\n    Returns a tuple: (max_length, start_index, run_substring)\n    If there is no uppercase letter, returns (0, -1, \"\").\n    \"\"\"\n    max_len = 0\n    current_len = 0\n    max_start = -1\n    current_start = 0\n\n    for i, ch in enumerate(s):\n        if 'A' <= ch <= 'Z':\n            if current_len == 0:\n                current_start = i\n            current_len += 1\n            if current_len > max_len:\n                max_len = current_len\n                max_start = current_start\n        else:\n            current_len = 0\n\n    if max_len == 0:\n        return 0, -1, \"\"\n    return max_len, max_start, s[max_start:max_start + max_len]\n```\n\nExamples:\n- max_upper_run(\"abCDEfGHIJKLmnopQR\") returns (6, 6, 'GHIJKL')\n- max_upper_run(\"abc\") returns (0, -1, \"\")\n\nNotes:\n- Time complexity: O(n), where n is the length of the string.\n- Space complexity: O(1). \n- Non-letter characters reset the current run."}
{"task_id": "Mbpp/796", "completion": "Here are Python examples to sum numeric values in a dictionary.\n\n1) Simple version (flat dictionary, only numeric values)\n- Sums values that are numbers; non-numeric values are ignored.\n\ndef sum_dict_values(d):\n    \"\"\"\n    Sum numeric values in a (flat) dictionary.\n    Non-numeric values are ignored.\n    Booleans are ignored.\n    \"\"\"\n    return sum(v for v in d.values() if isinstance(v, (int, float)) and not isinstance(v, bool))\n\n2) Recursive version (handles nested dicts and iterables)\n- Traverses dictionaries recursively and sums numeric leaves. Non-numeric values are ignored.\n\ndef sum_values(d):\n    total = 0\n    for v in d.values():\n        if isinstance(v, dict):\n            total += sum_values(v)\n        elif isinstance(v, (int, float)) and not isinstance(v, bool):\n            total += v\n        elif isinstance(v, (list, tuple, set)):\n            total += sum_values_in_iterable(v)\n    return total\n\ndef sum_values_in_iterable(it):\n    total = 0\n    for item in it:\n        if isinstance(item, dict):\n            total += sum_values(item)\n        elif isinstance(item, (int, float)) and not isinstance(item, bool):\n            total += item\n        elif isinstance(item, (list, tuple, set)):\n            total += sum_values_in_iterable(item)\n    return total\n\nUsage examples:\n\nd1 = {'a': 1, 'b': 2.5, 'c': 'x'}\nprint(sum_dict_values(d1))  # 3.5\n\nd2 = {'a': 1, 'b': {'ba': 2, 'bb': 3}, 'c': [4, 5, {'d': 6}]}\nprint(sum_values(d2))  # 21\n\nIf you want a version tailored to a specific language (e.g., JavaScript) or with different behavior (e.g., include booleans as 0/1), tell me and I\u2019ll adjust it."}
{"task_id": "Mbpp/803", "completion": "Here are two robust ways to implement a function that checks if a given number is a perfect square in C++.\n\nOption 1: Binary search (no floating-point, safe for very large integers)\n- Uses 128-bit intermediate to avoid overflow when squaring mid.\n\nCode:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(unsigned long long n) {\n    // 0 and 1 are trivial cases\n    if (n < 2) return true;\n\n    unsigned long long l = 0, r = n;\n    while (l <= r) {\n        unsigned long long mid = l + (r - l) / 2;\n        __int128 sq = ( __int128 )mid * mid; // avoid 64-bit overflow\n\n        if (sq == n) return true;\n        if (sq < n) l = mid + 1;\n        else        r = mid - 1;\n    }\n    return false;\n}\n\nint main() {\n    unsigned long long n;\n    if (!(cin >> n)) return 0;\n    cout << (isPerfectSquare(n) ? \"Yes\" : \"No\") << \"\\n\";\n    return 0;\n}\n```\n\nNotes:\n- Works up to 2^64 \u2212 1 for n.\n- Time complexity: O(log n).\n\nOption 2: Using sqrt with careful checking (concise)\n- Uses floating-point sqrt to get an approximate root, then checks nearby integers.\n- Works well for 64-bit integers when long double precision is used.\n\nCode:\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\nbool isPerfectSquare(unsigned long long n) {\n    if (n < 2) return true; // 0 and 1 are perfect squares\n\n    unsigned long long s = (unsigned long long) sqrt((long double) n);\n    // Check the candidate and the next one in case of rounding\n    return s * s == n || (s + 1) * (s + 1) == n;\n}\n\nint main() {\n    unsigned long long n;\n    if (!(cin >> n)) return 0;\n    cout << (isPerfectSquare(n) ? \"Yes\" : \"No\") << \"\\n\";\n    return 0;\n}\n```\n\nChoosing between them:\n- If you want a pure integer approach with guaranteed correctness across very large inputs, use the binary-search version.\n- If you prefer a shorter solution and are comfortable with floating-point use, the sqrt-based version is fine and typically fast."}
{"task_id": "Mbpp/799", "completion": "Here\u2019s a simple left-rotate (circular shift) by d bits for a 32-bit value. The amount d is taken modulo 32.\n\nC (C11, using uint32_t)\n- Handles d = 0 safely\n#include <stdint.h>\n\nstatic inline uint32_t rotl32(uint32_t x, unsigned int d) {\n    d &= 31; // d mod 32\n    if (d == 0) return x;\n    return (x << d) | (x >> (32 - d));\n}\n\nPython\ndef rotl32(x: int, d: int) -> int:\n    x &= 0xFFFFFFFF\n    d &= 31\n    return ((x << d) | (x >> (32 - d))) & 0xFFFFFFFF\n\nJava\npublic static int rotl32(int x, int d) {\n    int r = d & 31;\n    if (r == 0) return x;\n    return (x << r) | (x >>> (32 - r));\n}\n\nGo\nfunc rotl32(x uint32, d uint32) uint32 {\n    d &= 31\n    if d == 0 {\n        return x\n    }\n    return (x << d) | (x >> (32 - d))\n}\n\nRust (no standard rotate_left needed, or use it)\nfn rotl32(x: u32, n: u32) -> u32 {\n    let n = n & 31;\n    if n == 0 { x } else { (x << n) | (x >> (32 - n)) }\n}\n# Alternatively, x.rotate_left(n) is built-in.\n\nJavaScript (ECMAScript 2020+)\nfunction rotl32(x, d) {\n  x = x >>> 0;\n  d &= 31;\n  if (d === 0) return x;\n  return ((x << d) | (x >>> (32 - d))) >>> 0;\n}\n\nNotes\n- This performs a 32-bit left rotation: bits shifted out on the left re-enter on the right.\n- Always reduce d modulo 32 to avoid undefined behavior from shifting by 32.\n- If your language uses signed 32-bit ints (e.g., Java), the unsigned right shift (>>>) or masking helps ensure proper behavior."}
{"task_id": "Mbpp/782", "completion": "Here\u2019s an efficient O(n) solution that computes the sum of all odd-length subarrays.\n\nIdea:\n- For each index i, determine how many odd-length subarrays include a[i].\n- Let left = i + 1 (number of choices for the left boundary) and right = n - i (for the right boundary).\n- If i is even, the count is ceil(left * right / 2) = (left * right + 1) // 2.\n- If i is odd, the count is floor(left * right / 2) = (left * right) // 2.\n- Multiply a[i] by this count and accumulate.\n\nPython function:\n\n```python\ndef sum_of_odd_length_subarrays(arr):\n    n = len(arr)\n    total = 0\n    for i, val in enumerate(arr):\n        left = i + 1\n        right = n - i\n        if i % 2 == 0:  # i is even\n            count = (left * right + 1) // 2\n        else:  # i is odd\n            count = (left * right) // 2\n        total += val * count\n    return total\n\n# Example\n# arr = [1, 4, 2, 5, 3]\n# print(sum_of_odd_length_subarrays(arr))  # Output: 58\n```\n\nNotes:\n- Works for any integers (including negatives).\n- Time complexity: O(n)\n- Space complexity: O(1)\n\nIf you\u2019d like, I can also show a straightforward brute-force version (O(n^2)) for small inputs."}
{"task_id": "Mbpp/808", "completion": "Here are a few Python options depending on what you mean by \u201ccontains k\u201d in a collection of tuples.\n\nOption 1: Check if k appears in any position of any tuple\n- Returns True if k is found in any element of any tuple.\n\ndef contains_in_any_position(tuples_iterable, k):\n    return any(k in t for t in tuples_iterable if isinstance(t, tuple))\n\n# Example\ntuples_list = [(1, 2), (3, 4), (5, 6)]\nprint(contains_in_any_position(tuples_list, 4))  # True\nprint(contains_in_any_position(tuples_list, 7))  # False\n\nOption 2: Check if k is the first element of any tuple\n- Useful if your tuples are key-value pairs and you want to check for a specific key.\n\ndef contains_in_first_position(tuples_iterable, k):\n    return any(len(t) > 0 and t[0] == k for t in tuples_iterable if isinstance(t, tuple))\n\n# Example\ntuples_list = [(1, 'a'), (2, 'b'), (3, 'c')]\nprint(contains_in_first_position(tuples_list, 2))  # True\nprint(contains_in_first_position(tuples_list, 4))  # False\n\nOption 3: If you want a single function with a mode flag\n- You can switch between checking any position or only the first element.\n\ndef contains_k(tuples_iterable, k, first_only=False):\n    if first_only:\n        return any(len(t) > 0 and t[0] == k for t in tuples_iterable if isinstance(t, tuple))\n    return any(isinstance(t, tuple) and k in t for t in tuples_iterable)\n\n# Example\ntuples_list = [(1, 2), (3, 4), (5, 6)]\nprint(contains_k(tuples_list, 4))        # True (in any position)\nprint(contains_k(tuples_list, 3, True))  # True (as first element)\n\nNotes:\n- These assume you have an iterable of tuples. If there might be non-tuple items, the checks ensure we skip them safely.\n- If you\u2019re dealing with exactly 2-tuples (key-value pairs), you can tailor the function accordingly (e.g., t[0] for key). \n\nIf you tell me the exact input shape and the language you\u2019re using, I can tailor the function precisely."}
